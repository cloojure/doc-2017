<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>clojure.core.matrix.protocols documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Core.matrix 0.31.2-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></div></li><li class="depth-3"><a href="clojure.core.matrix.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matrix</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.compliance-tester.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>compliance-tester</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.dataset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dataset</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.experimental.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>experimental</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.generic.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generic</span></div></a></li><li class="depth-4"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>impl</span></div></div></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.clojure.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.common.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>common</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.dataset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dataset</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.default.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>default</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.double-array.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>double-array</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.index.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>index</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.mathsops.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mathsops</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.ndarray.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ndarray</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.ndarray-double.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ndarray-double</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.ndarray-macro.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ndarray-macro</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.ndarray-magic.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ndarray-magic</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.ndarray-object.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ndarray-object</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.object-array.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>object-array</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.persistent-vector.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>persistent-vector</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.pprint.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pprint</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.sequence.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sequence</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.sparse-map.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sparse-map</span></div></a></li><li class="depth-5"><a href="clojure.core.matrix.impl.wrappers.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>wrappers</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.implementations.html"><div class="inner"><span class="tree" style="top: -579px;"><span class="top" style="height: 588px;"></span><span class="bottom"></span></span><span>implementations</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.io.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>io</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.linear.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>linear</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.multimethods.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>multimethods</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.operators.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>operators</span></div></a></li><li class="depth-4 branch current"><a href="clojure.core.matrix.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.select.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>select</span></div></a></li><li class="depth-4"><a href="clojure.core.matrix.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-broadcast-compatible"><div class="inner"><span>broadcast-compatible</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-ensure-type"><div class="inner"><span>ensure-type</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PAddProduct"><div class="inner"><span>PAddProduct</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-add-product"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>add-product</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PAddProductMutable"><div class="inner"><span>PAddProductMutable</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-add-product.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>add-product!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PAddScaled"><div class="inner"><span>PAddScaled</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-add-scaled"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>add-scaled</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PAddScaledMutable"><div class="inner"><span>PAddScaledMutable</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-add-scaled.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>add-scaled!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PAddScaledProduct"><div class="inner"><span>PAddScaledProduct</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-add-scaled-product"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>add-scaled-product</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PAddScaledProductMutable"><div class="inner"><span>PAddScaledProductMutable</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-add-scaled-product.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>add-scaled-product!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PArrayMetrics"><div class="inner"><span>PArrayMetrics</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-nonzero-count"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nonzero-count</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PAssignment"><div class="inner"><span>PAssignment</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-assign.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>assign!</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-assign-array.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>assign-array!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PBlockDiagonalMatrix"><div class="inner"><span>PBlockDiagonalMatrix</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-block-diagonal-matrix"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>block-diagonal-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PBroadcast"><div class="inner"><span>PBroadcast</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-broadcast"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>broadcast</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PBroadcastCoerce"><div class="inner"><span>PBroadcastCoerce</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-broadcast-coerce"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>broadcast-coerce</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PBroadcastLike"><div class="inner"><span>PBroadcastLike</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-broadcast-like"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>broadcast-like</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PCholeskyDecomposition"><div class="inner"><span>PCholeskyDecomposition</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-cholesky"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cholesky</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PCoercion"><div class="inner"><span>PCoercion</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-coerce-param"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>coerce-param</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PColumnSetting"><div class="inner"><span>PColumnSetting</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-set-column"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-column</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-set-column.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-column!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PComputeMatrix"><div class="inner"><span>PComputeMatrix</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-compute-matrix"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>compute-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PConversion"><div class="inner"><span>PConversion</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-convert-to-nested-vectors"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>convert-to-nested-vectors</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PDatasetImplementation"><div class="inner"><span>PDatasetImplementation</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-add-column"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>add-column</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-column-names"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>column-names</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-columns"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>columns</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-join-columns"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>join-columns</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-join-rows"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>join-rows</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-merge-datasets"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>merge-datasets</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-rename-columns"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rename-columns</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-replace-column"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>replace-column</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-row-maps"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>row-maps</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-select-columns"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>select-columns</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-select-rows"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>select-rows</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-to-map"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>to-map</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PDense"><div class="inner"><span>PDense</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-dense"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dense</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-dense-coerce"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dense-coerce</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PDimensionImplementation"><div class="inner"><span>PDimensionImplementation</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-column-name"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>column-name</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-dimension-name"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dimension-name</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-row-name"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>row-name</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PDimensionInfo"><div class="inner"><span>PDimensionInfo</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-dimension-count"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dimension-count</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-dimensionality"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dimensionality</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-get-shape"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-shape</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-is-scalar.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>is-scalar?</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-is-vector.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>is-vector?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PDimensionLabels"><div class="inner"><span>PDimensionLabels</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-label"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>label</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-labels"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>labels</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PDoubleArrayOutput"><div class="inner"><span>PDoubleArrayOutput</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-as-double-array"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>as-double-array</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-to-double-array"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>to-double-array</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PEigenDecomposition"><div class="inner"><span>PEigenDecomposition</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-eigen"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>eigen</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PElementCount"><div class="inner"><span>PElementCount</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-element-count"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>element-count</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PElementMinMax"><div class="inner"><span>PElementMinMax</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-element-max"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>element-max</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-element-min"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>element-min</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-persistent-vector-coerce"><div class="inner"><span>persistent-vector-coerce</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PExponent"><div class="inner"><span>PExponent</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-element-pow"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>element-pow</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PFunctionalOperations"><div class="inner"><span>PFunctionalOperations</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-element-map"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>element-map</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-element-map.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>element-map!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-element-reduce"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>element-reduce</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-element-seq"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>element-seq</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PGenericOperations"><div class="inner"><span>PGenericOperations</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-generic-add"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generic-add</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-generic-div"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generic-div</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-generic-mul"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generic-mul</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-generic-negate"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generic-negate</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PGenericValues"><div class="inner"><span>PGenericValues</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-generic-one"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generic-one</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-generic-value"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generic-value</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-generic-zero"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generic-zero</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PImmutableAssignment"><div class="inner"><span>PImmutableAssignment</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-assign"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>assign</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PImmutableMatrixConstruction"><div class="inner"><span>PImmutableMatrixConstruction</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-immutable-matrix"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>immutable-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PImplementation"><div class="inner"><span>PImplementation</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-construct-matrix"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>construct-matrix</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-implementation-key"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>implementation-key</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-meta-info"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>meta-info</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-new-matrix"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>new-matrix</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-new-matrix-nd"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>new-matrix-nd</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-new-vector"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>new-vector</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-supports-dimensionality.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>supports-dimensionality?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PIndexedAccess"><div class="inner"><span>PIndexedAccess</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-get-1d"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-1d</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-get-2d"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-2d</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-get-nd"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-nd</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PIndexedSetting"><div class="inner"><span>PIndexedSetting</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-is-mutable.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>is-mutable?</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-set-1d"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-1d</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-set-2d"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-2d</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-set-nd"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-nd</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PIndexedSettingMutable"><div class="inner"><span>PIndexedSettingMutable</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-set-1d.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-1d!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-set-2d.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-2d!</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-set-nd.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-nd!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PIndexImplementation"><div class="inner"><span>PIndexImplementation</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-index-coerce"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>index-coerce</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-index-from-ints"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>index-from-ints</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-index-from-longs"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>index-from-longs</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-index-to-ints"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>index-to-ints</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-index-to-longs"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>index-to-longs</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-index.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>index?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PIndicesAccess"><div class="inner"><span>PIndicesAccess</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-get-indices"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-indices</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PIndicesSetting"><div class="inner"><span>PIndicesSetting</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-set-indices"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-indices</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-set-indices.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-indices!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PLeastSquares"><div class="inner"><span>PLeastSquares</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-least-squares"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>least-squares</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PLUDecomposition"><div class="inner"><span>PLUDecomposition</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-lu"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lu</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMathsFunctions"><div class="inner"><span>PMathsFunctions</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-abs"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>abs</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-acos"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>acos</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-asin"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>asin</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-atan"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>atan</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-cbrt"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cbrt</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-ceil"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ceil</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-cos"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cos</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-cosh"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cosh</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-exp"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exp</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-floor"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>floor</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-log"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>log</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-log10"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>log10</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-round"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>round</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-signum"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>signum</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-sin"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sin</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-sinh"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sinh</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-sqrt"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sqrt</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-tan"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tan</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-tanh"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tanh</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-to-degrees"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>to-degrees</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-to-radians"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>to-radians</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMathsFunctionsMutable"><div class="inner"><span>PMathsFunctionsMutable</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-abs.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>abs!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-acos.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>acos!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-asin.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>asin!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-atan.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>atan!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-cbrt.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cbrt!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-ceil.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ceil!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-cos.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cos!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-cosh.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cosh!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-exp.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exp!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-floor.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>floor!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-log.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>log!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-log10.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>log10!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-round.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>round!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-signum.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>signum!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-sin.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sin!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-sinh.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sinh!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-sqrt.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sqrt!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-tan.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tan!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-tanh.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tanh!</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-to-degrees.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>to-degrees!</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-to-radians.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>to-radians!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixAdd"><div class="inner"><span>PMatrixAdd</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-matrix-add"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matrix-add</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-matrix-sub"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matrix-sub</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixAddMutable"><div class="inner"><span>PMatrixAddMutable</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-matrix-add.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matrix-add!</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-matrix-sub.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matrix-sub!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixCloning"><div class="inner"><span>PMatrixCloning</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-clone"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clone</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixColumns"><div class="inner"><span>PMatrixColumns</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-get-columns"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-columns</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixDivide"><div class="inner"><span>PMatrixDivide</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-element-divide"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>element-divide</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixDivideMutable"><div class="inner"><span>PMatrixDivideMutable</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-element-divide.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>element-divide!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixEquality"><div class="inner"><span>PMatrixEquality</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-matrix-equals"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matrix-equals</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixEqualityEpsilon"><div class="inner"><span>PMatrixEqualityEpsilon</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-matrix-equals-epsilon"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matrix-equals-epsilon</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixMultiply"><div class="inner"><span>PMatrixMultiply</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-element-multiply"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>element-multiply</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-matrix-multiply"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matrix-multiply</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixMultiplyMutable"><div class="inner"><span>PMatrixMultiplyMutable</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-element-multiply.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>element-multiply!</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-matrix-multiply.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matrix-multiply!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixMutableScaling"><div class="inner"><span>PMatrixMutableScaling</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-pre-scale.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pre-scale!</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-scale.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>scale!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixOps"><div class="inner"><span>PMatrixOps</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-determinant"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>determinant</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-inverse"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>inverse</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-trace"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>trace</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixPredicates"><div class="inner"><span>PMatrixPredicates</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-identity-matrix.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>identity-matrix?</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-symmetric.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>symmetric?</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-zero-matrix.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>zero-matrix?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixProducts"><div class="inner"><span>PMatrixProducts</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-inner-product"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>inner-product</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-outer-product"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>outer-product</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixRank"><div class="inner"><span>PMatrixRank</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-rank"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rank</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixRows"><div class="inner"><span>PMatrixRows</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-get-rows"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-rows</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixScaling"><div class="inner"><span>PMatrixScaling</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-pre-scale"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pre-scale</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-scale"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>scale</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixSlices"><div class="inner"><span>PMatrixSlices</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-get-column"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-column</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-get-major-slice"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-major-slice</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-get-row"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-row</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-get-slice"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-slice</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixSubComponents"><div class="inner"><span>PMatrixSubComponents</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-main-diagonal"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>main-diagonal</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMatrixTypes"><div class="inner"><span>PMatrixTypes</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-diagonal.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>diagonal?</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-lower-triangular.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lower-triangular?</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-orthogonal.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>orthogonal?</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-positive-definite.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>positive-definite?</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-positive-semidefinite.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>positive-semidefinite?</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-upper-triangular.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>upper-triangular?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMutableFill"><div class="inner"><span>PMutableFill</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-fill.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fill!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMutableMatrixConstruction"><div class="inner"><span>PMutableMatrixConstruction</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-mutable-matrix"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mutable-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PMutableVectorOps"><div class="inner"><span>PMutableVectorOps</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-normalise.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>normalise!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PNegation"><div class="inner"><span>PNegation</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-negate"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>negate</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PNewSparseArray"><div class="inner"><span>PNewSparseArray</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-new-sparse-array"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>new-sparse-array</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PNonZeroIndices"><div class="inner"><span>PNonZeroIndices</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-non-zero-indices"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>non-zero-indices</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PNorm"><div class="inner"><span>PNorm</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-norm"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>norm</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PNumerical"><div class="inner"><span>PNumerical</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-numerical.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>numerical?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PObjectArrayOutput"><div class="inner"><span>PObjectArrayOutput</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-as-object-array"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>as-object-array</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-to-object-array"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>to-object-array</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-POrder"><div class="inner"><span>POrder</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-order"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>order</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PPack"><div class="inner"><span>PPack</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-pack"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pack</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PPermutationMatrix"><div class="inner"><span>PPermutationMatrix</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-permutation-matrix"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>permutation-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PQRDecomposition"><div class="inner"><span>PQRDecomposition</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-qr"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>qr</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PReshaping"><div class="inner"><span>PReshaping</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-reshape"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>reshape</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PRotate"><div class="inner"><span>PRotate</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-rotate"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rotate</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PRotateAll"><div class="inner"><span>PRotateAll</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-rotate-all"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rotate-all</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PRowColMatrix"><div class="inner"><span>PRowColMatrix</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-column-matrix"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>column-matrix</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-row-matrix"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>row-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PRowOperations"><div class="inner"><span>PRowOperations</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-add-row"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>add-row</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-multiply-row"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>multiply-row</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-swap-rows"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>swap-rows</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PRowSetting"><div class="inner"><span>PRowSetting</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-set-row"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-row</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-set-row.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-row!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSameShape"><div class="inner"><span>PSameShape</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-same-shape.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>same-shape?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSelect"><div class="inner"><span>PSelect</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-select"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>select</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSetSelection"><div class="inner"><span>PSetSelection</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-set-selection"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-selection</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSliceJoin"><div class="inner"><span>PSliceJoin</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-join"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>join</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSliceJoinAlong"><div class="inner"><span>PSliceJoinAlong</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-join-along"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>join-along</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSliceSeq"><div class="inner"><span>PSliceSeq</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-get-major-slice-seq"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-major-slice-seq</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSliceSeq2"><div class="inner"><span>PSliceSeq2</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-get-slice-seq"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-slice-seq</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSliceView"><div class="inner"><span>PSliceView</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-get-major-slice-view"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-major-slice-view</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSliceViewSeq"><div class="inner"><span>PSliceViewSeq</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-get-major-slice-view-seq"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-major-slice-view-seq</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSolveLinear"><div class="inner"><span>PSolveLinear</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-solve"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>solve</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSparse"><div class="inner"><span>PSparse</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-sparse"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sparse</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-sparse-coerce"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sparse-coerce</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSparseArray"><div class="inner"><span>PSparseArray</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-is-sparse.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>is-sparse?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSpecialisedConstructors"><div class="inner"><span>PSpecialisedConstructors</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-diagonal-matrix"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>diagonal-matrix</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-identity-matrix"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>identity-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSquare"><div class="inner"><span>PSquare</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-square"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>square</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSubMatrix"><div class="inner"><span>PSubMatrix</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-submatrix"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>submatrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSubVector"><div class="inner"><span>PSubVector</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-subvector"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>subvector</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSummable"><div class="inner"><span>PSummable</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-element-sum"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>element-sum</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PSVDDecomposition"><div class="inner"><span>PSVDDecomposition</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-svd"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>svd</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PTranspose"><div class="inner"><span>PTranspose</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-transpose"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transpose</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PTransposeInPlace"><div class="inner"><span>PTransposeInPlace</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-transpose.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transpose!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PTypeInfo"><div class="inner"><span>PTypeInfo</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-element-type"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>element-type</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PValidateShape"><div class="inner"><span>PValidateShape</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-validate-shape"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>validate-shape</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PValueEquality"><div class="inner"><span>PValueEquality</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-value-equals"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>value-equals</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PVectorCross"><div class="inner"><span>PVectorCross</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-cross-product"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cross-product</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-cross-product.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cross-product!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PVectorDistance"><div class="inner"><span>PVectorDistance</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-distance"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>distance</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PVectorisable"><div class="inner"><span>PVectorisable</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-to-vector"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>to-vector</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PVectorOps"><div class="inner"><span>PVectorOps</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-length"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>length</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-length-squared"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>length-squared</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-normalise"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>normalise</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-vector-dot"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>vector-dot</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PVectorTransform"><div class="inner"><span>PVectorTransform</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-vector-transform"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>vector-transform</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-vector-transform.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>vector-transform!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PVectorView"><div class="inner"><span>PVectorView</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-as-vector"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>as-vector</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PZeroCount"><div class="inner"><span>PZeroCount</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-zero-count"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>zero-count</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PZeroDimensionAccess"><div class="inner"><span>PZeroDimensionAccess</span></div></a></li><li class="depth-2 branch"><a href="clojure.core.matrix.protocols.html#var-get-0d"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-0d</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-set-0d.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-0d!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PZeroDimensionConstruction"><div class="inner"><span>PZeroDimensionConstruction</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-new-scalar-array"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>new-scalar-array</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-PZeroDimensionSet"><div class="inner"><span>PZeroDimensionSet</span></div></a></li><li class="depth-2"><a href="clojure.core.matrix.protocols.html#var-set-0d"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-0d</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-same-shapes.3F"><div class="inner"><span>same-shapes?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.protocols.html#var-supports-type.3F"><div class="inner"><span>supports-type?</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">clojure.core.matrix.protocols</h2><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-broadcast-compatible"><h3>broadcast-compatible</h3><div class="usage"><code>(broadcast-compatible a b)</code></div><div class="doc"><pre class="plaintext">Broadcasts two matrices into identical shapes, coercing to the type of the first matrix.
Intended to prepare for elementwise operations.
Returns a vector containing the two broadcasted matrices.
Throws an error if not possible.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L898">view source</a></div></div><div class="public anchor" id="var-ensure-type"><h3>ensure-type</h3><div class="usage"><code>(ensure-type m klass)</code></div><div class="doc"><pre class="plaintext">Checks if an array can contain a specified Java type, if so returns the orifginal array, otherwise
returns a copy of the array that can support the sepecified type.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L927">view source</a></div></div><div class="public anchor" id="var-PAddProduct"><h3>PAddProduct</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for add-product operation.
Intended to implement a fast version for result = m + a * b</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-add-product"><h3>add-product</h3><div class="usage"><code>(add-product m a b)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L450">view source</a></div></div><div class="public anchor" id="var-PAddProductMutable"><h3>PAddProductMutable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for mutable add-product! operation.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-add-product.21"><h3>add-product!</h3><div class="usage"><code>(add-product! m a b)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L455">view source</a></div></div><div class="public anchor" id="var-PAddScaled"><h3>PAddScaled</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for add-scaled operation.
Intended to implement a fast version for result = m + a * factor</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-add-scaled"><h3>add-scaled</h3><div class="usage"><code>(add-scaled m a factor)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L468">view source</a></div></div><div class="public anchor" id="var-PAddScaledMutable"><h3>PAddScaledMutable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for mutable add-scaled! operation.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-add-scaled.21"><h3>add-scaled!</h3><div class="usage"><code>(add-scaled! m a factor)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L473">view source</a></div></div><div class="public anchor" id="var-PAddScaledProduct"><h3>PAddScaledProduct</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for add-product operation.
Intended to implement a fast version for result = m + a * b * factor</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-add-scaled-product"><h3>add-scaled-product</h3><div class="usage"><code>(add-scaled-product m a b factor)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L459">view source</a></div></div><div class="public anchor" id="var-PAddScaledProductMutable"><h3>PAddScaledProductMutable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for mutable add-product! operation.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-add-scaled-product.21"><h3>add-scaled-product!</h3><div class="usage"><code>(add-scaled-product! m a b factor)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L464">view source</a></div></div><div class="public anchor" id="var-PArrayMetrics"><h3>PArrayMetrics</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Option protocol for quick determination of array matrics
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-nonzero-count"><h3>nonzero-count</h3><div class="usage"><code>(nonzero-count m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L141">view source</a></div></div><div class="public anchor" id="var-PAssignment"><h3>PAssignment</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for assigning values element-wise to mutable arrays.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-assign.21"><h3>assign!</h3><div class="usage"><code>(assign! m source)</code></div><div class="doc"><pre class="plaintext">Sets all the values in an array from a given source. Source may be a scalar
or a smaller array that can be broadcast to the shape of m.</pre></div></div><div class="public anchor" id="var-assign-array.21"><h3>assign-array!</h3><div class="usage"><code>(assign-array! m arr)</code><code>(assign-array! m arr start length)</code></div><div class="doc"><pre class="plaintext">Sets the elements in an array from an Java array source, in row-major order.
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L376">view source</a></div></div><div class="public anchor" id="var-PBlockDiagonalMatrix"><h3>PBlockDiagonalMatrix</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for construction of a block diagonal matrix.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-block-diagonal-matrix"><h3>block-diagonal-matrix</h3><div class="usage"><code>(block-diagonal-matrix m blocks)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L215">view source</a></div></div><div class="public anchor" id="var-PBroadcast"><h3>PBroadcast</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support broadcasting over one or more dimensions.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-broadcast"><h3>broadcast</h3><div class="usage"><code>(broadcast m target-shape)</code></div><div class="doc"><pre class="plaintext">Broadcasts an array over a desired target shape, which should be larger than the current matrix.
Dimensions should be matched up according to the last dimension.
In order to broadcast sucessfully, the current dimension of the array must be either:
 - of size 1
 - equal to the size of the dimension in the target shape
 - not included in the array (i.e. the target shape has more leading dimensions)

If broadcasting is not possible, an exception must be thrown.

Broadcasting may return either a view with replicated element or a new immutable matrix.</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L239">view source</a></div></div><div class="public anchor" id="var-PBroadcastCoerce"><h3>PBroadcastCoerce</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to broadcast into a given matrix shape and perform coercion in one step.

Equivalent to (coerce m (broadcast-like m a)) but likely to be more efficient.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-broadcast-coerce"><h3>broadcast-coerce</h3><div class="usage"><code>(broadcast-coerce m a)</code></div><div class="doc"><pre class="plaintext">Broacasts and coerces a to the same shape and implementation as m
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L257">view source</a></div></div><div class="public anchor" id="var-PBroadcastLike"><h3>PBroadcastLike</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to broadcast into a given matrix shape. May also perform coercion if needed by the implementation.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-broadcast-like"><h3>broadcast-like</h3><div class="usage"><code>(broadcast-like m a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L253">view source</a></div></div><div class="public anchor" id="var-PCholeskyDecomposition"><h3>PCholeskyDecomposition</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Procotol for Cholesky decomposition
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-cholesky"><h3>cholesky</h3><div class="usage"><code>(cholesky m options)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L831">view source</a></div></div><div class="public anchor" id="var-PCoercion"><h3>PCoercion</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to coerce a parameter to a format used by a specific implementation. It is
up to the implementation to determine what parameter types they support.
If the implementation is unable to perform coercion, it must return nil.

Implementations are encouraged to avoid taking a full copy of the data, for performance reasons.
It is preferable to use structural sharing with the original data if possible.

If coercion is impossible (e.g. param has an invalid shape or element types) then the
implementation *may* throw an exception, though it may also return nil to get default behaviour,
which should implement any expected exceptions.

If an implementation implements coercion via copying, then it is recommended that conversion
should be to the most efficient packed representation (i.e. as defined by &apos;pack&apos;)

Implementations must also be able to coerce valid scalar values (presumably via the identity function)</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-coerce-param"><h3>coerce-param</h3><div class="usage"><code>(coerce-param m param)</code></div><div class="doc"><pre class="plaintext">Attempts to coerce param into a matrix format supported by the implementation of matrix m.
May return nil if unable to do so, in which case a default implementation can be used.</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L219">view source</a></div></div><div class="public anchor" id="var-PColumnSetting"><h3>PColumnSetting</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for column setting. Should set a dimension 1 (column) slice to the given column value.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-set-column"><h3>set-column</h3><div class="usage"><code>(set-column m i column)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-set-column.21"><h3>set-column!</h3><div class="usage"><code>(set-column! m i column)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L681">view source</a></div></div><div class="public anchor" id="var-PComputeMatrix"><h3>PComputeMatrix</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to compute a matrix by calling a function on each indexed location. The function f will be called
as (f x y z ...) for all index values.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-compute-matrix"><h3>compute-matrix</h3><div class="usage"><code>(compute-matrix m shape f)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L540">view source</a></div></div><div class="public anchor" id="var-PConversion"><h3>PConversion</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to allow conversion to Clojure-friendly vector format. Optional for implementers,
however providing an efficient implementation is strongly encouraged to enable fast interop
with Clojure vectors.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-convert-to-nested-vectors"><h3>convert-to-nested-vectors</h3><div class="usage"><code>(convert-to-nested-vectors m)</code></div><div class="doc"><pre class="plaintext">Converts an array to nested Clojure persistent vectors
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L263">view source</a></div></div><div class="public anchor" id="var-PDatasetImplementation"><h3>PDatasetImplementation</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for general dataset functionality
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-add-column"><h3>add-column</h3><div class="usage"><code>(add-column ds col-name col)</code></div><div class="doc"><pre class="plaintext">Adds column to the dataset
</pre></div></div><div class="public anchor" id="var-column-names"><h3>column-names</h3><div class="usage"><code>(column-names ds)</code></div><div class="doc"><pre class="plaintext">Returns a persistent vector containing column names in the same order as they are placed in the dataset
</pre></div></div><div class="public anchor" id="var-columns"><h3>columns</h3><div class="usage"><code>(columns ds)</code></div><div class="doc"><pre class="plaintext">Returns a persistent vector containing columns in the same order they are placed in the dataset
</pre></div></div><div class="public anchor" id="var-join-columns"><h3>join-columns</h3><div class="usage"><code>(join-columns ds1 ds2)</code></div><div class="doc"><pre class="plaintext">Returns a dataset created by combining the columns of the given datasets
</pre></div></div><div class="public anchor" id="var-join-rows"><h3>join-rows</h3><div class="usage"><code>(join-rows ds1 ds2)</code></div><div class="doc"><pre class="plaintext">Returns a dataset created by combining the rows of the given datasets
</pre></div></div><div class="public anchor" id="var-merge-datasets"><h3>merge-datasets</h3><div class="usage"><code>(merge-datasets ds1 ds2)</code></div><div class="doc"><pre class="plaintext">Returns a dataset created by combining columns of the given datasets. In case of columns with duplicate names, last-one-wins strategy is applied
</pre></div></div><div class="public anchor" id="var-rename-columns"><h3>rename-columns</h3><div class="usage"><code>(rename-columns ds col-map)</code></div><div class="doc"><pre class="plaintext">Renames columns based on map of old new column name pairs
</pre></div></div><div class="public anchor" id="var-replace-column"><h3>replace-column</h3><div class="usage"><code>(replace-column ds col-name vs)</code></div><div class="doc"><pre class="plaintext">Replaces column in a dataset with new values
</pre></div></div><div class="public anchor" id="var-row-maps"><h3>row-maps</h3><div class="usage"><code>(row-maps ds)</code></div><div class="doc"><pre class="plaintext">Returns seq of maps with row values
</pre></div></div><div class="public anchor" id="var-select-columns"><h3>select-columns</h3><div class="usage"><code>(select-columns ds cols)</code></div><div class="doc"><pre class="plaintext">Produces a new dataset with the columns in the specified order
</pre></div></div><div class="public anchor" id="var-select-rows"><h3>select-rows</h3><div class="usage"><code>(select-rows ds rows)</code></div><div class="doc"><pre class="plaintext">Produces a new dataset with specified rows
</pre></div></div><div class="public anchor" id="var-to-map"><h3>to-map</h3><div class="usage"><code>(to-map ds)</code></div><div class="doc"><pre class="plaintext">Returns map of columns with associated list of values
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L859">view source</a></div></div><div class="public anchor" id="var-PDense"><h3>PDense</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for constructing a dense array from the given data.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-dense"><h3>dense</h3><div class="usage"><code>(dense m)</code></div><div class="doc"><pre class="plaintext">Attempts to make array into a dense format. Must return the same array unchanged if not possible.
</pre></div></div><div class="public anchor" id="var-dense-coerce"><h3>dense-coerce</h3><div class="usage"><code>(dense-coerce m data)</code></div><div class="doc"><pre class="plaintext">Attempts to coerce data to a dense array of implementation m. May return nil if not supported
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L175">view source</a></div></div><div class="public anchor" id="var-PDimensionImplementation"><h3>PDimensionImplementation</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">EXPERIMENTAL: Protocol for querying multi-dimensioned datasets
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-column-name"><h3>column-name</h3><div class="usage"><code>(column-name ds idx)</code></div><div class="doc"><pre class="plaintext">returns the name of the column (dimension 1) at a specified column index
</pre></div></div><div class="public anchor" id="var-dimension-name"><h3>dimension-name</h3><div class="usage"><code>(dimension-name ds idx dim)</code></div><div class="doc"><pre class="plaintext">Returns the name of the specified index along a given numbered dimension
</pre></div></div><div class="public anchor" id="var-row-name"><h3>row-name</h3><div class="usage"><code>(row-name ds idx)</code></div><div class="doc"><pre class="plaintext">Returns the name of the row (dimension 0) at a specified index
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L874">view source</a></div></div><div class="public anchor" id="var-PDimensionInfo"><h3>PDimensionInfo</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to return standard dimension information about an array.
dimensionality and dimension-count are mandatory for implementations</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-dimension-count"><h3>dimension-count</h3><div class="usage"><code>(dimension-count m dimension-number)</code></div><div class="doc"><pre class="plaintext">Returns the size of a specific dimension. Must throw an exception if the array does not
have the specified dimension.</pre></div></div><div class="public anchor" id="var-dimensionality"><h3>dimensionality</h3><div class="usage"><code>(dimensionality m)</code></div><div class="doc"><pre class="plaintext">Returns the number of dimensions of an array
</pre></div></div><div class="public anchor" id="var-get-shape"><h3>get-shape</h3><div class="usage"><code>(get-shape m)</code></div><div class="doc"><pre class="plaintext">Returns the shape of the array, typically as a Java array or sequence of dimension sizes.
Implementations are free to choose what type is used to represent the shape, but it must
contain only integer values and be traversable as a sequence via clojure.core/seq</pre></div></div><div class="public anchor" id="var-is-scalar.3F"><h3>is-scalar?</h3><div class="usage"><code>(is-scalar? m)</code></div><div class="doc"><pre class="plaintext">Tests whether an object is a scalar value, i.e. a value that can exist at a
specific position in an array.</pre></div></div><div class="public anchor" id="var-is-vector.3F"><h3>is-vector?</h3><div class="usage"><code>(is-vector? m)</code></div><div class="doc"><pre class="plaintext">Tests whether an object is a vector (1D array)
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L57">view source</a></div></div><div class="public anchor" id="var-PDimensionLabels"><h3>PDimensionLabels</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for arrays supporting labelled dimensions
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-label"><h3>label</h3><div class="usage"><code>(label m dim i)</code></div><div class="doc"><pre class="plaintext">Returns the label at a specific index along the given dimension
</pre></div></div><div class="public anchor" id="var-labels"><h3>labels</h3><div class="usage"><code>(labels m dim)</code></div><div class="doc"><pre class="plaintext">Returns all labels along a given dimension, as a vector
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L815">view source</a></div></div><div class="public anchor" id="var-PDoubleArrayOutput"><h3>PDoubleArrayOutput</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for getting data as a double array
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-as-double-array"><h3>as-double-array</h3><div class="usage"><code>(as-double-array m)</code></div><div class="doc"><pre class="plaintext">Returns the internal double array used by m. If no such array is used, returns nil.
Provides an opportunity to avoid copying the internal array.</pre></div></div><div class="public anchor" id="var-to-double-array"><h3>to-double-array</h3><div class="usage"><code>(to-double-array m)</code></div><div class="doc"><pre class="plaintext">Returns a double array containing the values of m in row-major order. May or may not be
the internal double array used by m, depending on the implementation.</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L399">view source</a></div></div><div class="public anchor" id="var-PEigenDecomposition"><h3>PEigenDecomposition</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Procotol for Eigenvalue decomposition
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-eigen"><h3>eigen</h3><div class="usage"><code>(eigen m options)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L843">view source</a></div></div><div class="public anchor" id="var-PElementCount"><h3>PElementCount</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to return the total count of elements in matrix. Result may be any integer type,
typically a java.lang.Long</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-element-count"><h3>element-count</h3><div class="usage"><code>(element-count m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L698">view source</a></div></div><div class="public anchor" id="var-PElementMinMax"><h3>PElementMinMax</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to return the minimum and maximum elements in a numerical array. Must throw an exception
if the array is not numerical.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-element-max"><h3>element-max</h3><div class="usage"><code>(element-max m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-element-min"><h3>element-min</h3><div class="usage"><code>(element-min m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L703">view source</a></div></div><div class="public anchor" id="var-persistent-vector-coerce"><h3>persistent-vector-coerce</h3><div class="usage"><code>(persistent-vector-coerce x)</code></div><div class="doc"><pre class="plaintext">Coerces a data structure to nested persistent vectors
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L883">view source</a></div></div><div class="public anchor" id="var-PExponent"><h3>PExponent</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support the &apos;pow&apos; function. Should raise every element of a matrix to a
given exponent. Default implementation uses Java&apos;s Math/pow function which is appropriate for
double values: arrays supporting arbitrary precision numbers or complex types will need to
provide their own implementation.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-element-pow"><h3>element-pow</h3><div class="usage"><code>(element-pow m exponent)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L652">view source</a></div></div><div class="public anchor" id="var-PFunctionalOperations"><h3>PFunctionalOperations</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to allow functional-style operations on matrix elements.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-element-map"><h3>element-map</h3><div class="usage"><code>(element-map m f)</code><code>(element-map m f a)</code><code>(element-map m f a more)</code></div><div class="doc"><pre class="plaintext">Maps f over all elements of m (and optionally other matrices), returning a new matrix.
f is expected to produce elements of a type supported by the implementation of m - failure
to do so may cause an error.</pre></div></div><div class="public anchor" id="var-element-map.21"><h3>element-map!</h3><div class="usage"><code>(element-map! m f)</code><code>(element-map! m f a)</code><code>(element-map! m f a more)</code></div><div class="doc"><pre class="plaintext">Maps f over all elements of m (and optionally other matrices), mutating the elements of m in place.
Must throw an exception if m is not mutable.
f is expected to produce elements of a type supported by the implementation of m - failure
to do so may cause an error.</pre></div></div><div class="public anchor" id="var-element-reduce"><h3>element-reduce</h3><div class="usage"><code>(element-reduce m f)</code><code>(element-reduce m f init)</code></div><div class="doc"><pre class="plaintext">Reduces with the function f over all elements of m.
</pre></div></div><div class="public anchor" id="var-element-seq"><h3>element-seq</h3><div class="usage"><code>(element-seq m)</code></div><div class="doc"><pre class="plaintext">Must return a sequence containing all elements of the matrix, in row-major order.
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L709">view source</a></div></div><div class="public anchor" id="var-PGenericOperations"><h3>PGenericOperations</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for returning the generic numerical functions of a matrix implementation
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-generic-add"><h3>generic-add</h3><div class="usage"><code>(generic-add m)</code></div><div class="doc"><pre class="plaintext">Generic &apos;add&apos; function for numerical values. Must satisfy (equals x (add zero x)).
</pre></div></div><div class="public anchor" id="var-generic-div"><h3>generic-div</h3><div class="usage"><code>(generic-div m)</code></div><div class="doc"><pre class="plaintext">Generic &apos;div&apos; function for numerical values.
</pre></div></div><div class="public anchor" id="var-generic-mul"><h3>generic-mul</h3><div class="usage"><code>(generic-mul m)</code></div><div class="doc"><pre class="plaintext">Generic &apos;mul&apos; function for numerical values. Must satisfy (equals x (mul one x)).
</pre></div></div><div class="public anchor" id="var-generic-negate"><h3>generic-negate</h3><div class="usage"><code>(generic-negate m)</code></div><div class="doc"><pre class="plaintext">Generic &apos;negate&apos; function for numerical values.
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L770">view source</a></div></div><div class="public anchor" id="var-PGenericValues"><h3>PGenericValues</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for returning the generic/default values of a matrix implementation
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-generic-one"><h3>generic-one</h3><div class="usage"><code>(generic-one m)</code></div><div class="doc"><pre class="plaintext">Generic &apos;one&apos; value for numerical arrays. Must satisfy (equals m (mul m one)).
</pre></div></div><div class="public anchor" id="var-generic-value"><h3>generic-value</h3><div class="usage"><code>(generic-value m)</code></div><div class="doc"><pre class="plaintext">Generic value for a new array. Likely to be zero or nil.
</pre></div></div><div class="public anchor" id="var-generic-zero"><h3>generic-zero</h3><div class="usage"><code>(generic-zero m)</code></div><div class="doc"><pre class="plaintext">Generic &apos;zero&apos; value for numerical arrays. Must satisfy (equals m (add m zero)).
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L764">view source</a></div></div><div class="public anchor" id="var-PImmutableAssignment"><h3>PImmutableAssignment</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for assigning values element-wise to an array, broadcasting as needed.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-assign"><h3>assign</h3><div class="usage"><code>(assign m source)</code></div><div class="doc"><pre class="plaintext">Sets all the values in an array from a given source. Source may be a scalar
or a smaller array that can be broadcast to the shape of m.</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L387">view source</a></div></div><div class="public anchor" id="var-PImmutableMatrixConstruction"><h3>PImmutableMatrixConstruction</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for creating an immutable copy of a matrix. If implemented, must return a fully immutable
copy of the given matrix.

The default implementation will attempt to choose a suitable immutable matrix implementation.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-immutable-matrix"><h3>immutable-matrix</h3><div class="usage"><code>(immutable-matrix m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L180">view source</a></div></div><div class="public anchor" id="var-PImplementation"><h3>PImplementation</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for general implementation functionality. Required to support implementation metadata and
matrix construction.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-construct-matrix"><h3>construct-matrix</h3><div class="usage"><code>(construct-matrix m data)</code></div><div class="doc"><pre class="plaintext">Returns a new n-dimensional array containing the given data. data should be in the form of either
nested sequences or a valid existing array.

The return value should be in the preferred format of the given implementation. If the implementation
does not support the required dimensionality or element type then it may either:
 - Throw an error
 - Return nil to indicate that a default implementation should be used instead

0-dimensional arrays / scalars are permitted.</pre></div></div><div class="public anchor" id="var-implementation-key"><h3>implementation-key</h3><div class="usage"><code>(implementation-key m)</code></div><div class="doc"><pre class="plaintext">Returns a keyword representing this implementation.
Each implementation should have one unique key.</pre></div></div><div class="public anchor" id="var-meta-info"><h3>meta-info</h3><div class="usage"><code>(meta-info m)</code></div><div class="doc"><pre class="plaintext">Returns meta-information on the implementation. It is expected that
at least an element :doc containing a string describing an implementation
is provided.</pre></div></div><div class="public anchor" id="var-new-matrix"><h3>new-matrix</h3><div class="usage"><code>(new-matrix m rows columns)</code></div><div class="doc"><pre class="plaintext">Returns a new matrix (regular 2D matrix) with the given number of rows and columns, filled with numeric zero.
</pre></div></div><div class="public anchor" id="var-new-matrix-nd"><h3>new-matrix-nd</h3><div class="usage"><code>(new-matrix-nd m shape)</code></div><div class="doc"><pre class="plaintext">Returns a new general matrix of the given shape.
Must return nil if the shape is not supported by the implementation.
Shape must be a sequence of dimension sizes.</pre></div></div><div class="public anchor" id="var-new-vector"><h3>new-vector</h3><div class="usage"><code>(new-vector m length)</code></div><div class="doc"><pre class="plaintext">Returns a new vector (1D column matrix) of the given length, filled with numeric zero.
</pre></div></div><div class="public anchor" id="var-supports-dimensionality.3F"><h3>supports-dimensionality?</h3><div class="usage"><code>(supports-dimensionality? m dimensions)</code></div><div class="doc"><pre class="plaintext">Returns true if the implementation supports matrices with the given number of dimensions.
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L26">view source</a></div></div><div class="public anchor" id="var-PIndexedAccess"><h3>PIndexedAccess</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for indexed read access to arrays, matrices and vectors. Indexing values can
be assumed to be integers. indexes may be any sequence or Java array of index values.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-get-1d"><h3>get-1d</h3><div class="usage"><code>(get-1d m row)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-get-2d"><h3>get-2d</h3><div class="usage"><code>(get-2d m row column)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-get-nd"><h3>get-nd</h3><div class="usage"><code>(get-nd m indexes)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L77">view source</a></div></div><div class="public anchor" id="var-PIndexedSetting"><h3>PIndexedSetting</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for indexed &apos;setter&apos; operations. These are like Clojure&apos;s &apos;assoc&apos;
function, i.e. they return an updated copy of the original array, which is itself unchanged.
Must be supported for any immutable array type.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-is-mutable.3F"><h3>is-mutable?</h3><div class="usage"><code>(is-mutable? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the matrix is mutable and therefore supports direct mutable operations, e.g. add!
</pre></div></div><div class="public anchor" id="var-set-1d"><h3>set-1d</h3><div class="usage"><code>(set-1d m row v)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-set-2d"><h3>set-2d</h3><div class="usage"><code>(set-2d m row column v)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-set-nd"><h3>set-nd</h3><div class="usage"><code>(set-nd m indexes v)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L84">view source</a></div></div><div class="public anchor" id="var-PIndexedSettingMutable"><h3>PIndexedSettingMutable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for indexed mutable setter access to matrices and vectors.
Must be supported for any mutable matrix type.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-set-1d.21"><h3>set-1d!</h3><div class="usage"><code>(set-1d! m row v)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-set-2d.21"><h3>set-2d!</h3><div class="usage"><code>(set-2d! m row column v)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-set-nd.21"><h3>set-nd!</h3><div class="usage"><code>(set-nd! m indexes v)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L100">view source</a></div></div><div class="public anchor" id="var-PIndexImplementation"><h3>PIndexImplementation</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for determining if an object is a valid index. Implementations may implement this protocol to support their own index types.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-index-coerce"><h3>index-coerce</h3><div class="usage"><code>(index-coerce m a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-index-from-ints"><h3>index-from-ints</h3><div class="usage"><code>(index-from-ints m xs)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-index-from-longs"><h3>index-from-longs</h3><div class="usage"><code>(index-from-longs m xs)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-index-to-ints"><h3>index-to-ints</h3><div class="usage"><code>(index-to-ints m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-index-to-longs"><h3>index-to-longs</h3><div class="usage"><code>(index-to-longs m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-index.3F"><h3>index?</h3><div class="usage"><code>(index? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the argument is a valid index, false otherwise
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L803">view source</a></div></div><div class="public anchor" id="var-PIndicesAccess"><h3>PIndicesAccess</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for getting elements of an array at the specified indices.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-get-indices"><h3>get-indices</h3><div class="usage"><code>(get-indices a indices)</code></div><div class="doc"><pre class="plaintext">returns a 1-d array with the elements of a at indices
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L788">view source</a></div></div><div class="public anchor" id="var-PIndicesSetting"><h3>PIndicesSetting</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for setting elements of an array at the specified indices
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-set-indices"><h3>set-indices</h3><div class="usage"><code>(set-indices a indices values)</code></div><div class="doc"><pre class="plaintext">sets the elements from a at indices to values
</pre></div></div><div class="public anchor" id="var-set-indices.21"><h3>set-indices!</h3><div class="usage"><code>(set-indices! a indices values)</code></div><div class="doc"><pre class="plaintext">destructively sets the elements from a at indices to values
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L792">view source</a></div></div><div class="public anchor" id="var-PLeastSquares"><h3>PLeastSquares</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for computing least-square solution to a linear matrix equation
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-least-squares"><h3>least-squares</h3><div class="usage"><code>(least-squares a b)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L851">view source</a></div></div><div class="public anchor" id="var-PLUDecomposition"><h3>PLUDecomposition</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for LU decomposition
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-lu"><h3>lu</h3><div class="usage"><code>(lu m options)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L835">view source</a></div></div><div class="public anchor" id="var-PMathsFunctions"><h3>PMathsFunctions</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support mathematic functions applied element-wise to a numerical array
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-abs"><h3>abs</h3><div class="usage"><code>(abs m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-acos"><h3>acos</h3><div class="usage"><code>(acos m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-asin"><h3>asin</h3><div class="usage"><code>(asin m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-atan"><h3>atan</h3><div class="usage"><code>(atan m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-cbrt"><h3>cbrt</h3><div class="usage"><code>(cbrt m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-ceil"><h3>ceil</h3><div class="usage"><code>(ceil m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-cos"><h3>cos</h3><div class="usage"><code>(cos m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-cosh"><h3>cosh</h3><div class="usage"><code>(cosh m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-exp"><h3>exp</h3><div class="usage"><code>(exp m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-floor"><h3>floor</h3><div class="usage"><code>(floor m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-log"><h3>log</h3><div class="usage"><code>(log m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-log10"><h3>log10</h3><div class="usage"><code>(log10 m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-round"><h3>round</h3><div class="usage"><code>(round m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-signum"><h3>signum</h3><div class="usage"><code>(signum m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-sin"><h3>sin</h3><div class="usage"><code>(sin m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-sinh"><h3>sinh</h3><div class="usage"><code>(sinh m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-sqrt"><h3>sqrt</h3><div class="usage"><code>(sqrt m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-tan"><h3>tan</h3><div class="usage"><code>(tan m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-tanh"><h3>tanh</h3><div class="usage"><code>(tanh m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-to-degrees"><h3>to-degrees</h3><div class="usage"><code>(to-degrees m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-to-radians"><h3>to-radians</h3><div class="usage"><code>(to-radians m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L688">view source</a></div></div><div class="public anchor" id="var-PMathsFunctionsMutable"><h3>PMathsFunctionsMutable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support mutable mathematic functions applied element-wise to a numerical array
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-abs.21"><h3>abs!</h3><div class="usage"><code>(abs! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-acos.21"><h3>acos!</h3><div class="usage"><code>(acos! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-asin.21"><h3>asin!</h3><div class="usage"><code>(asin! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-atan.21"><h3>atan!</h3><div class="usage"><code>(atan! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-cbrt.21"><h3>cbrt!</h3><div class="usage"><code>(cbrt! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-ceil.21"><h3>ceil!</h3><div class="usage"><code>(ceil! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-cos.21"><h3>cos!</h3><div class="usage"><code>(cos! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-cosh.21"><h3>cosh!</h3><div class="usage"><code>(cosh! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-exp.21"><h3>exp!</h3><div class="usage"><code>(exp! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-floor.21"><h3>floor!</h3><div class="usage"><code>(floor! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-log.21"><h3>log!</h3><div class="usage"><code>(log! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-log10.21"><h3>log10!</h3><div class="usage"><code>(log10! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-round.21"><h3>round!</h3><div class="usage"><code>(round! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-signum.21"><h3>signum!</h3><div class="usage"><code>(signum! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-sin.21"><h3>sin!</h3><div class="usage"><code>(sin! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-sinh.21"><h3>sinh!</h3><div class="usage"><code>(sinh! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-sqrt.21"><h3>sqrt!</h3><div class="usage"><code>(sqrt! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-tan.21"><h3>tan!</h3><div class="usage"><code>(tan! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-tanh.21"><h3>tanh!</h3><div class="usage"><code>(tanh! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-to-degrees.21"><h3>to-degrees!</h3><div class="usage"><code>(to-degrees! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-to-radians.21"><h3>to-radians!</h3><div class="usage"><code>(to-radians! m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L693">view source</a></div></div><div class="public anchor" id="var-PMatrixAdd"><h3>PMatrixAdd</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support addition and subtraction on arbitrary matrices.
These are elementwise operations that should support broadcasting.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-matrix-add"><h3>matrix-add</h3><div class="usage"><code>(matrix-add m a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-matrix-sub"><h3>matrix-sub</h3><div class="usage"><code>(matrix-sub m a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L522">view source</a></div></div><div class="public anchor" id="var-PMatrixAddMutable"><h3>PMatrixAddMutable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support mutable addition and subtraction
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-matrix-add.21"><h3>matrix-add!</h3><div class="usage"><code>(matrix-add! m a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-matrix-sub.21"><h3>matrix-sub!</h3><div class="usage"><code>(matrix-sub! m a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L528">view source</a></div></div><div class="public anchor" id="var-PMatrixCloning"><h3>PMatrixCloning</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for cloning a matrix value. The new clone must be mutable if the original
matrix is mutable, i.e. mutating the clone must not affect the original. The copy should be shallow, if applicable.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-clone"><h3>clone</h3><div class="usage"><code>(clone m)</code></div><div class="doc"><pre class="plaintext">Returns a clone of an array. Must be a new independent (non-view)
instance if the array is mutable.</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L107">view source</a></div></div><div class="public anchor" id="var-PMatrixColumns"><h3>PMatrixColumns</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for accessing columns of a matrix
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-get-columns"><h3>get-columns</h3><div class="usage"><code>(get-columns m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L306">view source</a></div></div><div class="public anchor" id="var-PMatrixDivide"><h3>PMatrixDivide</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support element-wise division operator.
One-arg version returns the reciprocal of all elements.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-element-divide"><h3>element-divide</h3><div class="usage"><code>(element-divide m)</code><code>(element-divide m a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L477">view source</a></div></div><div class="public anchor" id="var-PMatrixDivideMutable"><h3>PMatrixDivideMutable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support mutable element-wise division operater.
One-arg version returns the reciprocal of all elements.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-element-divide.21"><h3>element-divide!</h3><div class="usage"><code>(element-divide! m)</code><code>(element-divide! m a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L484">view source</a></div></div><div class="public anchor" id="var-PMatrixEquality"><h3>PMatrixEquality</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for numerical array equality operations.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-matrix-equals"><h3>matrix-equals</h3><div class="usage"><code>(matrix-equals a b)</code></div><div class="doc"><pre class="plaintext">Return true if a equals b, i.e. if a and b are have the same shape and all elements are equal.
Must use numerical value comparison on numbers (==) to account for matrices that may hold a mix of
numercial types (e.g. java.lang.Long and java.lang.Double). Implementations that only support doubles
should use Number.doubleValue() to get a numeric value to compare.
May throw an exception if the matrices are non-numeric</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L422">view source</a></div></div><div class="public anchor" id="var-PMatrixEqualityEpsilon"><h3>PMatrixEqualityEpsilon</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for numerical array equality operations with a specified tolerance.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-matrix-equals-epsilon"><h3>matrix-equals-epsilon</h3><div class="usage"><code>(matrix-equals-epsilon a b eps)</code></div><div class="doc"><pre class="plaintext">As matrix-equals, but provides a numerical tolerance for equality testing.
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L431">view source</a></div></div><div class="public anchor" id="var-PMatrixMultiply"><h3>PMatrixMultiply</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support matrix multiplication on an arbitrary matrix, vector or scalar.

Implementation may return nil if the implementation does not support one of the parameters, in
which case a more general operation will be attempted.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-element-multiply"><h3>element-multiply</h3><div class="usage"><code>(element-multiply m a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-matrix-multiply"><h3>matrix-multiply</h3><div class="usage"><code>(matrix-multiply m a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L436">view source</a></div></div><div class="public anchor" id="var-PMatrixMultiplyMutable"><h3>PMatrixMultiplyMutable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support mutable matrix multiplication on an arbitrary matrix, vector or scalar
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-element-multiply.21"><h3>element-multiply!</h3><div class="usage"><code>(element-multiply! m a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-matrix-multiply.21"><h3>matrix-multiply!</h3><div class="usage"><code>(matrix-multiply! m a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L491">view source</a></div></div><div class="public anchor" id="var-PMatrixMutableScaling"><h3>PMatrixMutableScaling</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support mutable array scaling by scalar values.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-pre-scale.21"><h3>pre-scale!</h3><div class="usage"><code>(pre-scale! m factor)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-scale.21"><h3>scale!</h3><div class="usage"><code>(scale! m factor)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L517">view source</a></div></div><div class="public anchor" id="var-PMatrixOps"><h3>PMatrixOps</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support common 2D numerical matrix operations
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-determinant"><h3>determinant</h3><div class="usage"><code>(determinant m)</code></div><div class="doc"><pre class="plaintext">Returns the determinant of a matrix.
</pre></div></div><div class="public anchor" id="var-inverse"><h3>inverse</h3><div class="usage"><code>(inverse m)</code></div><div class="doc"><pre class="plaintext">Returns the invese of a matrix. Should throw an exception if m is not invertible.
</pre></div></div><div class="public anchor" id="var-trace"><h3>trace</h3><div class="usage"><code>(trace m)</code></div><div class="doc"><pre class="plaintext">Returns the trace of a matrix (sum of elements on main diagonal.
Must throw an error if the matrix is not square (i.e. all dimensions sizes are equal)</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L628">view source</a></div></div><div class="public anchor" id="var-PMatrixPredicates"><h3>PMatrixPredicates</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for matrix predicates like identity-matrix? or zero-matrix?
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-identity-matrix.3F"><h3>identity-matrix?</h3><div class="usage"><code>(identity-matrix? m)</code></div><div class="doc"><pre class="plaintext">returns true if the matrix m is an identity-matrix
</pre></div></div><div class="public anchor" id="var-symmetric.3F"><h3>symmetric?</h3><div class="usage"><code>(symmetric? m)</code></div><div class="doc"><pre class="plaintext">returns true if matrix m is symmetric
</pre></div></div><div class="public anchor" id="var-zero-matrix.3F"><h3>zero-matrix?</h3><div class="usage"><code>(zero-matrix? m)</code></div><div class="doc"><pre class="plaintext">returns true if all the elements of matrix m are zeros
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L737">view source</a></div></div><div class="public anchor" id="var-PMatrixProducts"><h3>PMatrixProducts</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for general inner and outer products of arrays.
Products should use + and * as normally defined for numerical types</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-inner-product"><h3>inner-product</h3><div class="usage"><code>(inner-product m a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-outer-product"><h3>outer-product</h3><div class="usage"><code>(outer-product m a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L444">view source</a></div></div><div class="public anchor" id="var-PMatrixRank"><h3>PMatrixRank</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support computing the rank (number of linearly independent rows) in a matrix
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-rank"><h3>rank</h3><div class="usage"><code>(rank m)</code></div><div class="doc"><pre class="plaintext">Returns the rank of a matrix
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L642">view source</a></div></div><div class="public anchor" id="var-PMatrixRows"><h3>PMatrixRows</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for accessing rows of a matrix
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-get-rows"><h3>get-rows</h3><div class="usage"><code>(get-rows m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L302">view source</a></div></div><div class="public anchor" id="var-PMatrixScaling"><h3>PMatrixScaling</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support numerical array scaling by scalar values. Provided because array classes may have
efficient specialised scaling operaions.

Works according the the default definition of multiplication for the matrix class
(usually numerical, i.e. equivalent to clojure.core/+)</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-pre-scale"><h3>pre-scale</h3><div class="usage"><code>(pre-scale m a)</code></div><div class="doc"><pre class="plaintext">Pre-multiplies the array with the scalar. This is the same as scale for arrays
where multiplication is commutative, but may be different for special kinds of scalars.</pre></div></div><div class="public anchor" id="var-scale"><h3>scale</h3><div class="usage"><code>(scale m a)</code></div><div class="doc"><pre class="plaintext">Multiplies a array by the scalar value a, 
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L505">view source</a></div></div><div class="public anchor" id="var-PMatrixSlices"><h3>PMatrixSlices</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support getting slices of an array.  If implemented, must return either a view, a scalar
or an immutable sub-matrix: it must *not* return copied data. i.e. making a full copy must be avoided.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-get-column"><h3>get-column</h3><div class="usage"><code>(get-column m i)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-get-major-slice"><h3>get-major-slice</h3><div class="usage"><code>(get-major-slice m i)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-get-row"><h3>get-row</h3><div class="usage"><code>(get-row m i)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-get-slice"><h3>get-slice</h3><div class="usage"><code>(get-slice m dimension i)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L294">view source</a></div></div><div class="public anchor" id="var-PMatrixSubComponents"><h3>PMatrixSubComponents</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for picking out subsections of a 2D matrix. Should return a mutable view if possible.
The default implementation creates a new vector containing the diagonal values.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-main-diagonal"><h3>main-diagonal</h3><div class="usage"><code>(main-diagonal m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L357">view source</a></div></div><div class="public anchor" id="var-PMatrixTypes"><h3>PMatrixTypes</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-diagonal.3F"><h3>diagonal?</h3><div class="usage"><code>(diagonal? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the matrix is diagonal
</pre></div></div><div class="public anchor" id="var-lower-triangular.3F"><h3>lower-triangular?</h3><div class="usage"><code>(lower-triangular? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the matrix m is lower triangualar
</pre></div></div><div class="public anchor" id="var-orthogonal.3F"><h3>orthogonal?</h3><div class="usage"><code>(orthogonal? m eps)</code></div><div class="doc"><pre class="plaintext">Returns true if the matrix is orthogonal
</pre></div></div><div class="public anchor" id="var-positive-definite.3F"><h3>positive-definite?</h3><div class="usage"><code>(positive-definite? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the matrix is positive definite
</pre></div></div><div class="public anchor" id="var-positive-semidefinite.3F"><h3>positive-semidefinite?</h3><div class="usage"><code>(positive-semidefinite? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the matrix is positive semidefinite
</pre></div></div><div class="public anchor" id="var-upper-triangular.3F"><h3>upper-triangular?</h3><div class="usage"><code>(upper-triangular? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the matrix m is upper triangualar
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L749">view source</a></div></div><div class="public anchor" id="var-PMutableFill"><h3>PMutableFill</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-fill.21"><h3>fill!</h3><div class="usage"><code>(fill! m value)</code></div><div class="doc"><pre class="plaintext">Fills the array with the given scalar value.
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L394">view source</a></div></div><div class="public anchor" id="var-PMutableMatrixConstruction"><h3>PMutableMatrixConstruction</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for creating a mutable copy of a matrix. If implemented, must return either a fully mutable
copy of the given matrix, or nil if not possible.

The default implementation will attempt to choose a suitable mutable matrix implementation.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-mutable-matrix"><h3>mutable-matrix</h3><div class="usage"><code>(mutable-matrix m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L159">view source</a></div></div><div class="public anchor" id="var-PMutableVectorOps"><h3>PMutableVectorOps</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for mutable versions of common vector operations
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-normalise.21"><h3>normalise!</h3><div class="usage"><code>(normalise! a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L624">view source</a></div></div><div class="public anchor" id="var-PNegation"><h3>PNegation</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-negate"><h3>negate</h3><div class="usage"><code>(negate m)</code></div><div class="doc"><pre class="plaintext">Returns a new numerical array with all elements negated.
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L638">view source</a></div></div><div class="public anchor" id="var-PNewSparseArray"><h3>PNewSparseArray</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for constructing sparse arrays. Should return nil if the sparse array shape is not supported.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-new-sparse-array"><h3>new-sparse-array</h3><div class="usage"><code>(new-sparse-array m shape)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L368">view source</a></div></div><div class="public anchor" id="var-PNonZeroIndices"><h3>PNonZeroIndices</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for getting non-zero indices of an array
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-non-zero-indices"><h3>non-zero-indices</h3><div class="usage"><code>(non-zero-indices m)</code></div><div class="doc"><pre class="plaintext">Gets the non-zero indices of an array.
- For a 1D vector, returns an ordered index list.
- For a higher dimensional array, returns the non-zero-indices for each slice in row-major order.</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L797">view source</a></div></div><div class="public anchor" id="var-PNorm"><h3>PNorm</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for matrix and vector norms
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-norm"><h3>norm</h3><div class="usage"><code>(norm m p)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L823">view source</a></div></div><div class="public anchor" id="var-PNumerical"><h3>PNumerical</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for identifying numerical arrays. Should return true if every element in the
array is a valid numerical value.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-numerical.3F"><h3>numerical?</h3><div class="usage"><code>(numerical? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the array is numerical.
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L577">view source</a></div></div><div class="public anchor" id="var-PObjectArrayOutput"><h3>PObjectArrayOutput</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for getting data as an object array
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-as-object-array"><h3>as-object-array</h3><div class="usage"><code>(as-object-array m)</code></div><div class="doc"><pre class="plaintext">Returns the internal object array used by m. If no such array is used, returns nil.
Provides an opportunity to avoid copying the internal array.</pre></div></div><div class="public anchor" id="var-to-object-array"><h3>to-object-array</h3><div class="usage"><code>(to-object-array m)</code></div><div class="doc"><pre class="plaintext">Returns an object array containing the values of m in row-major order. May or may not be
the internal object array used by m, depending on the implementation.</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L408">view source</a></div></div><div class="public anchor" id="var-POrder"><h3>POrder</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for matrix reorder. May reorder along any dimension.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-order"><h3>order</h3><div class="usage"><code>(order m indices)</code><code>(order m dimension indices)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L571">view source</a></div></div><div class="public anchor" id="var-PPack"><h3>PPack</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to efficiently pack an array, according to the most efficient representation for a given
implementation.

Definition of pack is up to the implementation to interpret, but the general rules are:
1. Must not change the value of the array for comparison purposes
2. Must not change the shape of the array
3. May preserve sparse representation
4. Should convert to most efficient format for common operations (e.g. mget, inner-product)</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-pack"><h3>pack</h3><div class="usage"><code>(pack m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L277">view source</a></div></div><div class="public anchor" id="var-PPermutationMatrix"><h3>PPermutationMatrix</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for construction of a permutation matrix.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-permutation-matrix"><h3>permutation-matrix</h3><div class="usage"><code>(permutation-matrix m permutation)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L211">view source</a></div></div><div class="public anchor" id="var-PQRDecomposition"><h3>PQRDecomposition</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for QR decomposition
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-qr"><h3>qr</h3><div class="usage"><code>(qr m options)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L827">view source</a></div></div><div class="public anchor" id="var-PReshaping"><h3>PReshaping</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to reshape matrices. Should support any new shape allowed by the implementation.
Must preserve row-major ordering of matrix elements.
If the original matrix is mutable, must return a new mutable copy of data.
If the new shape has less elements than the original shape, it is OK to truncate the remaining elements.
If the new shape requires more elements than the original shape, should throw an exception.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-reshape"><h3>reshape</h3><div class="usage"><code>(reshape m shape)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L269">view source</a></div></div><div class="public anchor" id="var-PRotate"><h3>PRotate</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Rotates an array along a specified dimension by the given number of places.

Rotating a dimension that does not exist has no effect on the array.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-rotate"><h3>rotate</h3><div class="usage"><code>(rotate m dim places)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L554">view source</a></div></div><div class="public anchor" id="var-PRotateAll"><h3>PRotateAll</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Rotates an array using the specified shifts for each dimension.

shifts may be any sequence of integer shift amounts.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-rotate-all"><h3>rotate-all</h3><div class="usage"><code>(rotate-all m shifts)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L560">view source</a></div></div><div class="public anchor" id="var-PRowColMatrix"><h3>PRowColMatrix</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support construction of row and column matrices from 1D vectors.

A vector of length N should be converted to a 1xN or Nx1 matrix respectively.

Should throw an error if the data is not a 1D vector</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-column-matrix"><h3>column-matrix</h3><div class="usage"><code>(column-matrix m data)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-row-matrix"><h3>row-matrix</h3><div class="usage"><code>(row-matrix m data)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L150">view source</a></div></div><div class="public anchor" id="var-PRowOperations"><h3>PRowOperations</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for elementary row operations
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-add-row"><h3>add-row</h3><div class="usage"><code>(add-row m i j k)</code></div><div class="doc"><pre class="plaintext">Returns a new matrix with row i added to row j times k
</pre></div></div><div class="public anchor" id="var-multiply-row"><h3>multiply-row</h3><div class="usage"><code>(multiply-row m i k)</code></div><div class="doc"><pre class="plaintext">Returns a new matrix with row i multiplied by k
</pre></div></div><div class="public anchor" id="var-swap-rows"><h3>swap-rows</h3><div class="usage"><code>(swap-rows m i j)</code></div><div class="doc"><pre class="plaintext">Returns a new matrix with rows i and j swapped
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L667">view source</a></div></div><div class="public anchor" id="var-PRowSetting"><h3>PRowSetting</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for row setting. Should set a dimension 0 (row) slice to thegiven row value.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-set-row"><h3>set-row</h3><div class="usage"><code>(set-row m i row)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-set-row.21"><h3>set-row!</h3><div class="usage"><code>(set-row! m i row)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L676">view source</a></div></div><div class="public anchor" id="var-PSameShape"><h3>PSameShape</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to test if two arrays have the same shape. Implementations may have an optimised
method for shape equality tests, and this is a frequently required operations so it may
make sense to provide an optimised implementation.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-same-shape.3F"><h3>same-shape?</h3><div class="usage"><code>(same-shape? a b)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L288">view source</a></div></div><div class="public anchor" id="var-PSelect"><h3>PSelect</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for the sel function
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-select"><h3>select</h3><div class="usage"><code>(select a args)</code></div><div class="doc"><pre class="plaintext">selects all elements at indices which are in the cartesian product of args
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L780">view source</a></div></div><div class="public anchor" id="var-PSetSelection"><h3>PSetSelection</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for setting the elements of an array returned by (select a args) to values
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-set-selection"><h3>set-selection</h3><div class="usage"><code>(set-selection a args values)</code></div><div class="doc"><pre class="plaintext">sets the elements in the selection of a to values
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L784">view source</a></div></div><div class="public anchor" id="var-PSliceJoin"><h3>PSliceJoin</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for concatenating / joining arrays.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-join"><h3>join</h3><div class="usage"><code>(join m a)</code></div><div class="doc"><pre class="plaintext">Concatenates a to m, along the major slice dimension
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L342">view source</a></div></div><div class="public anchor" id="var-PSliceJoinAlong"><h3>PSliceJoinAlong</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for concatenating / joining arrays.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-join-along"><h3>join-along</h3><div class="usage"><code>(join-along m a dim)</code></div><div class="doc"><pre class="plaintext">Concatenates a to m, along the slice dimension dim
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L346">view source</a></div></div><div class="public anchor" id="var-PSliceSeq"><h3>PSliceSeq</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Returns the row-major slices of the array as a sequence.

These must be views or immutable sub-arrays for higher order slices, or scalars
for the slices of a 1D vector.

The default implementation uses get-major-slice-view to obtain the slices.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-get-major-slice-seq"><h3>get-major-slice-seq</h3><div class="usage"><code>(get-major-slice-seq m)</code></div><div class="doc"><pre class="plaintext">Gets a sequence of all major array slices
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L319">view source</a></div></div><div class="public anchor" id="var-PSliceSeq2"><h3>PSliceSeq2</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Returns slices of the array as a sequence.

These must be views or immutable sub-arrays for higher order slices, or scalars
for the slices of a 1D vector.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-get-slice-seq"><h3>get-slice-seq</h3><div class="usage"><code>(get-slice-seq m dim)</code></div><div class="doc"><pre class="plaintext">Gets a sequence of all array slices
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L328">view source</a></div></div><div class="public anchor" id="var-PSliceView"><h3>PSliceView</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for quick view access into a row-major slices of an array. If implemented, must return
either a view or an immutable sub-matrix: it must *not* return copied data.

If the matrix is mutable, it must return a mutable view.

The default implementation creates a wrapper view.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-get-major-slice-view"><h3>get-major-slice-view</h3><div class="usage"><code>(get-major-slice-view m i)</code></div><div class="doc"><pre class="plaintext">Gets a view of a major array slice
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L310">view source</a></div></div><div class="public anchor" id="var-PSliceViewSeq"><h3>PSliceViewSeq</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Returns the row-major slice views of the array.

These must be arrays if the array is mutable, i.e. slices of a 1D vector
must be 0-dimensional mutable arrays.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-get-major-slice-view-seq"><h3>get-major-slice-view-seq</h3><div class="usage"><code>(get-major-slice-view-seq m)</code></div><div class="doc"><pre class="plaintext">Gets a sequence of all major array slices
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L335">view source</a></div></div><div class="public anchor" id="var-PSolveLinear"><h3>PSolveLinear</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for solving linear matrix equation or system of linear scalar equations
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-solve"><h3>solve</h3><div class="usage"><code>(solve a b)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L847">view source</a></div></div><div class="public anchor" id="var-PSparse"><h3>PSparse</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for constructing a sparse array from the given data. Implementations should
consider the possibility that data may be a large lazy sequence, possibly larger than memory, so should ideally
attempt to construct the sparse matrix incrementally without realising the whole sequence at once.

May return nil if no sparse conversion is available.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-sparse"><h3>sparse</h3><div class="usage"><code>(sparse m)</code></div><div class="doc"><pre class="plaintext">Attempts to make array into a sparse format. Must return the same array unchanged if not possible.
</pre></div></div><div class="public anchor" id="var-sparse-coerce"><h3>sparse-coerce</h3><div class="usage"><code>(sparse-coerce m data)</code></div><div class="doc"><pre class="plaintext">Attempts to coerce data to a sparse array of implementation m. May return nil if not supported
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L166">view source</a></div></div><div class="public anchor" id="var-PSparseArray"><h3>PSparseArray</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for determining if an array is in a sparse format. It is up to the implementation to define
its own sparse formats, but in general the intention should be that a sparse array uses significantly
less storage than an equivalent dense array, assuming a high proportion of zero values in the array.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-is-sparse.3F"><h3>is-sparse?</h3><div class="usage"><code>(is-sparse? m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L362">view source</a></div></div><div class="public anchor" id="var-PSpecialisedConstructors"><h3>PSpecialisedConstructors</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for construction of special matrices.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-diagonal-matrix"><h3>diagonal-matrix</h3><div class="usage"><code>(diagonal-matrix m diagonal-values)</code></div><div class="doc"><pre class="plaintext">Create a diagonal matrix with the specified leading diagonal values
</pre></div></div><div class="public anchor" id="var-identity-matrix"><h3>identity-matrix</h3><div class="usage"><code>(identity-matrix m dims)</code></div><div class="doc"><pre class="plaintext">Create a 2D identity matrix with the given number of dimensions
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L206">view source</a></div></div><div class="public anchor" id="var-PSquare"><h3>PSquare</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support element-wise squaring of a numerical array.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-square"><h3>square</h3><div class="usage"><code>(square m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L659">view source</a></div></div><div class="public anchor" id="var-PSubMatrix"><h3>PSubMatrix</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to get a subarray of another array. dim-ranges should be a sequence of [start len]
pairs, one for each dimension. If a pair is nil, it should be interpreted to take the whole dimension.

Returning a mutable view is preferred, if the implementation supports this.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-submatrix"><h3>submatrix</h3><div class="usage"><code>(submatrix d dim-ranges)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L533">view source</a></div></div><div class="public anchor" id="var-PSubVector"><h3>PSubVector</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for getting a sub-vector view of a vector. Must return a mutable view
if the original vector is mutable. Should throw an exception if the specified
subvector is out of bounds for the target vector.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-subvector"><h3>subvector</h3><div class="usage"><code>(subvector m start length)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L350">view source</a></div></div><div class="public anchor" id="var-PSummable"><h3>PSummable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support the summing of all elements in an array.
The array must hold numeric values only, or an exception will be thrown.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-element-sum"><h3>element-sum</h3><div class="usage"><code>(element-sum m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L647">view source</a></div></div><div class="public anchor" id="var-PSVDDecomposition"><h3>PSVDDecomposition</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for SVD decomposition
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-svd"><h3>svd</h3><div class="usage"><code>(svd m options)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L839">view source</a></div></div><div class="public anchor" id="var-PTranspose"><h3>PTranspose</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for array transpose operation
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-transpose"><h3>transpose</h3><div class="usage"><code>(transpose m)</code></div><div class="doc"><pre class="plaintext">Returns the transpose of a matrix. Equivalent to reversing the &quot;shape&quot;.
Note that:
- The transpose of a scalar is the same scalar
- The transpose of a 1D vector is the same 1D vector
- The transpose of a 2D matrix swaps rows and columns</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L545">view source</a></div></div><div class="public anchor" id="var-PTransposeInPlace"><h3>PTransposeInPlace</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for mutable 2D matrix transpose in place
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-transpose.21"><h3>transpose!</h3><div class="usage"><code>(transpose! m)</code></div><div class="doc"><pre class="plaintext">Transposes a mutable 2D matrix in place
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L566">view source</a></div></div><div class="public anchor" id="var-PTypeInfo"><h3>PTypeInfo</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for querying the type of matrix elements. If not provided, the default implementation will
return java.lang.Object, and the matrix object must accept any type of value.
If a matrix is primitive-backed, it should return the appropriate primitive type e.g. Double/TYPE.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-element-type"><h3>element-type</h3><div class="usage"><code>(element-type m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L135">view source</a></div></div><div class="public anchor" id="var-PValidateShape"><h3>PValidateShape</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Optional protocol to validate the shape of a matrix. If the matrix has an incorrect shape, should
throw an error. Otherwise it should return the correct shape.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-validate-shape"><h3>validate-shape</h3><div class="usage"><code>(validate-shape m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L145">view source</a></div></div><div class="public anchor" id="var-PValueEquality"><h3>PValueEquality</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for comparing two arrays, with the semantics of clojure.core/=.
Returns false if the arrays are not of equal shape, or if any elements are not equal.</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-value-equals"><h3>value-equals</h3><div class="usage"><code>(value-equals m a)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L417">view source</a></div></div><div class="public anchor" id="var-PVectorCross"><h3>PVectorCross</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-cross-product"><h3>cross-product</h3><div class="usage"><code>(cross-product a b)</code></div><div class="doc"><pre class="plaintext">Cross product of two vectors
</pre></div></div><div class="public anchor" id="var-cross-product.21"><h3>cross-product!</h3><div class="usage"><code>(cross-product! a b)</code></div><div class="doc"><pre class="plaintext">Calculate cross product of two vectors, storing the result in the first vector
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L601">view source</a></div></div><div class="public anchor" id="var-PVectorDistance"><h3>PVectorDistance</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-distance"><h3>distance</h3><div class="usage"><code>(distance a b)</code></div><div class="doc"><pre class="plaintext">Euclidean distance of two vectors.
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L607">view source</a></div></div><div class="public anchor" id="var-PVectorisable"><h3>PVectorisable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to return an array as a flattened vector of all elements.
Implementations are encouraged to avoid taking a full copy of all data
(e.g. by using structural sharing or views).</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-to-vector"><h3>to-vector</h3><div class="usage"><code>(to-vector m)</code></div><div class="doc"><pre class="plaintext">Returns an array as a single flattened vector
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L616">view source</a></div></div><div class="public anchor" id="var-PVectorOps"><h3>PVectorOps</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support common numerical vector operations.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-length"><h3>length</h3><div class="usage"><code>(length a)</code></div><div class="doc"><pre class="plaintext">Euclidian length of a vector.
</pre></div></div><div class="public anchor" id="var-length-squared"><h3>length-squared</h3><div class="usage"><code>(length-squared a)</code></div><div class="doc"><pre class="plaintext">Squared Euclidean length of a vector.
</pre></div></div><div class="public anchor" id="var-normalise"><h3>normalise</h3><div class="usage"><code>(normalise a)</code></div><div class="doc"><pre class="plaintext">Returns a new vector, normalised to length 1.0
</pre></div></div><div class="public anchor" id="var-vector-dot"><h3>vector-dot</h3><div class="usage"><code>(vector-dot a b)</code></div><div class="doc"><pre class="plaintext">Numerical dot product of two vectors. Must return a scalar value if the two parameters are
vectors of equal length.

If the vectors are of unequal length, should throw an exception (however returning nil is
also acceptable).

Otherwise the implementation may optionally either return nil or compute a higher dimensional
inner-product (if it is able to do so).</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L583">view source</a></div></div><div class="public anchor" id="var-PVectorTransform"><h3>PVectorTransform</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol to support transformation of a vector to another vector.
Is equivalent to matrix multiplication when 2D matrices are used as transformations.
But other transformations are possible, e.g. affine transformations.

A transformation need not be a core.matrix matrix: other types are permissible</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-vector-transform"><h3>vector-transform</h3><div class="usage"><code>(vector-transform t v)</code></div><div class="doc"><pre class="plaintext">Transforms a vector
</pre></div></div><div class="public anchor" id="var-vector-transform.21"><h3>vector-transform!</h3><div class="usage"><code>(vector-transform! t v)</code></div><div class="doc"><pre class="plaintext">Transforms a vector in place - mutates the vector argument
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L496">view source</a></div></div><div class="public anchor" id="var-PVectorView"><h3>PVectorView</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-as-vector"><h3>as-vector</h3><div class="usage"><code>(as-vector m)</code></div><div class="doc"><pre class="plaintext">Returns a view of an array as a single flattened vector. May return the vector itself
if it is already a 1D vector.</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L611">view source</a></div></div><div class="public anchor" id="var-PZeroCount"><h3>PZeroCount</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for counting the number of zeros in an array
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-zero-count"><h3>zero-count</h3><div class="usage"><code>(zero-count m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L372">view source</a></div></div><div class="public anchor" id="var-PZeroDimensionAccess"><h3>PZeroDimensionAccess</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for accessing the scalar value in zero-dimensional arrays. Zero dimensional arrays differ
from scalar values in the following two senses:
 - They may be mutable (in which case set-0d! is expected to work)
 - They are not considered themselves to be scalars. Hence you must use get-0d to access the
   contained scalar value</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-get-0d"><h3>get-0d</h3><div class="usage"><code>(get-0d m)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-set-0d.21"><h3>set-0d!</h3><div class="usage"><code>(set-0d! m value)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L193">view source</a></div></div><div class="public anchor" id="var-PZeroDimensionConstruction"><h3>PZeroDimensionConstruction</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-new-scalar-array"><h3>new-scalar-array</h3><div class="usage"><code>(new-scalar-array m)</code><code>(new-scalar-array m value)</code></div><div class="doc"><pre class="plaintext">Construct a new zero-dimensional array with the specified scalar value (zero if not specified)
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L187">view source</a></div></div><div class="public anchor" id="var-PZeroDimensionSet"><h3>PZeroDimensionSet</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Protocol for setting the scalar value in zero-dimensional arrays.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-set-0d"><h3>set-0d</h3><div class="usage"><code>(set-0d m value)</code></div><div class="doc"><pre class="plaintext">Sets the scalar value in a 0-d array, returning a new 0-d array
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L202">view source</a></div></div><div class="public anchor" id="var-same-shapes.3F"><h3>same-shapes?</h3><div class="usage"><code>(same-shapes? arrays)</code></div><div class="doc"><pre class="plaintext">Returns true if a sequence of arrays all have the same shape.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L910">view source</a></div></div><div class="public anchor" id="var-supports-type.3F"><h3>supports-type?</h3><div class="usage"><code>(supports-type? m klass)</code></div><div class="doc"><pre class="plaintext">Checks if an array can contain a specified Java type.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix/protocols.clj#L921">view source</a></div></div></div></body></html>