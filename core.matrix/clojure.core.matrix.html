<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>clojure.core.matrix documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Core.matrix 0.31.2-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></div></li><li class="depth-3 current"><a href="clojure.core.matrix.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matrix</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.compliance-tester.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>compliance-tester</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.dataset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dataset</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.experimental.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>experimental</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.generic.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generic</span></div></a></li><li class="depth-4"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>impl</span></div></div></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.clojure.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.common.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>common</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.dataset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dataset</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.default.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>default</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.double-array.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>double-array</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.index.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>index</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.mathsops.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mathsops</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.ndarray.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ndarray</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.ndarray-double.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ndarray-double</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.ndarray-macro.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ndarray-macro</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.ndarray-magic.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ndarray-magic</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.ndarray-object.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ndarray-object</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.object-array.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>object-array</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.persistent-vector.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>persistent-vector</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.pprint.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pprint</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.sequence.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sequence</span></div></a></li><li class="depth-5 branch"><a href="clojure.core.matrix.impl.sparse-map.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sparse-map</span></div></a></li><li class="depth-5"><a href="clojure.core.matrix.impl.wrappers.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>wrappers</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.implementations.html"><div class="inner"><span class="tree" style="top: -579px;"><span class="top" style="height: 588px;"></span><span class="bottom"></span></span><span>implementations</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.io.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>io</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.linear.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>linear</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.multimethods.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>multimethods</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.operators.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>operators</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-4 branch"><a href="clojure.core.matrix.select.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>select</span></div></a></li><li class="depth-4"><a href="clojure.core.matrix.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="clojure.core.matrix.html#var-abs"><div class="inner"><span>abs</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-abs.21"><div class="inner"><span>abs!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-acos"><div class="inner"><span>acos</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-acos.21"><div class="inner"><span>acos!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-add"><div class="inner"><span>add</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-add.21"><div class="inner"><span>add!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-add-product"><div class="inner"><span>add-product</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-add-product.21"><div class="inner"><span>add-product!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-add-row"><div class="inner"><span>add-row</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-add-scaled"><div class="inner"><span>add-scaled</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-add-scaled.21"><div class="inner"><span>add-scaled!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-add-scaled-product"><div class="inner"><span>add-scaled-product</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-add-scaled-product.21"><div class="inner"><span>add-scaled-product!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-array"><div class="inner"><span>array</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-array.3F"><div class="inner"><span>array?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-as-vector"><div class="inner"><span>as-vector</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-asin"><div class="inner"><span>asin</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-asin.21"><div class="inner"><span>asin!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-assign"><div class="inner"><span>assign</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-assign.21"><div class="inner"><span>assign!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-assign-array.21"><div class="inner"><span>assign-array!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-atan"><div class="inner"><span>atan</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-atan.21"><div class="inner"><span>atan!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-block-diagonal-matrix"><div class="inner"><span>block-diagonal-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-broadcast"><div class="inner"><span>broadcast</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-broadcast-coerce"><div class="inner"><span>broadcast-coerce</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-broadcast-like"><div class="inner"><span>broadcast-like</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-cbrt"><div class="inner"><span>cbrt</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-cbrt.21"><div class="inner"><span>cbrt!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-ceil"><div class="inner"><span>ceil</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-ceil.21"><div class="inner"><span>ceil!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-clone"><div class="inner"><span>clone</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-coerce"><div class="inner"><span>coerce</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-column-count"><div class="inner"><span>column-count</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-column-matrix"><div class="inner"><span>column-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-column-matrix.3F"><div class="inner"><span>column-matrix?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-columns"><div class="inner"><span>columns</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-compute-matrix"><div class="inner"><span>compute-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-conforming.3F"><div class="inner"><span>conforming?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-cos"><div class="inner"><span>cos</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-cos.21"><div class="inner"><span>cos!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-cosh"><div class="inner"><span>cosh</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-cosh.21"><div class="inner"><span>cosh!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-cross"><div class="inner"><span>cross</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-cross.21"><div class="inner"><span>cross!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-current-implementation"><div class="inner"><span>current-implementation</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-current-implementation-object"><div class="inner"><span>current-implementation-object</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-dense"><div class="inner"><span>dense</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-density"><div class="inner"><span>density</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-det"><div class="inner"><span>det</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-diagonal"><div class="inner"><span>diagonal</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-diagonal-matrix"><div class="inner"><span>diagonal-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-diagonal.3F"><div class="inner"><span>diagonal?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-dimension-count"><div class="inner"><span>dimension-count</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-dimensionality"><div class="inner"><span>dimensionality</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-distance"><div class="inner"><span>distance</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-div"><div class="inner"><span>div</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-div.21"><div class="inner"><span>div!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-dot"><div class="inner"><span>dot</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-e*"><div class="inner"><span>e*</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-e.3D"><div class="inner"><span>e=</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-e.3D.3D"><div class="inner"><span>e==</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-ecount"><div class="inner"><span>ecount</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-element-type"><div class="inner"><span>element-type</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-emap"><div class="inner"><span>emap</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-emap.21"><div class="inner"><span>emap!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-emax"><div class="inner"><span>emax</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-emin"><div class="inner"><span>emin</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-emul"><div class="inner"><span>emul</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-emul.21"><div class="inner"><span>emul!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-ensure-mutable"><div class="inner"><span>ensure-mutable</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-equals"><div class="inner"><span>equals</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-ereduce"><div class="inner"><span>ereduce</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-eseq"><div class="inner"><span>eseq</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-esum"><div class="inner"><span>esum</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-exp"><div class="inner"><span>exp</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-exp.21"><div class="inner"><span>exp!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-fill"><div class="inner"><span>fill</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-fill.21"><div class="inner"><span>fill!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-floor"><div class="inner"><span>floor</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-floor.21"><div class="inner"><span>floor!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-get-column"><div class="inner"><span>get-column</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-get-row"><div class="inner"><span>get-row</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-identity-matrix"><div class="inner"><span>identity-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-identity-matrix.3F"><div class="inner"><span>identity-matrix?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-immutable"><div class="inner"><span>immutable</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-index"><div class="inner"><span>index</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-index-seq"><div class="inner"><span>index-seq</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-index-seq-for-shape"><div class="inner"><span>index-seq-for-shape</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-index.3F"><div class="inner"><span>index?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-inner-product"><div class="inner"><span>inner-product</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-inverse"><div class="inner"><span>inverse</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-join"><div class="inner"><span>join</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-join-along"><div class="inner"><span>join-along</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-label"><div class="inner"><span>label</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-labels"><div class="inner"><span>labels</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-length"><div class="inner"><span>length</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-length-squared"><div class="inner"><span>length-squared</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-log"><div class="inner"><span>log</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-log.21"><div class="inner"><span>log!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-log10"><div class="inner"><span>log10</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-log10.21"><div class="inner"><span>log10!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-lower-triangular.3F"><div class="inner"><span>lower-triangular?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-main-diagonal"><div class="inner"><span>main-diagonal</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-matrix"><div class="inner"><span>matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-matrix.3F"><div class="inner"><span>matrix?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-mget"><div class="inner"><span>mget</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-mmul"><div class="inner"><span>mmul</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-mset"><div class="inner"><span>mset</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-mset.21"><div class="inner"><span>mset!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-mul"><div class="inner"><span>mul</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-mul.21"><div class="inner"><span>mul!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-multiply-row"><div class="inner"><span>multiply-row</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-mutable"><div class="inner"><span>mutable</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-mutable-matrix"><div class="inner"><span>mutable-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-mutable.3F"><div class="inner"><span>mutable?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-negate"><div class="inner"><span>negate</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-negate.21"><div class="inner"><span>negate!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-new-array"><div class="inner"><span>new-array</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-new-matrix"><div class="inner"><span>new-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-new-scalar-array"><div class="inner"><span>new-scalar-array</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-new-sparse-array"><div class="inner"><span>new-sparse-array</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-new-vector"><div class="inner"><span>new-vector</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-non-zero-count"><div class="inner"><span>non-zero-count</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-non-zero-indices"><div class="inner"><span>non-zero-indices</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-normalise"><div class="inner"><span>normalise</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-normalise.21"><div class="inner"><span>normalise!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-numerical.3F"><div class="inner"><span>numerical?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-order"><div class="inner"><span>order</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-orthogonal.3F"><div class="inner"><span>orthogonal?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-outer-product"><div class="inner"><span>outer-product</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-pack"><div class="inner"><span>pack</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-permutation-matrix"><div class="inner"><span>permutation-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-pm"><div class="inner"><span>pm</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-pow"><div class="inner"><span>pow</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-pow.21"><div class="inner"><span>pow!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-reshape"><div class="inner"><span>reshape</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-rotate"><div class="inner"><span>rotate</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-round"><div class="inner"><span>round</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-round.21"><div class="inner"><span>round!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-row-count"><div class="inner"><span>row-count</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-row-matrix"><div class="inner"><span>row-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-row-matrix.3F"><div class="inner"><span>row-matrix?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-rows"><div class="inner"><span>rows</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-same-shape.3F"><div class="inner"><span>same-shape?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-scalar"><div class="inner"><span>scalar</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-scalar-array"><div class="inner"><span>scalar-array</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-scalar.3F"><div class="inner"><span>scalar?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-scale"><div class="inner"><span>scale</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-scale.21"><div class="inner"><span>scale!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-select"><div class="inner"><span>select</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-select-indices"><div class="inner"><span>select-indices</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-set-column"><div class="inner"><span>set-column</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-set-column.21"><div class="inner"><span>set-column!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-set-current-implementation"><div class="inner"><span>set-current-implementation</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-set-indices"><div class="inner"><span>set-indices</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-set-indices.21"><div class="inner"><span>set-indices!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-set-row"><div class="inner"><span>set-row</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-set-row.21"><div class="inner"><span>set-row!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-set-selection"><div class="inner"><span>set-selection</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-set-selection.21"><div class="inner"><span>set-selection!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-shape"><div class="inner"><span>shape</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-signum"><div class="inner"><span>signum</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-signum.21"><div class="inner"><span>signum!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-sin"><div class="inner"><span>sin</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-sin.21"><div class="inner"><span>sin!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-sinh"><div class="inner"><span>sinh</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-sinh.21"><div class="inner"><span>sinh!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-slice"><div class="inner"><span>slice</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-slice-count"><div class="inner"><span>slice-count</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-slice-views"><div class="inner"><span>slice-views</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-slices"><div class="inner"><span>slices</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-sparse"><div class="inner"><span>sparse</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-sparse-array"><div class="inner"><span>sparse-array</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-sparse-matrix"><div class="inner"><span>sparse-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-sparse.3F"><div class="inner"><span>sparse?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-sqrt"><div class="inner"><span>sqrt</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-sqrt.21"><div class="inner"><span>sqrt!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-square"><div class="inner"><span>square</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-square.3F"><div class="inner"><span>square?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-sub"><div class="inner"><span>sub</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-sub.21"><div class="inner"><span>sub!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-submatrix"><div class="inner"><span>submatrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-subvector"><div class="inner"><span>subvector</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-supports-dimensionality.3F"><div class="inner"><span>supports-dimensionality?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-supports-shape.3F"><div class="inner"><span>supports-shape?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-swap-rows"><div class="inner"><span>swap-rows</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-symmetric.3F"><div class="inner"><span>symmetric?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-tan"><div class="inner"><span>tan</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-tan.21"><div class="inner"><span>tan!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-tanh"><div class="inner"><span>tanh</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-tanh.21"><div class="inner"><span>tanh!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-to-degrees"><div class="inner"><span>to-degrees</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-to-degrees.21"><div class="inner"><span>to-degrees!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-to-double-array"><div class="inner"><span>to-double-array</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-to-nested-vectors"><div class="inner"><span>to-nested-vectors</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-to-object-array"><div class="inner"><span>to-object-array</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-to-radians"><div class="inner"><span>to-radians</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-to-radians.21"><div class="inner"><span>to-radians!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-to-vector"><div class="inner"><span>to-vector</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-trace"><div class="inner"><span>trace</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-transform"><div class="inner"><span>transform</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-transform.21"><div class="inner"><span>transform!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-transpose"><div class="inner"><span>transpose</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-transpose.21"><div class="inner"><span>transpose!</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-upper-triangular.3F"><div class="inner"><span>upper-triangular?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-vec.3F"><div class="inner"><span>vec?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-with-implementation"><div class="inner"><span>with-implementation</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-zero-array"><div class="inner"><span>zero-array</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-zero-count"><div class="inner"><span>zero-count</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-zero-dimensional.3F"><div class="inner"><span>zero-dimensional?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-zero-matrix"><div class="inner"><span>zero-matrix</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-zero-matrix.3F"><div class="inner"><span>zero-matrix?</span></div></a></li><li class="depth-1"><a href="clojure.core.matrix.html#var-zero-vector"><div class="inner"><span>zero-vector</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">clojure.core.matrix</h2><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-abs"><h3>abs</h3><div class="usage"><code>(abs m)</code></div><div class="doc"><pre class="plaintext">Computes the abs function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-abs.21"><h3>abs!</h3><div class="usage"><code>(abs! m)</code></div><div class="doc"><pre class="plaintext">Computes the abs function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-acos"><h3>acos</h3><div class="usage"><code>(acos m)</code></div><div class="doc"><pre class="plaintext">Computes the acos function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-acos.21"><h3>acos!</h3><div class="usage"><code>(acos! m)</code></div><div class="doc"><pre class="plaintext">Computes the acos function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-add"><h3>add</h3><div class="usage"><code>(add)</code><code>(add a)</code><code>(add a b)</code><code>(add a b &amp; more)</code></div><div class="doc"><pre class="plaintext">Performs element-wise addition on one or more numerical arrays.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1188">view source</a></div></div><div class="public anchor" id="var-add.21"><h3>add!</h3><div class="usage"><code>(add! a)</code><code>(add! a b)</code><code>(add! a b &amp; more)</code></div><div class="doc"><pre class="plaintext">Performs element-wise mutable addition on one or more numerical arrays.
Returns the first array after it has been mutated.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1244">view source</a></div></div><div class="public anchor" id="var-add-product"><h3>add-product</h3><div class="usage"><code>(add-product m a b)</code></div><div class="doc"><pre class="plaintext">Adds the element-wise product of two numerical arrays to the first array.
Arrays must be the same shape.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1197">view source</a></div></div><div class="public anchor" id="var-add-product.21"><h3>add-product!</h3><div class="usage"><code>(add-product! m a b)</code></div><div class="doc"><pre class="plaintext">Adds the product of two numerical arrays to the first array. Returns the mutated array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1203">view source</a></div></div><div class="public anchor" id="var-add-row"><h3>add-row</h3><div class="usage"><code>(add-row m i j)</code><code>(add-row m i j factor)</code></div><div class="doc"><pre class="plaintext">Add a row j (optionally multiplied by a scalar factor) to a row i
and replace row i with the result</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1446">view source</a></div></div><div class="public anchor" id="var-add-scaled"><h3>add-scaled</h3><div class="usage"><code>(add-scaled m a factor)</code></div><div class="doc"><pre class="plaintext">Adds a numerical array scaled by a given factor to the first array
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1209">view source</a></div></div><div class="public anchor" id="var-add-scaled.21"><h3>add-scaled!</h3><div class="usage"><code>(add-scaled! m a factor)</code></div><div class="doc"><pre class="plaintext">Adds a numerical array scaled by a given factor to the first array. Returns the mutated array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1214">view source</a></div></div><div class="public anchor" id="var-add-scaled-product"><h3>add-scaled-product</h3><div class="usage"><code>(add-scaled-product m a b factor)</code></div><div class="doc"><pre class="plaintext">Adds the product of two numerical arrays scaled by a given factor to the first array.

This is equivalent to (add m (mul a b factor)) but may be optimised by the underlying implementation.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1220">view source</a></div></div><div class="public anchor" id="var-add-scaled-product.21"><h3>add-scaled-product!</h3><div class="usage"><code>(add-scaled-product! m a b factor)</code></div><div class="doc"><pre class="plaintext">Adds the product of two numerical arrays scaled by a given factor to the first array.
Returns the mutated array.
This is equivalent to (add! m (mul a b factor)) but may be optimised by the underlying implementation.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1227">view source</a></div></div><div class="public anchor" id="var-array"><h3>array</h3><div class="usage"><code>(array data)</code><code>(array implementation data)</code></div><div class="doc"><pre class="plaintext">Constructs a new n-dimensional array from the given data.

The data may be in one of the following forms:
- A valid existing array
- Nested sequences of scalar values, e.g. Clojure vectors (must have regular shape)
- A sequence of slices, each of which must be valid array data

If implementation is not specified, uses the current matrix library as specified
in *matrix-implementation*

If the implementation does not support the shape of data provided, may either
create an array using a different implementation on a best-efforts basis or
alternatively throw an error. Users should not rely on this behaviour.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L61">view source</a></div></div><div class="public anchor" id="var-array.3F"><h3>array?</h3><div class="usage"><code>(array? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the parameter is an N-dimensional array, for any N&gt;=0
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L428">view source</a></div></div><div class="public anchor" id="var-as-vector"><h3>as-vector</h3><div class="usage"><code>(as-vector m)</code></div><div class="doc"><pre class="plaintext">Creates a view of an array as a single flattened vector.

Returns nil if this is not supported by the implementation. You should use `to-vector` instead to
obtain a flattened vector without guaranteeing a view.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L966">view source</a></div></div><div class="public anchor" id="var-asin"><h3>asin</h3><div class="usage"><code>(asin m)</code></div><div class="doc"><pre class="plaintext">Computes the asin function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-asin.21"><h3>asin!</h3><div class="usage"><code>(asin! m)</code></div><div class="doc"><pre class="plaintext">Computes the asin function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-assign"><h3>assign</h3><div class="usage"><code>(assign m a)</code></div><div class="doc"><pre class="plaintext">Assigns array a element-wise, broadcasting to fill the whole shape of m.
Returns a new matrix, of the same shape as the original m.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L388">view source</a></div></div><div class="public anchor" id="var-assign.21"><h3>assign!</h3><div class="usage"><code>(assign! m a)</code></div><div class="doc"><pre class="plaintext">Assigns a new value to an array. Sets the values of the target element-wise, broadcasting where necessary.
Returns the mutated array. The new value may be either a scalar or a array of compatible (maybe smaller) shape.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L374">view source</a></div></div><div class="public anchor" id="var-assign-array.21"><h3>assign-array!</h3><div class="usage"><code>(assign-array! m a)</code></div><div class="doc"><pre class="plaintext">Assigns values to a core.matrix array from a Java array.
Returns the mutated core.matrix array</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L381">view source</a></div></div><div class="public anchor" id="var-atan"><h3>atan</h3><div class="usage"><code>(atan m)</code></div><div class="doc"><pre class="plaintext">Computes the atan function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-atan.21"><h3>atan!</h3><div class="usage"><code>(atan! m)</code></div><div class="doc"><pre class="plaintext">Computes the atan function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-block-diagonal-matrix"><h3>block-diagonal-matrix</h3><div class="usage"><code>(block-diagonal-matrix blocks)</code><code>(block-diagonal-matrix implementation blocks)</code></div><div class="doc"><pre class="plaintext">Constructs a block diagonal matrix for a given vector of 2D square matrices and arranges
the matrices along the main diagonal of the 2D matrix</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L224">view source</a></div></div><div class="public anchor" id="var-broadcast"><h3>broadcast</h3><div class="usage"><code>(broadcast m shape)</code></div><div class="doc"><pre class="plaintext">Broadcasts a matrix to a specified shape. Returns a new matrix with the shape specified.
The broadcasted matrix may be a view over the original matrix: attempting to modify the
broadcasted matrix therefore has undefined results.
Will throw an exception if broadcast to the target shape is not possible.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L984">view source</a></div></div><div class="public anchor" id="var-broadcast-coerce"><h3>broadcast-coerce</h3><div class="usage"><code>(broadcast-coerce m a)</code></div><div class="doc"><pre class="plaintext">Broadcasts and coerces the second matrix to the shape and type of the first.
Equivalent to (coerce m (broadcast-like m a)).</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L999">view source</a></div></div><div class="public anchor" id="var-broadcast-like"><h3>broadcast-like</h3><div class="usage"><code>(broadcast-like m a)</code></div><div class="doc"><pre class="plaintext">Broadcasts the second matrix to the shape of the first. See &apos;broadcast&apos;.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L993">view source</a></div></div><div class="public anchor" id="var-cbrt"><h3>cbrt</h3><div class="usage"><code>(cbrt m)</code></div><div class="doc"><pre class="plaintext">Computes the cbrt function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-cbrt.21"><h3>cbrt!</h3><div class="usage"><code>(cbrt! m)</code></div><div class="doc"><pre class="plaintext">Computes the cbrt function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-ceil"><h3>ceil</h3><div class="usage"><code>(ceil m)</code></div><div class="doc"><pre class="plaintext">Computes the ceil function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-ceil.21"><h3>ceil!</h3><div class="usage"><code>(ceil! m)</code></div><div class="doc"><pre class="plaintext">Computes the ceil function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-clone"><h3>clone</h3><div class="usage"><code>(clone m)</code></div><div class="doc"><pre class="plaintext">Constructs a (shallow) clone of the array. This function is intended to
allow safe defensive usage of matrices / vectors. If the intent is to create a mutable clone of
some array data, it is recommended to use mutable instead.

Guarantees that:
1. Mutating the returned array will not modify any other array (defensive copy)
2. The returned array will be fully mutable, if the implementation supports mutable matrices.

The clone may or may not be of the same implementation: implementations are encouraged to do so but
this is not mandatory.

A core.matrix implementation which only provides immutable arrays may safely return the same array.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L394">view source</a></div></div><div class="public anchor" id="var-coerce"><h3>coerce</h3><div class="usage"><code>(coerce param)</code><code>(coerce matrix-or-implementation param)</code></div><div class="doc"><pre class="plaintext">Coerces param (which may be any array) into a format preferred by a specific matrix implementation.
If the matrix implementation is not specified, uses the current matrix implementation.
If param is already in a format deemed usable by the implementation, may return it unchanged.

coerce should never alter the shape of the array, but may convert element types where necessary
(e.g. turning real values into complex values when converting to a complex array type).</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L823">view source</a></div></div><div class="public anchor" id="var-column-count"><h3>column-count</h3><div class="usage"><code>(column-count m)</code></div><div class="doc"><pre class="plaintext">Returns the number of columns in a matrix (array must be 2D or more)
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L521">view source</a></div></div><div class="public anchor" id="var-column-matrix"><h3>column-matrix</h3><div class="usage"><code>(column-matrix data)</code><code>(column-matrix implementation data)</code></div><div class="doc"><pre class="plaintext">Constructs a column matrix with the given data. The returned matrix is a 2D Nx1 column matrix.

The data must be either a valid existing vector or a sequence of scalar values.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L195">view source</a></div></div><div class="public anchor" id="var-column-matrix.3F"><h3>column-matrix?</h3><div class="usage"><code>(column-matrix? m)</code></div><div class="doc"><pre class="plaintext">Returns true if a matrix is a column-matrix (i.e. is 2D and has has exactly one column)
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L554">view source</a></div></div><div class="public anchor" id="var-columns"><h3>columns</h3><div class="usage"><code>(columns m)</code></div><div class="doc"><pre class="plaintext">Gets the columns of a matrix, as a sequence of 1D vectors.

If the array has more than 2 dimensions, will return the columns from all slices in order.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L907">view source</a></div></div><div class="public anchor" id="var-compute-matrix"><h3>compute-matrix</h3><div class="usage"><code>(compute-matrix shape f)</code><code>(compute-matrix implementation shape f)</code></div><div class="doc"><pre class="plaintext">Creates a matrix with the specified shape, and each element specified by (f i j k...)
Where i, j, k... are the index positions of each element in the matrix</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L289">view source</a></div></div><div class="public anchor" id="var-conforming.3F"><h3>conforming?</h3><div class="usage"><code>(conforming? a)</code><code>(conforming? a b)</code></div><div class="doc"><pre class="plaintext">Returns true if two arrays have a conforming shape. Two arrays are conforming if there
exists a common shape that both can broadcast to. This is a requirement for element-wise
operations to work correctly on two different-shaped arrays.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L602">view source</a></div></div><div class="public anchor" id="var-cos"><h3>cos</h3><div class="usage"><code>(cos m)</code></div><div class="doc"><pre class="plaintext">Computes the cos function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-cos.21"><h3>cos!</h3><div class="usage"><code>(cos! m)</code></div><div class="doc"><pre class="plaintext">Computes the cos function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-cosh"><h3>cosh</h3><div class="usage"><code>(cosh m)</code></div><div class="doc"><pre class="plaintext">Computes the cosh function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-cosh.21"><h3>cosh!</h3><div class="usage"><code>(cosh! m)</code></div><div class="doc"><pre class="plaintext">Computes the cosh function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-cross"><h3>cross</h3><div class="usage"><code>(cross a b)</code></div><div class="doc"><pre class="plaintext">Computes the 3D cross-product of two numerical vectors.

Behavior on other types is undefined.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1338">view source</a></div></div><div class="public anchor" id="var-cross.21"><h3>cross!</h3><div class="usage"><code>(cross! a b)</code></div><div class="doc"><pre class="plaintext">Computes the cross-product of two numerical 3D vectors, storing the result in the first vector.
Returns the (mutated) first vector.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1345">view source</a></div></div><div class="public anchor" id="var-current-implementation"><h3>current-implementation</h3><div class="usage"><code>(current-implementation)</code></div><div class="doc"><pre class="plaintext">Gets the currently active matrix implementation (as a keyword)
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1617">view source</a></div></div><div class="public anchor" id="var-current-implementation-object"><h3>current-implementation-object</h3><div class="usage"><code>(current-implementation-object)</code></div><div class="doc"><pre class="plaintext">Gets a canonical object for the currently active matrix implementation. This object
can be used to pass as an implementation parameter, or to query implementation internals via core.matrix protocols.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1640">view source</a></div></div><div class="public anchor" id="var-dense"><h3>dense</h3><div class="usage"><code>(dense data)</code><code>(dense implementation data)</code></div><div class="doc"><pre class="plaintext">Coerces an array to a dense format if possible. Dense arrays are expected to
allocate contiguous storage space for all elements.

&apos;dense&apos; should not be used with very large arrays, and may throw an OutOfMemoryError
 if the dense array is too large to fit in available memory.

Returns the array unchanged if such coercion is not possible, or if the array is already dense.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L332">view source</a></div></div><div class="public anchor" id="var-density"><h3>density</h3><div class="usage"><code>(density m)</code></div><div class="doc"><pre class="plaintext">Returns the density of the matrix, defined as the proportion of non-zero elements
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L581">view source</a></div></div><div class="public anchor" id="var-det"><h3>det</h3><div class="usage"><code>(det a)</code></div><div class="doc"><pre class="plaintext">Calculates the determinant of a 2D square numerical matrix.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1358">view source</a></div></div><div class="public anchor" id="var-diagonal"><h3>diagonal</h3><div class="usage"><code>(diagonal m)</code><code>(diagonal m k)</code></div><div class="doc"><pre class="plaintext">Returns the specified diagonal of a 2D matrix as a vector.
If k&gt;0, returns a diagonal above the main diagonal.
If k&lt;0, returns a diagonal below the main diagonal.
Works on both square and rectangular matrices.
Returns empty vector if value of k is out of range (outside matrix)</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L922">view source</a></div></div><div class="public anchor" id="var-diagonal-matrix"><h3>diagonal-matrix</h3><div class="usage"><code>(diagonal-matrix diagonal-values)</code><code>(diagonal-matrix implementation diagonal-values)</code></div><div class="doc"><pre class="plaintext">Constructs a 2D diagonal matrix with the given numerical values on the main diagonal.
 All off-diagonal elements will be zero, and diagonal-values may be a vector or any
Clojure sequence of values.

 Diagonal matrices constructed this way may use specialised storage formats, hence may not be fully mutable.
 Use (mutable (diagonal-matrix ...)) if you need to guarantee a mutable matrix.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L277">view source</a></div></div><div class="public anchor" id="var-diagonal.3F"><h3>diagonal?</h3><div class="usage"><code>(diagonal? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the parameter is a diagonal matrix
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L471">view source</a></div></div><div class="public anchor" id="var-dimension-count"><h3>dimension-count</h3><div class="usage"><code>(dimension-count m dim)</code></div><div class="doc"><pre class="plaintext">Returns the size of the specified dimension in a matrix. Will throw an error if the matrix
does not have the specified dimension.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L527">view source</a></div></div><div class="public anchor" id="var-dimensionality"><h3>dimensionality</h3><div class="usage"><code>(dimensionality m)</code></div><div class="doc"><pre class="plaintext">Returns the dimensionality of an array. The dimensionality is equal to
the number of dimensions in the array&apos;s shape.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L508">view source</a></div></div><div class="public anchor" id="var-distance"><h3>distance</h3><div class="usage"><code>(distance a b)</code></div><div class="doc"><pre class="plaintext">Calculates the euclidean distance between two numerical vectors.
This is equivalent to (norm 2 (sub a b)) but may be optimised by the underlying implementation.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1352">view source</a></div></div><div class="public anchor" id="var-div"><h3>div</h3><div class="usage"><code>(div a)</code><code>(div a b)</code><code>(div a b &amp; more)</code></div><div class="doc"><pre class="plaintext">Performs element-wise matrix division for numerical arrays.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1127">view source</a></div></div><div class="public anchor" id="var-div.21"><h3>div!</h3><div class="usage"><code>(div! a)</code><code>(div! a b)</code><code>(div! a b &amp; more)</code></div><div class="doc"><pre class="plaintext">Performs in-place element-wise matrix division for numerical arrays.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1133">view source</a></div></div><div class="public anchor" id="var-dot"><h3>dot</h3><div class="usage"><code>(dot a b)</code></div><div class="doc"><pre class="plaintext">Computes the dot product (1Dx1D inner product) of two numerical vectors.
If either argument is not a vector, computes a higher dimensional inner product.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1304">view source</a></div></div><div class="public anchor" id="var-e*"><h3>e*</h3><div class="usage"><code>(e*)</code><code>(e* a)</code><code>(e* a b)</code><code>(e* a b &amp; more)</code></div><div class="doc"><pre class="plaintext">An element-wise multiply operator equivalent to emul.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1118">view source</a></div></div><div class="public anchor" id="var-e.3D"><h3>e=</h3><div class="usage"><code>(e= m1)</code><code>(e= m1 m2)</code><code>(e= m1 m2 &amp; more)</code></div><div class="doc"><pre class="plaintext">Returns true if all array elements are equal (using the semantics of clojure.core/=).
WARNING: a java.lang.Long does not equal a java.lang.Double.
Use &apos;equals&apos; or &apos;e==&apos; instead if you want numerical equality.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1554">view source</a></div></div><div class="public anchor" id="var-e.3D.3D"><h3>e==</h3><div class="usage"><code>(e== m1)</code><code>(e== m1 m2)</code><code>(e== m1 m2 &amp; more)</code></div><div class="doc"><pre class="plaintext">Returns true if all array elements are numerically equal. Throws an error if any elements
of the arrays being compared are not numerical values.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1567">view source</a></div></div><div class="public anchor" id="var-ecount"><h3>ecount</h3><div class="usage"><code>(ecount m)</code></div><div class="doc"><pre class="plaintext">Returns the total count of elements in an array.

Equal to the product of the lengths of each dimension in the array&apos;s shape.

Returns 1 for a zero-dimensional array or scalar.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1500">view source</a></div></div><div class="public anchor" id="var-element-type"><h3>element-type</h3><div class="usage"><code>(element-type m)</code></div><div class="doc"><pre class="plaintext">Returns the class of elements that can be in the array. For example, a numerical array may return
the class java.lang.Double.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L502">view source</a></div></div><div class="public anchor" id="var-emap"><h3>emap</h3><div class="usage"><code>(emap f m)</code><code>(emap f m a)</code><code>(emap f m a &amp; more)</code></div><div class="doc"><pre class="plaintext">Element-wise map over all elements of one or more arrays.

f must return a result compatible with the element-type of the array m

Returns a new array of the same element-type and shape as the array m.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1521">view source</a></div></div><div class="public anchor" id="var-emap.21"><h3>emap!</h3><div class="usage"><code>(emap! f m)</code><code>(emap! f m a)</code><code>(emap! f m a &amp; more)</code></div><div class="doc"><pre class="plaintext">Element-wise map of a function f over all elements of one or more arrays.

f must return a result compatible with the element-type of the array m

Performs in-place modification of the first array argument.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1577">view source</a></div></div><div class="public anchor" id="var-emax"><h3>emax</h3><div class="usage"><code>(emax m)</code></div><div class="doc"><pre class="plaintext">Gets the maximum element value from a numerical array
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1549">view source</a></div></div><div class="public anchor" id="var-emin"><h3>emin</h3><div class="usage"><code>(emin m)</code></div><div class="doc"><pre class="plaintext">Gets the minimum element value from a numerical array
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1544">view source</a></div></div><div class="public anchor" id="var-emul"><h3>emul</h3><div class="usage"><code>(emul)</code><code>(emul a)</code><code>(emul a b)</code><code>(emul a b &amp; more)</code></div><div class="doc"><pre class="plaintext">Performs element-wise multiplication.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1096">view source</a></div></div><div class="public anchor" id="var-emul.21"><h3>emul!</h3><div class="usage"><code>(emul! a)</code><code>(emul! a b)</code><code>(emul! a b &amp; more)</code></div><div class="doc"><pre class="plaintext">Performs in-place element-wise multiplication of numerical arrays.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1159">view source</a></div></div><div class="public anchor" id="var-ensure-mutable"><h3>ensure-mutable</h3><div class="usage"><code>(ensure-mutable m)</code></div><div class="doc"><pre class="plaintext">Checks if an array is mutable, and if not converts to a new mutable array. Guarantees
that the result will be mutable, but may not be the same type as the original array.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L269">view source</a></div></div><div class="public anchor" id="var-equals"><h3>equals</h3><div class="usage"><code>(equals a b)</code><code>(equals a b epsilon)</code></div><div class="doc"><pre class="plaintext">Returns true if two arrays are numerically equal.

Will return false for arrays of different shapes.

May either return false or throw an error if the arrays are not numerical.

If epsilon is provided, performs an equality test
with the given maximum tolerance (default is 0.0, i.e. exact numerical equivalence)</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1051">view source</a></div></div><div class="public anchor" id="var-ereduce"><h3>ereduce</h3><div class="usage"><code>(ereduce f m)</code><code>(ereduce f init m)</code></div><div class="doc"><pre class="plaintext">Element-wise reduce on all elements of an array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1514">view source</a></div></div><div class="public anchor" id="var-eseq"><h3>eseq</h3><div class="usage"><code>(eseq m)</code></div><div class="doc"><pre class="plaintext">Returns all elements of an array as a sequence in row-major order
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1509">view source</a></div></div><div class="public anchor" id="var-esum"><h3>esum</h3><div class="usage"><code>(esum m)</code></div><div class="doc"><pre class="plaintext">Calculates the sum of all the elements in a numerical array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1539">view source</a></div></div><div class="public anchor" id="var-exp"><h3>exp</h3><div class="usage"><code>(exp m)</code></div><div class="doc"><pre class="plaintext">Computes the exp function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-exp.21"><h3>exp!</h3><div class="usage"><code>(exp! m)</code></div><div class="doc"><pre class="plaintext">Computes the exp function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-fill"><h3>fill</h3><div class="usage"><code>(fill m value)</code></div><div class="doc"><pre class="plaintext">Fills a matrix with a single scalar value. The scalar value must be compatible with the element-type
of the array. Returns a new array.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1042">view source</a></div></div><div class="public anchor" id="var-fill.21"><h3>fill!</h3><div class="usage"><code>(fill! m value)</code></div><div class="doc"><pre class="plaintext">Fills a matrix with a single scalar value. The scalar value must be compatible with the element-type
of the array.

Equivalent to assign!, but may be more efficient for scalar values.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1033">view source</a></div></div><div class="public anchor" id="var-floor"><h3>floor</h3><div class="usage"><code>(floor m)</code></div><div class="doc"><pre class="plaintext">Computes the floor function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-floor.21"><h3>floor!</h3><div class="usage"><code>(floor! m)</code></div><div class="doc"><pre class="plaintext">Computes the floor function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-get-column"><h3>get-column</h3><div class="usage"><code>(get-column m y)</code></div><div class="doc"><pre class="plaintext">Gets a column of a matrix, as a vector.
Will return a mutable view if supported by the implementation.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L734">view source</a></div></div><div class="public anchor" id="var-get-row"><h3>get-row</h3><div class="usage"><code>(get-row m x)</code></div><div class="doc"><pre class="plaintext">Gets a row of a matrix, as a vector.
Will return a mutable view if supported by the implementation.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L728">view source</a></div></div><div class="public anchor" id="var-identity-matrix"><h3>identity-matrix</h3><div class="usage"><code>(identity-matrix dims)</code><code>(identity-matrix implementation dims)</code></div><div class="doc"><pre class="plaintext">Constructs a 2D identity matrix with the given number of rows.

Identity matrices constructed with this function may not be fully mutable because they may be
implemented with a specialised identity matrix type. Use (mutable (identity-matrix ...)) if you
need to guarantee a mutable matrix.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L204">view source</a></div></div><div class="public anchor" id="var-identity-matrix.3F"><h3>identity-matrix?</h3><div class="usage"><code>(identity-matrix? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the parameter is an identity-matrix
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L456">view source</a></div></div><div class="public anchor" id="var-immutable"><h3>immutable</h3><div class="usage"><code>(immutable data)</code><code>(immutable data type)</code></div><div class="doc"><pre class="plaintext">Returns an immutable array containing the given array data.

May return the same array if it is already immutable.

If the implementation does not support immutable matrices, will return an immutable array
from another core.matrix implementation that supports either the same element type or a broader type.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L246">view source</a></div></div><div class="public anchor" id="var-index"><h3>index</h3><div class="usage"><code>(index data)</code><code>(index implementation data)</code></div><div class="doc"><pre class="plaintext">Constructs a new index from given data.

The data may be in one of the following forms:
- A valid existing index
- A 1D array of integer values
- A sequence of integer values

If implementation is not specified, uses the current matrix library as specified
in *matrix-implementation*

If the implementation does not support its own native index types, will return a
valid index from a default implementation.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L84">view source</a></div></div><div class="public anchor" id="var-index-seq"><h3>index-seq</h3><div class="usage"><code>(index-seq m)</code></div><div class="doc"><pre class="plaintext">Returns a sequence of all possible index vectors into a matrix, in row-major order
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1595">view source</a></div></div><div class="public anchor" id="var-index-seq-for-shape"><h3>index-seq-for-shape</h3><div class="usage"><code>(index-seq-for-shape sh)</code></div><div class="doc"><pre class="plaintext">Returns a sequence of all possible index vectors for a given shape, in row-major order
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1590">view source</a></div></div><div class="public anchor" id="var-index.3F"><h3>index?</h3><div class="usage"><code>(index? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the parameter is a valid array index type. An index is a seq-able 1D list
of integer values that can be used to index into arrays.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L596">view source</a></div></div><div class="public anchor" id="var-inner-product"><h3>inner-product</h3><div class="usage"><code>(inner-product)</code><code>(inner-product a)</code><code>(inner-product a b)</code><code>(inner-product a b &amp; more)</code></div><div class="doc"><pre class="plaintext">Computes the inner product of numerical arrays.

For matrix/matrix and matrix/vector arguments, this is equivalent to matrix multiplication.

The inner product of two arrays with indexed dimensions {..i j} and {j k..} has dimensions {..i k..}. The inner-product of two vectors will be scalar.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1312">view source</a></div></div><div class="public anchor" id="var-inverse"><h3>inverse</h3><div class="usage"><code>(inverse m)</code></div><div class="doc"><pre class="plaintext">Calculates the inverse of a 2D numerical matrix.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1363">view source</a></div></div><div class="public anchor" id="var-join"><h3>join</h3><div class="usage"><code>(join &amp; arrays)</code></div><div class="doc"><pre class="plaintext">Joins arrays together, along dimension 0. Other dimensions must be compatible
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L939">view source</a></div></div><div class="public anchor" id="var-join-along"><h3>join-along</h3><div class="usage"><code>(join-along dimension &amp; arrays)</code></div><div class="doc"><pre class="plaintext">Joins arrays together, along a specified dimension. Other dimensions must be compatible.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L944">view source</a></div></div><div class="public anchor" id="var-label"><h3>label</h3><div class="usage"><code>(label m dim i)</code></div><div class="doc"><pre class="plaintext">Returns a label for the specified position along a given array dimension. Returns nil if the dimension is unlabelled.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1069">view source</a></div></div><div class="public anchor" id="var-labels"><h3>labels</h3><div class="usage"><code>(labels m dim)</code></div><div class="doc"><pre class="plaintext">Return a vector of labels for a given array dimension. Return nil if the dimension is unlabelled.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1074">view source</a></div></div><div class="public anchor" id="var-length"><h3>length</h3><div class="usage"><code>(length m)</code></div><div class="doc"><pre class="plaintext">Calculates the euclidean length (magnitude) of a numerical vector
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1388">view source</a></div></div><div class="public anchor" id="var-length-squared"><h3>length-squared</h3><div class="usage"><code>(length-squared m)</code></div><div class="doc"><pre class="plaintext">Calculates the squared length (squared magnitude) of a numerical vector
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1393">view source</a></div></div><div class="public anchor" id="var-log"><h3>log</h3><div class="usage"><code>(log m)</code></div><div class="doc"><pre class="plaintext">Computes the log function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-log.21"><h3>log!</h3><div class="usage"><code>(log! m)</code></div><div class="doc"><pre class="plaintext">Computes the log function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-log10"><h3>log10</h3><div class="usage"><code>(log10 m)</code></div><div class="doc"><pre class="plaintext">Computes the log10 function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-log10.21"><h3>log10!</h3><div class="usage"><code>(log10! m)</code></div><div class="doc"><pre class="plaintext">Computes the log10 function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-lower-triangular.3F"><h3>lower-triangular?</h3><div class="usage"><code>(lower-triangular? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the parameter is a lower triangular matrix
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L481">view source</a></div></div><div class="public anchor" id="var-main-diagonal"><h3>main-diagonal</h3><div class="usage"><code>(main-diagonal m)</code></div><div class="doc"><pre class="plaintext">Returns the main diagonal of a matrix or general array, as a vector.
The main diagonal of a general array is defined as those elements where the all the
indexes are equal, i.e. the index is of the form [i i ... i]
Works on both square and rectangular matrices.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L914">view source</a></div></div><div class="public anchor" id="var-matrix"><h3>matrix</h3><div class="usage"><code>(matrix data)</code><code>(matrix implementation data)</code></div><div class="doc"><pre class="plaintext">Constructs a new n-dimensional matrix from the given numerical data.

The data may be in one of the following forms:
- A valid existing numerical array
- Nested sequences of scalar values, e.g. Clojure vectors
- A sequence of slices, each of which must be valid matrix data

If implementation is not specified, uses the current matrix library as specified
in *matrix-implementation*</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L42">view source</a></div></div><div class="public anchor" id="var-matrix.3F"><h3>matrix?</h3><div class="usage"><code>(matrix? m)</code></div><div class="doc"><pre class="plaintext">Returns true if parameter is a valid matrix (i.e. an array with dimensionality == 2)
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L434">view source</a></div></div><div class="public anchor" id="var-mget"><h3>mget</h3><div class="usage"><code>(mget m)</code><code>(mget m x)</code><code>(mget m x y)</code><code>(mget m x y &amp; more)</code></div><div class="doc"><pre class="plaintext">Gets a scalar value from an array at the specified position. Supports any number of dimensions.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L675">view source</a></div></div><div class="public anchor" id="var-mmul"><h3>mmul</h3><div class="usage"><code>(mmul)</code><code>(mmul a)</code><code>(mmul a b)</code><code>(mmul a b &amp; more)</code></div><div class="doc"><pre class="plaintext">Performs matrix multiplication on matrices or vectors.  Equivalent to
inner-product when applied to vectors.  Will treat a 1D vector roughly as a
1xN matrix (row vector) when it&apos;s the first argument, or as an Nx1 matrix
(column vector) when it&apos;s the second argument--except that the dimensionality
of the result will be different from what it would be with matrix arguments.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1105">view source</a></div></div><div class="public anchor" id="var-mset"><h3>mset</h3><div class="usage"><code>(mset m v)</code><code>(mset m x v)</code><code>(mset m x y v)</code><code>(mset m x y z &amp; more)</code></div><div class="doc"><pre class="plaintext">Sets a scalar value in an array at the specified position, returning a new matrix and leaving the
original unchanged.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L691">view source</a></div></div><div class="public anchor" id="var-mset.21"><h3>mset!</h3><div class="usage"><code>(mset! m v)</code><code>(mset! m x v)</code><code>(mset! m x y v)</code><code>(mset! m x y z &amp; more)</code></div><div class="doc"><pre class="plaintext">Sets a scalar value in an array at the specified position. Supports any number of dimensions.

Will throw an exception if the matrix is not mutable at the specified position. Note that it
is possible for some arrays to be mutable in places and immutable in others (e.g. sparse arrays)

Returns the modified matrix (it is guaranteed to return the same instance)</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L703">view source</a></div></div><div class="public anchor" id="var-mul"><h3>mul</h3><div class="usage"><code>(mul)</code><code>(mul a)</code><code>(mul a b)</code><code>(mul a b &amp; more)</code></div><div class="doc"><pre class="plaintext">Performs element-wise multiplication with scalars and numerical arrays.

Behaves like clojure.core/* for scalar values.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1082">view source</a></div></div><div class="public anchor" id="var-mul.21"><h3>mul!</h3><div class="usage"><code>(mul! a)</code><code>(mul! a b)</code><code>(mul! a b &amp; more)</code></div><div class="doc"><pre class="plaintext">Performs in-place element-wise multiplication of numerical arrays.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1147">view source</a></div></div><div class="public anchor" id="var-multiply-row"><h3>multiply-row</h3><div class="usage"><code>(multiply-row m i factor)</code></div><div class="doc"><pre class="plaintext">Multiply row i by a constant factor
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1441">view source</a></div></div><div class="public anchor" id="var-mutable"><h3>mutable</h3><div class="usage"><code>(mutable data)</code><code>(mutable data type)</code></div><div class="doc"><pre class="plaintext">Constructs a fully mutable copy of the given array data.

If the implementation does not support mutable matrices, will return a mutable array
from another core.matrix implementation that supports either the same element type or a broader type.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L232">view source</a></div></div><div class="public anchor" id="var-mutable-matrix"><h3>mutable-matrix</h3><h4 class="deprecated">deprecated</h4><div class="usage"><code>(mutable-matrix data)</code><code>(mutable-matrix data type)</code></div><div class="doc"><pre class="plaintext">Constructs a mutable copy of the given matrix.

DEPRECATED: please use mutable instead</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L260">view source</a></div></div><div class="public anchor" id="var-mutable.3F"><h3>mutable?</h3><div class="usage"><code>(mutable? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the matrix is mutable, i.e. supports setting of values.

It is possible for some matrix implementations to have constraints on mutability (e.g. mutable only in diagonal elements),
this method will still return true for such cases.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L588">view source</a></div></div><div class="public anchor" id="var-negate"><h3>negate</h3><div class="usage"><code>(negate m)</code></div><div class="doc"><pre class="plaintext">Calculates the negation of a numerical array.
Generally equivalent to (scale m -1.0)</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1369">view source</a></div></div><div class="public anchor" id="var-negate.21"><h3>negate!</h3><div class="usage"><code>(negate! m)</code></div><div class="doc"><pre class="plaintext">Calculates the negation of a numerical array in place. Equivalent to scaling by -1.0
Generally equivalent to (scale! m -1.0)</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1375">view source</a></div></div><div class="public anchor" id="var-new-array"><h3>new-array</h3><div class="usage"><code>(new-array shape)</code><code>(new-array implementation shape)</code></div><div class="doc"><pre class="plaintext">Creates a new array with the given shape.
New array will contain default values as defined by the implementation (usually null or zero).
If the implementation supports mutable matrices, then the new matrix will be fully mutable.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L149">view source</a></div></div><div class="public anchor" id="var-new-matrix"><h3>new-matrix</h3><div class="usage"><code>(new-matrix rows columns)</code><code>(new-matrix implementation rows columns)</code></div><div class="doc"><pre class="plaintext">Constructs a new 2D array (matrix) with the given dimensions.
The new matrix will contain default values as defined by the implementation (usually null or zero).
If the implementation supports mutable matrices, then the new matrix will be fully mutable.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L133">view source</a></div></div><div class="public anchor" id="var-new-scalar-array"><h3>new-scalar-array</h3><div class="usage"><code>(new-scalar-array)</code><code>(new-scalar-array implementation)</code></div><div class="doc"><pre class="plaintext">Returns a new mutable scalar array containing the scalar value zero.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L171">view source</a></div></div><div class="public anchor" id="var-new-sparse-array"><h3>new-sparse-array</h3><div class="usage"><code>(new-sparse-array shape)</code><code>(new-sparse-array implementation shape)</code></div><div class="doc"><pre class="plaintext">Creates a new sparse array with the given shape.
New array will contain default values as defined by the implementation (usually zero).
If the implementation supports mutable matrices, then the new matrix will be fully mutable.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L160">view source</a></div></div><div class="public anchor" id="var-new-vector"><h3>new-vector</h3><div class="usage"><code>(new-vector length)</code><code>(new-vector implementation length)</code></div><div class="doc"><pre class="plaintext">Constructs a new vector with the given length.
New matrix will contain default values as defined by the implementation (usually null or zero).
If the implementation supports mutable vectors, then the new vector will be fully mutable.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L117">view source</a></div></div><div class="public anchor" id="var-non-zero-count"><h3>non-zero-count</h3><div class="usage"><code>(non-zero-count m)</code></div><div class="doc"><pre class="plaintext">Counts the number of non-zero values in a numerical array.
May perform a full array scan, but will often be quicker for specialised
sparse matrices - sometimes as fast as O(1)</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1480">view source</a></div></div><div class="public anchor" id="var-non-zero-indices"><h3>non-zero-indices</h3><div class="usage"><code>(non-zero-indices m)</code></div><div class="doc"><pre class="plaintext">Gets the non-zero indices of an array.
- For a 1D vector, returns an ordered index list.
- For a higher dimensional array, returns the non-zero-indices for each slice in row-major order.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1488">view source</a></div></div><div class="public anchor" id="var-normalise"><h3>normalise</h3><div class="usage"><code>(normalise v)</code></div><div class="doc"><pre class="plaintext">Normalises a numerical vector (scales to unit length).
Returns a new normalised vector.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1291">view source</a></div></div><div class="public anchor" id="var-normalise.21"><h3>normalise!</h3><div class="usage"><code>(normalise! v)</code></div><div class="doc"><pre class="plaintext">Normalises a numerical vector in-place (scales to unit length).
Returns the modified vector.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1297">view source</a></div></div><div class="public anchor" id="var-numerical.3F"><h3>numerical?</h3><div class="usage"><code>(numerical? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the matrix is a valid numerical matrix (i.e. supports numerical core.matrix operations).
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L627">view source</a></div></div><div class="public anchor" id="var-order"><h3>order</h3><div class="usage"><code>(order m indices)</code><code>(order m dimension indices)</code></div><div class="doc"><pre class="plaintext">Reorders slices of an array along a specified dimension. Re-orders along major dimension
if no dimension is specified.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L958">view source</a></div></div><div class="public anchor" id="var-orthogonal.3F"><h3>orthogonal?</h3><div class="usage"><code>(orthogonal? m eps)</code><code>(orthogonal? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the parameter is an orthogonal matrix
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L486">view source</a></div></div><div class="public anchor" id="var-outer-product"><h3>outer-product</h3><div class="usage"><code>(outer-product)</code><code>(outer-product a)</code><code>(outer-product a b)</code><code>(outer-product a b &amp; more)</code></div><div class="doc"><pre class="plaintext">Computes the outer product of numerical arrays.

The outer product of two arrays with indexed dimensions {i..j} and {j..k} has dimensions {i..j j..k}, i.e. the dimensioanlity will be the
sum of the dimensionalities of the two arguments.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1326">view source</a></div></div><div class="public anchor" id="var-pack"><h3>pack</h3><div class="usage"><code>(pack a)</code></div><div class="doc"><pre class="plaintext">Packs array data in the most efficient format as defined by the implementation. May return the
same array if no additional packing is required.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L666">view source</a></div></div><div class="public anchor" id="var-permutation-matrix"><h3>permutation-matrix</h3><div class="usage"><code>(permutation-matrix permutation)</code><code>(permutation-matrix implementation permutation)</code></div><div class="doc"><pre class="plaintext">Constructs a permutation matrix for a given permutation vector. The permutation vector should
contain a distinct set of integers 0...n-1, representing the re-ordering performed by
the permutation matrix.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L215">view source</a></div></div><div class="public anchor" id="var-pm"><h3>pm</h3><div class="usage"><code>(pm m)</code><code>(pm m opts)</code></div><div class="doc"><pre class="plaintext">Pretty-prints a matrix.

opts is a map of optional parameters which may include:

   :formatter - a function to format each array element</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1603">view source</a></div></div><div class="public anchor" id="var-pow"><h3>pow</h3><div class="usage"><code>(pow m)</code><code>(pow m exponent)</code><code>(pow m exponent &amp; more)</code></div><div class="doc"><pre class="plaintext">Raises every element of a numerical matrix by the given exponent.

Note that behaviour for large exponents may depend on the underlying implementation:
for example double-based matrices may overflow to Double/POSITIVE_INFINITY.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1398">view source</a></div></div><div class="public anchor" id="var-pow.21"><h3>pow!</h3><div class="usage"><code>(pow! m a)</code></div><div class="doc"><pre class="plaintext">Mutable exponent function, see &apos;pow&apos;
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1410">view source</a></div></div><div class="public anchor" id="var-reshape"><h3>reshape</h3><div class="usage"><code>(reshape m shape)</code></div><div class="doc"><pre class="plaintext">Changes the shape of a matrix to the specified new shape. shape can be any sequence of dimension sizes.

Preserves the row-major order of matrix elements. Truncates the sequence of elements if the shape is smaller
than the original shape.

Pads with default values (dependent on implementation - but normally zero) if the shape is larger.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1023">view source</a></div></div><div class="public anchor" id="var-rotate"><h3>rotate</h3><div class="usage"><code>(rotate m dimension shift-amount)</code><code>(rotate m shifts)</code></div><div class="doc"><pre class="plaintext">Rotates an array along specified dimensions.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L951">view source</a></div></div><div class="public anchor" id="var-round"><h3>round</h3><div class="usage"><code>(round m)</code></div><div class="doc"><pre class="plaintext">Computes the round function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-round.21"><h3>round!</h3><div class="usage"><code>(round! m)</code></div><div class="doc"><pre class="plaintext">Computes the round function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-row-count"><h3>row-count</h3><div class="usage"><code>(row-count m)</code></div><div class="doc"><pre class="plaintext">Returns the number of rows in a matrix or vector (array must be 1D or more)
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L515">view source</a></div></div><div class="public anchor" id="var-row-matrix"><h3>row-matrix</h3><div class="usage"><code>(row-matrix data)</code><code>(row-matrix implementation data)</code></div><div class="doc"><pre class="plaintext">Constructs a row matrix with the given data. The returned matrix is a 2D 1xN row matrix.

The data must be either a valid existing vector or a sequence of scalar values.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L186">view source</a></div></div><div class="public anchor" id="var-row-matrix.3F"><h3>row-matrix?</h3><div class="usage"><code>(row-matrix? m)</code></div><div class="doc"><pre class="plaintext">Returns true if a matrix is a row-matrix (i.e. is 2D and has exactly one row)
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L548">view source</a></div></div><div class="public anchor" id="var-rows"><h3>rows</h3><div class="usage"><code>(rows m)</code></div><div class="doc"><pre class="plaintext">Gets the rows of a matrix, as a sequence of 1D vectors.

If the array has more than 2 dimensions, will return the rows from all slices in order.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L900">view source</a></div></div><div class="public anchor" id="var-same-shape.3F"><h3>same-shape?</h3><div class="usage"><code>(same-shape?)</code><code>(same-shape? m)</code><code>(same-shape? m n)</code><code>(same-shape? m n &amp; more)</code></div><div class="doc"><pre class="plaintext">Returns true if the arrays have the same shape, false otherwise
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L611">view source</a></div></div><div class="public anchor" id="var-scalar"><h3>scalar</h3><div class="usage"><code>(scalar m)</code></div><div class="doc"><pre class="plaintext">Coerces m to a scalar value. Result is guaranteed not to be an array.
Will throw an exception if m is not zero-dimensional.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L418">view source</a></div></div><div class="public anchor" id="var-scalar-array"><h3>scalar-array</h3><div class="usage"><code>(scalar-array value)</code><code>(scalar-array implementation value)</code></div><div class="doc"><pre class="plaintext">Creates a new zero-dimensional array containing the specified scalar value.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L179">view source</a></div></div><div class="public anchor" id="var-scalar.3F"><h3>scalar?</h3><div class="usage"><code>(scalar? v)</code></div><div class="doc"><pre class="plaintext">Returns true if the parameter is a scalar value (i.e. acceptable as matrix element value).
A 0-d array containing a scalar is *not* itself a scalar value.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L444">view source</a></div></div><div class="public anchor" id="var-scale"><h3>scale</h3><div class="usage"><code>(scale m factor)</code><code>(scale m factor &amp; more-factors)</code></div><div class="doc"><pre class="plaintext">Scales a numerical array by one or more scalar factors.
Returns a new scaled matrix.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1268">view source</a></div></div><div class="public anchor" id="var-scale.21"><h3>scale!</h3><div class="usage"><code>(scale! m factor)</code><code>(scale! m factor &amp; more-factors)</code></div><div class="doc"><pre class="plaintext">Scales a numerical array by one or more scalar factors (in place).
Returns the matrix after it has been mutated.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1276">view source</a></div></div><div class="public anchor" id="var-select"><h3>select</h3><div class="usage"><code>(select a &amp; args)</code></div><div class="doc"><pre class="plaintext">Returns a view containing all elements in a which are at the positions
of the Cartesian product of args. An argument can be:
 - a number - selects like [number] but drops the current dimension,
 - a 1-dimensional array of numbers
 - the keyword :all which is the same as the range of all valid indices.
The number of args must match the dimensionality of a.

Examples:
(select [[1 2][3 4]] 0 0) ;=&gt; 1
(select [[1 2][3 4]] 0 :all) ;=&gt; [1 2]
(select [[1 2][3 4]] [0 1] [0]) ;=&gt; [[1] [3]]
(select [[1 2][3 4]] :all 0) ;=&gt; [1 3]</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L770">view source</a></div></div><div class="public anchor" id="var-select-indices"><h3>select-indices</h3><div class="usage"><code>(select-indices a indices)</code></div><div class="doc"><pre class="plaintext">Returns a one-dimensional array of the elements which are at the specified
indices. An index is a one-dimensional array which element-count matches the
dimensionality of a. Examples:
(select-indices [[1 2] [3 4]] [[0 0][1 1]]) ;=&gt; [1 4]</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L789">view source</a></div></div><div class="public anchor" id="var-set-column"><h3>set-column</h3><div class="usage"><code>(set-column m i column)</code></div><div class="doc"><pre class="plaintext">Sets a column in a matrix using a specified vector.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1465">view source</a></div></div><div class="public anchor" id="var-set-column.21"><h3>set-column!</h3><div class="usage"><code>(set-column! m i column)</code></div><div class="doc"><pre class="plaintext">Sets a column in a matrix using a specified vector.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1470">view source</a></div></div><div class="public anchor" id="var-set-current-implementation"><h3>set-current-implementation</h3><div class="usage"><code>(set-current-implementation m)</code></div><div class="doc"><pre class="plaintext">Sets the currently active core.matrix implementation. Parameter may be either a keyword identifying the 
imnplementation, or an array instance from the implementation.

This is used primarily for functions that construct new matrices, i.e. it determines the
implementation used for expressions like: (matrix [[1 2] [3 4]])</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1645">view source</a></div></div><div class="public anchor" id="var-set-indices"><h3>set-indices</h3><div class="usage"><code>(set-indices a indices values)</code></div><div class="doc"><pre class="plaintext">like select-indices but sets the elements at the specified indices to values.
Leaves a unchanged and returns a modified array</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L811">view source</a></div></div><div class="public anchor" id="var-set-indices.21"><h3>set-indices!</h3><div class="usage"><code>(set-indices! a indices values)</code></div><div class="doc"><pre class="plaintext">like set-indices but destructively modifies array in place
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L817">view source</a></div></div><div class="public anchor" id="var-set-row"><h3>set-row</h3><div class="usage"><code>(set-row m i row)</code></div><div class="doc"><pre class="plaintext">Sets a row in a matrix using a specified vector.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1454">view source</a></div></div><div class="public anchor" id="var-set-row.21"><h3>set-row!</h3><div class="usage"><code>(set-row! m i row)</code></div><div class="doc"><pre class="plaintext">Sets a row in a matrix in-place using a specified vector.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1459">view source</a></div></div><div class="public anchor" id="var-set-selection"><h3>set-selection</h3><div class="usage"><code>(set-selection a &amp; args)</code></div><div class="doc"><pre class="plaintext">Like select but sets the elements in the selection to the values in (last
args). Leaves a unchanged and returns the modified array</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L797">view source</a></div></div><div class="public anchor" id="var-set-selection.21"><h3>set-selection!</h3><div class="usage"><code>(set-selection! a &amp; args)</code></div><div class="doc"><pre class="plaintext">Like set-selection but destructively modifies a in place
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L804">view source</a></div></div><div class="public anchor" id="var-shape"><h3>shape</h3><div class="usage"><code>(shape m)</code></div><div class="doc"><pre class="plaintext">Returns the shape of an array, i.e. the dimension sizes for all dimensions.

The result will be a vector containing only integer index values, with a count
equal to the dimensionality of the array.

Returns nil the if object is not an array (i.e. is a scalar value)</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L560">view source</a></div></div><div class="public anchor" id="var-signum"><h3>signum</h3><div class="usage"><code>(signum m)</code></div><div class="doc"><pre class="plaintext">Computes the signum function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-signum.21"><h3>signum!</h3><div class="usage"><code>(signum! m)</code></div><div class="doc"><pre class="plaintext">Computes the signum function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-sin"><h3>sin</h3><div class="usage"><code>(sin m)</code></div><div class="doc"><pre class="plaintext">Computes the sin function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-sin.21"><h3>sin!</h3><div class="usage"><code>(sin! m)</code></div><div class="doc"><pre class="plaintext">Computes the sin function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-sinh"><h3>sinh</h3><div class="usage"><code>(sinh m)</code></div><div class="doc"><pre class="plaintext">Computes the sinh function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-sinh.21"><h3>sinh!</h3><div class="usage"><code>(sinh! m)</code></div><div class="doc"><pre class="plaintext">Computes the sinh function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-slice"><h3>slice</h3><div class="usage"><code>(slice m index)</code><code>(slice m dimension index)</code></div><div class="doc"><pre class="plaintext">Gets a slice of an array along a specific dimension.
The returned array will have one less dimension.

Slicing a 1D vector will return a scalar.

Slicing on the first dimension (dimension 0) is likely to perform better
for many array implementations, and is therefore the default if no
dimension is specified.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L861">view source</a></div></div><div class="public anchor" id="var-slice-count"><h3>slice-count</h3><div class="usage"><code>(slice-count m)</code></div><div class="doc"><pre class="plaintext">Returns the number of slices in an array (array must be 1D or more). The array is sliced
in row-major order, i.e. this is the dimension count of the first dimension.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L534">view source</a></div></div><div class="public anchor" id="var-slice-views"><h3>slice-views</h3><div class="usage"><code>(slice-views m)</code><code>(slice-views m dimension)</code></div><div class="doc"><pre class="plaintext">Gets a sequence of views of the slices of an array. If dimension is supplied, slices along a given dimension,
otherwise slices along the first dimension. If the matrix implementation supports mutable views, these views
can be used to mutate portions of the original array.

The key difference between &apos;slices&apos; and &apos;slice-views&apos; is that &apos;slice-views&apos; will always return views, including
for the 0-dimensional case. Hence it will return a sequence of 0-dimensional scalar arrays if
the array is 1-dimensional.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L885">view source</a></div></div><div class="public anchor" id="var-slices"><h3>slices</h3><div class="usage"><code>(slices m)</code><code>(slices m dimension)</code></div><div class="doc"><pre class="plaintext">Gets a sequence of slices of an array. If dimension is supplied, slices along a given dimension,
otherwise slices along the first dimension.

Returns a sequence of scalar values if the array is 1-dimensional.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L875">view source</a></div></div><div class="public anchor" id="var-sparse"><h3>sparse</h3><div class="usage"><code>(sparse data)</code><code>(sparse implementation data)</code></div><div class="doc"><pre class="plaintext">Coerces an array to a sparse format if possible. Sparse arrays are expected to
minimise space usage for zero elements.

Returns the array unchanged if such coercion is not possible, or if the array is already sparse.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L321">view source</a></div></div><div class="public anchor" id="var-sparse-array"><h3>sparse-array</h3><div class="usage"><code>(sparse-array data)</code><code>(sparse-array implementation data)</code></div><div class="doc"><pre class="plaintext">Creates a sparse array with the given data, using a specified implementation
or the current implementation if not specified. 

Throws an exception if creation of a sparse array is not possible</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L310">view source</a></div></div><div class="public anchor" id="var-sparse-matrix"><h3>sparse-matrix</h3><div class="usage"><code>(sparse-matrix data)</code><code>(sparse-matrix implementation data)</code></div><div class="doc"><pre class="plaintext">Creates a sparse matrix with the given data, using a specified implementation
or the current implementation if not specified. Sparse matrices are required to store
a M*N matrix with E non-zero elements in approx O(M+N+E) space or less.

Throws an exception if creation of a sparse matrix is not possible</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L298">view source</a></div></div><div class="public anchor" id="var-sparse.3F"><h3>sparse?</h3><div class="usage"><code>(sparse? m)</code></div><div class="doc"><pre class="plaintext">Returns true if an array is sparse, i.e. the implementation supports storage of the entire
array in less memory than would normally be implied by the number of elements.

Sparse matrices may have memory requirements that scale with the number of non-zero elements
rather than the total number of elements, for example.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L493">view source</a></div></div><div class="public anchor" id="var-sqrt"><h3>sqrt</h3><div class="usage"><code>(sqrt m)</code></div><div class="doc"><pre class="plaintext">Computes the sqrt function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-sqrt.21"><h3>sqrt!</h3><div class="usage"><code>(sqrt! m)</code></div><div class="doc"><pre class="plaintext">Computes the sqrt function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-square"><h3>square</h3><div class="usage"><code>(square m)</code></div><div class="doc"><pre class="plaintext">Squares every element of a numerical array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1286">view source</a></div></div><div class="public anchor" id="var-square.3F"><h3>square?</h3><div class="usage"><code>(square? m)</code></div><div class="doc"><pre class="plaintext">Returns true if matrix is square (i.e. a 2D array with same number of rows and columns)
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L541">view source</a></div></div><div class="public anchor" id="var-sub"><h3>sub</h3><div class="usage"><code>(sub a)</code><code>(sub a b)</code><code>(sub a b &amp; more)</code></div><div class="doc"><pre class="plaintext">Performs element-wise subtraction on one or more numerical arrays.
Returns a new array.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1235">view source</a></div></div><div class="public anchor" id="var-sub.21"><h3>sub!</h3><div class="usage"><code>(sub! a)</code><code>(sub! a b)</code><code>(sub! a b &amp; more)</code></div><div class="doc"><pre class="plaintext">Performs element-wise mutable subtraction on one or more numerical arrays.
Returns the first array, after it has been mutated.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1256">view source</a></div></div><div class="public anchor" id="var-submatrix"><h3>submatrix</h3><div class="usage"><code>(submatrix m index-ranges)</code><code>(submatrix m dimension index-range)</code><code>(submatrix m row-start row-length col-start col-length)</code></div><div class="doc"><pre class="plaintext">Gets a view of a submatrix, for a set of index ranges.
Index ranges should be [start, length] pairs.
Index range pairs can be nil (gets the whole range) </pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L844">view source</a></div></div><div class="public anchor" id="var-subvector"><h3>subvector</h3><div class="usage"><code>(subvector m start length)</code></div><div class="doc"><pre class="plaintext">Gets a view of part of a vector. The view maintains a reference to the original,
so can be used to modify the original vector if it is mutable.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L855">view source</a></div></div><div class="public anchor" id="var-supports-dimensionality.3F"><h3>supports-dimensionality?</h3><div class="usage"><code>(supports-dimensionality? m dimension-count)</code></div><div class="doc"><pre class="plaintext">Returns true if the implementation for a given matrix supports a specific dimensionality, i.e.
can natively create and manipulate matrices with the given number of dimensions</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L358">view source</a></div></div><div class="public anchor" id="var-supports-shape.3F"><h3>supports-shape?</h3><div class="usage"><code>(supports-shape? m shape)</code></div><div class="doc"><pre class="plaintext">Returns true if the implementation supports creation of matrices with a specific shape.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L365">view source</a></div></div><div class="public anchor" id="var-swap-rows"><h3>swap-rows</h3><div class="usage"><code>(swap-rows m i j)</code></div><div class="doc"><pre class="plaintext">Swap row i with row j in a matrix, returning a new matrix
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1436">view source</a></div></div><div class="public anchor" id="var-symmetric.3F"><h3>symmetric?</h3><div class="usage"><code>(symmetric? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the parameter is a symmetric matrix
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L466">view source</a></div></div><div class="public anchor" id="var-tan"><h3>tan</h3><div class="usage"><code>(tan m)</code></div><div class="doc"><pre class="plaintext">Computes the tan function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-tan.21"><h3>tan!</h3><div class="usage"><code>(tan! m)</code></div><div class="doc"><pre class="plaintext">Computes the tan function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-tanh"><h3>tanh</h3><div class="usage"><code>(tanh m)</code></div><div class="doc"><pre class="plaintext">Computes the tanh function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-tanh.21"><h3>tanh!</h3><div class="usage"><code>(tanh! m)</code></div><div class="doc"><pre class="plaintext">Computes the tanh function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-to-degrees"><h3>to-degrees</h3><div class="usage"><code>(to-degrees m)</code></div><div class="doc"><pre class="plaintext">Computes the to-degrees function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-to-degrees.21"><h3>to-degrees!</h3><div class="usage"><code>(to-degrees! m)</code></div><div class="doc"><pre class="plaintext">Computes the to-degrees function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-to-double-array"><h3>to-double-array</h3><div class="usage"><code>(to-double-array m)</code><code>(to-double-array m want-copy?)</code></div><div class="doc"><pre class="plaintext">Returns a Java double[] array containing the values of a numerical array m in row-major order. Will
throw an error if any of the array elements cannot be converted to doubles.

If want-copy? is true, will guarantee a new double array (defensive copy).
If want-copy? is false, will return the internal array used by m, or nil if not supported
by the implementation.
If want-copy? is not specified, will return either a copy or the internal array</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L635">view source</a></div></div><div class="public anchor" id="var-to-nested-vectors"><h3>to-nested-vectors</h3><div class="usage"><code>(to-nested-vectors m)</code></div><div class="doc"><pre class="plaintext">Converts an array to an idiomatic, immutable nested Clojure vector format. The bottom level of the
nested vectors will contain the element values.

The depth of nesting will be equal to the dimensionality of the array.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L410">view source</a></div></div><div class="public anchor" id="var-to-object-array"><h3>to-object-array</h3><div class="usage"><code>(to-object-array m)</code><code>(to-object-array m want-copy?)</code></div><div class="doc"><pre class="plaintext">Returns a Java Object[] array containing the values of an array m in row-major order.

If want-copy? is true, will guarantee a new Object array (defensive copy).
If want-copy? is false, will return the internal array used by m, or nil if not supported
by the implementation.
If want-copy? is not specified, will return either a copy or the internal array</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L651">view source</a></div></div><div class="public anchor" id="var-to-radians"><h3>to-radians</h3><div class="usage"><code>(to-radians m)</code></div><div class="doc"><pre class="plaintext">Computes the to-radians function on all elements of an array, using double precision values. Returns a new array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-to-radians.21"><h3>to-radians!</h3><div class="usage"><code>(to-radians! m)</code></div><div class="doc"><pre class="plaintext">Computes the to-radians function on all elements of an array, using double precision values. Mutates the array in-place.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1418">view source</a></div></div><div class="public anchor" id="var-to-vector"><h3>to-vector</h3><div class="usage"><code>(to-vector m)</code></div><div class="doc"><pre class="plaintext">Creates a new array representing the elements of array m as a single flattened vector.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L974">view source</a></div></div><div class="public anchor" id="var-trace"><h3>trace</h3><div class="usage"><code>(trace a)</code></div><div class="doc"><pre class="plaintext">Calculates the trace of a 2D numerical matrix (sum of elements on main diagonal).

The matrix need not be square.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1381">view source</a></div></div><div class="public anchor" id="var-transform"><h3>transform</h3><div class="usage"><code>(transform t v)</code></div><div class="doc"><pre class="plaintext">Transforms a given vector with a transformation, returning a new vector.

The transformation may be a 2D matrix, but other types of transformation are also supported
e.g. affine transformations.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1171">view source</a></div></div><div class="public anchor" id="var-transform.21"><h3>transform!</h3><div class="usage"><code>(transform! t v)</code></div><div class="doc"><pre class="plaintext">Transforms a given vector in place. Returns the transformed vector.

The transformation must map an n-dimensional vector to another n-dimensional vector, i.e.
if it is a 2D matrix then it must have shape [n x n].</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1179">view source</a></div></div><div class="public anchor" id="var-transpose"><h3>transpose</h3><div class="usage"><code>(transpose m)</code><code>(transpose m ordering)</code></div><div class="doc"><pre class="plaintext">Transposes a matrix, returning a new matrix. For 2D matrices, rows and columns are swapped.
More generally, the dimension indices are reversed for any shape of array. Note that 1D vectors
and scalars will be returned unchanged.

If ordering is provided, will re-order dimensions according to the provided order.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1006">view source</a></div></div><div class="public anchor" id="var-transpose.21"><h3>transpose!</h3><div class="usage"><code>(transpose! m)</code></div><div class="doc"><pre class="plaintext">Transposes a square 2D matrix in-place. Will throw an exception if not possible.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L1017">view source</a></div></div><div class="public anchor" id="var-upper-triangular.3F"><h3>upper-triangular?</h3><div class="usage"><code>(upper-triangular? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the parameter is a upper triangular matrix
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L476">view source</a></div></div><div class="public anchor" id="var-vec.3F"><h3>vec?</h3><div class="usage"><code>(vec? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the parameter is a vector (1-dimensional array)
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L439">view source</a></div></div><div class="public anchor" id="var-with-implementation"><h3>with-implementation</h3><h4 class="type">macro</h4><div class="usage"><code>(with-implementation impl &amp; body)</code></div><div class="doc"><pre class="plaintext">Runs a set of expressions using a specified matrix implementation.

Example:
  (with-implementation :vectorz
    (new-matrix 10 10))</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L345">view source</a></div></div><div class="public anchor" id="var-zero-array"><h3>zero-array</h3><div class="usage"><code>(zero-array shape)</code><code>(zero-array implementation shape)</code></div><div class="doc"><pre class="plaintext">Creates a new zero-filled numerical array with the given shape.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L142">view source</a></div></div><div class="public anchor" id="var-zero-count"><h3>zero-count</h3><div class="usage"><code>(zero-count m)</code></div><div class="doc"><pre class="plaintext">Returns the number of zeros in an array.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L576">view source</a></div></div><div class="public anchor" id="var-zero-dimensional.3F"><h3>zero-dimensional?</h3><div class="usage"><code>(zero-dimensional? m)</code></div><div class="doc"><pre class="plaintext">Returns true if the parameter has zero dimensions. i.e. it is a 0-d array or a scalar value.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L451">view source</a></div></div><div class="public anchor" id="var-zero-matrix"><h3>zero-matrix</h3><div class="usage"><code>(zero-matrix rows columns)</code><code>(zero-matrix implementation rows columns)</code></div><div class="doc"><pre class="plaintext">Constructs a new zero-filled numerical matrix with the given dimensions.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L126">view source</a></div></div><div class="public anchor" id="var-zero-matrix.3F"><h3>zero-matrix?</h3><div class="usage"><code>(zero-matrix? m)</code></div><div class="doc"><pre class="plaintext">Returns true if all the elements of the parameter are zero.
</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L461">view source</a></div></div><div class="public anchor" id="var-zero-vector"><h3>zero-vector</h3><div class="usage"><code>(zero-vector length)</code><code>(zero-vector implementation length)</code></div><div class="doc"><pre class="plaintext">Constructs a new zero-filled numerical vector with the given length.

Implementations are encouraged to return immutable vectors or sparse vectors
for efficency whre available.</pre></div><div class="src-link"><a href="https://github.com/mikera/core.matrix/blob/master/src/main/clojure/clojure/core/matrix.clj#L106">view source</a></div></div></div></body></html>