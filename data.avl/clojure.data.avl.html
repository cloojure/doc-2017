<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>clojure.data.avl documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Data.avl</span> <span class="project-version">0.0.18-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="clojure.data.avl.html"><div class="inner"><span>clojure.data.avl</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="clojure.data.avl.html#var-nearest"><div class="inner"><span>nearest</span></div></a></li><li class="depth-1"><a href="clojure.data.avl.html#var-rank-of"><div class="inner"><span>rank-of</span></div></a></li><li class="depth-1"><a href="clojure.data.avl.html#var-sorted-map"><div class="inner"><span>sorted-map</span></div></a></li><li class="depth-1"><a href="clojure.data.avl.html#var-sorted-map-by"><div class="inner"><span>sorted-map-by</span></div></a></li><li class="depth-1"><a href="clojure.data.avl.html#var-sorted-set"><div class="inner"><span>sorted-set</span></div></a></li><li class="depth-1"><a href="clojure.data.avl.html#var-sorted-set-by"><div class="inner"><span>sorted-set-by</span></div></a></li><li class="depth-1"><a href="clojure.data.avl.html#var-split-at"><div class="inner"><span>split-at</span></div></a></li><li class="depth-1"><a href="clojure.data.avl.html#var-split-key"><div class="inner"><span>split-key</span></div></a></li><li class="depth-1"><a href="clojure.data.avl.html#var-subrange"><div class="inner"><span>subrange</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">clojure.data.avl</h1><div class="doc"><pre class="plaintext">An implementation of persistent sorted maps and sets based on AVL
trees which can be used as drop-in replacements for Clojure's
built-in sorted maps and sets based on red-black trees. Apart from
the standard sorted collection API, the provided map and set types
support the transients API and several additional logarithmic time
operations: rank queries via clojure.core/nth (select element by
rank) and clojure.data.avl/rank-of (discover rank of element),
"nearest key" lookups via clojure.data.avl/nearest, splits by key
and index via clojure.data.avl/split-key and
clojure.data.avl/split-at, respectively, and subsets/submaps using
clojure.data.avl/subrange.</pre></div><div class="public anchor" id="var-nearest"><h3>nearest</h3><h4 class="added">added in 0.0.12</h4><div class="usage"><code>(nearest coll test x)</code></div><div class="doc"><pre class="plaintext">(alpha)

Equivalent to, but more efficient than, (first (subseq* coll test x)),
where subseq* is clojure.core/subseq for test in #{&gt;, &gt;=} and
clojure.core/rsubseq for test in #{&lt;, &lt;=}.</pre></div></div><div class="public anchor" id="var-rank-of"><h3>rank-of</h3><h4 class="added">added in 0.0.6</h4><div class="usage"><code>(rank-of coll x)</code></div><div class="doc"><pre class="plaintext">Returns the rank of x in coll or -1 if not present.
</pre></div></div><div class="public anchor" id="var-sorted-map"><h3>sorted-map</h3><h4 class="added">added in 0.0.1</h4><div class="usage"><code>(sorted-map &amp; keyvals)</code></div><div class="doc"><pre class="plaintext">keyval =&gt; key val
Returns a new AVL map with supplied mappings.</pre></div></div><div class="public anchor" id="var-sorted-map-by"><h3>sorted-map-by</h3><h4 class="added">added in 0.0.1</h4><div class="usage"><code>(sorted-map-by comparator &amp; keyvals)</code></div><div class="doc"><pre class="plaintext">keyval =&gt; key val
Returns a new sorted map with supplied mappings, using the supplied
comparator.</pre></div></div><div class="public anchor" id="var-sorted-set"><h3>sorted-set</h3><h4 class="added">added in 0.0.1</h4><div class="usage"><code>(sorted-set &amp; keys)</code></div><div class="doc"><pre class="plaintext">Returns a new sorted set with supplied keys.
</pre></div></div><div class="public anchor" id="var-sorted-set-by"><h3>sorted-set-by</h3><h4 class="added">added in 0.0.1</h4><div class="usage"><code>(sorted-set-by comparator &amp; keys)</code></div><div class="doc"><pre class="plaintext">Returns a new sorted set with supplied keys, using the supplied comparator.
</pre></div></div><div class="public anchor" id="var-split-at"><h3>split-at</h3><h4 class="added">added in 0.0.12</h4><div class="usage"><code>(split-at n coll)</code></div><div class="doc"><pre class="plaintext">(alpha)

Equivalent to, but more efficient than,
[(into (empty coll) (take n coll))
 (into (empty coll) (drop n coll))].</pre></div></div><div class="public anchor" id="var-split-key"><h3>split-key</h3><h4 class="added">added in 0.0.12</h4><div class="usage"><code>(split-key k coll)</code></div><div class="doc"><pre class="plaintext">(alpha)

Returns [left e? right], where left and right are collections of
the same type as coll and containing, respectively, the keys below
and above k in the ordering determined by coll's comparator, while
e? is the entry at key k for maps, the stored copy of the key k for
sets, nil if coll does not contain k.</pre></div></div><div class="public anchor" id="var-subrange"><h3>subrange</h3><h4 class="added">added in 0.0.12</h4><div class="usage"><code>(subrange coll test limit)</code><code>(subrange coll start-test start end-test end)</code></div><div class="doc"><pre class="plaintext">(alpha)

Returns an AVL collection comprising the entries of coll between
start and end (in the sense determined by coll's comparator) in
logarithmic time. Whether the endpoints are themselves included in
the returned collection depends on the provided tests; start-test
must be either &gt; or &gt;=, end-test must be either &lt; or &lt;=.

When passed a single test and limit, subrange infers the other end
of the range from the test: &gt; / &gt;= mean to include items up to the
end of coll, &lt; / &lt;= mean to include items taken from the beginning
of coll.

(subrange coll &gt;= start &lt;= end) is equivalent to, but more efficient
than, (into (empty coll) (subseq coll &gt;= start &lt;= end)).</pre></div></div></div></body></html>