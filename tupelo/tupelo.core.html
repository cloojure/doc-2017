<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>tupelo.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Tupelo</span> <span class="project-version">0.9.73</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tupelo</span></div></div></li><li class="depth-2 branch"><a href="tupelo.array.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>array</span></div></a></li><li class="depth-2 branch"><a href="tupelo.async.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>async</span></div></a></li><li class="depth-2 branch"><a href="tupelo.base64.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>base64</span></div></a></li><li class="depth-2 branch"><a href="tupelo.base64url.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>base64url</span></div></a></li><li class="depth-2 branch"><a href="tupelo.char.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>char</span></div></a></li><li class="depth-2 branch current"><a href="tupelo.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="tupelo.csv.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>csv</span></div></a></li><li class="depth-2 branch"><a href="tupelo.dev.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dev</span></div></a></li><li class="depth-2 branch"><a href="tupelo.forest.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>forest</span></div></a></li><li class="depth-2 branch"><a href="tupelo.gen.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>gen</span></div></a></li><li class="depth-2 branch"><a href="tupelo.misc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>misc</span></div></a></li><li class="depth-2 branch"><a href="tupelo.parse.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parse</span></div></a></li><li class="depth-2 branch"><a href="tupelo.pedestal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pedestal</span></div></a></li><li class="depth-2 branch"><a href="tupelo.schema.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>schema</span></div></a></li><li class="depth-2 branch"><a href="tupelo.spec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>spec</span></div></a></li><li class="depth-2 branch"><a href="tupelo.string.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>string</span></div></a></li><li class="depth-2 branch"><a href="tupelo.test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></a></li><li class="depth-2 branch"><a href="tupelo.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>x</span></div></div></li><li class="depth-3 branch"><a href="tupelo.x.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-3 branch"><a href="tupelo.x.spec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>spec</span></div></a></li><li class="depth-3"><a href="tupelo.x.specter.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>specter</span></div></a></li><li class="depth-2"><a href="tupelo.y64.html"><div class="inner"><span class="tree" style="top: -114px;"><span class="top" style="height: 123px;"></span><span class="bottom"></span></span><span>y64</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="tupelo.core.html#var--.3Evector"><div class="inner"><span>-&gt;vector</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-all-rel.3D"><div class="inner"><span>all-rel=</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-append"><div class="inner"><span>append</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-chars-thru"><div class="inner"><span>chars-thru</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-check-spy-enabled"><div class="inner"><span>check-spy-enabled</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-clip-str"><div class="inner"><span>clip-str</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-conjv"><div class="inner"><span>conjv</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-contains-elem.3F"><div class="inner"><span>contains-elem?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-contains-key.3F"><div class="inner"><span>contains-key?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-contains-val.3F"><div class="inner"><span>contains-val?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-dissoc-in"><div class="inner"><span>dissoc-in</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-drop-at"><div class="inner"><span>drop-at</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-drop-if"><div class="inner"><span>drop-if</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-edn-.3Ejson"><div class="inner"><span>edn-&gt;json</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-falsey.3F"><div class="inner"><span>falsey?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-fetch"><div class="inner"><span>fetch</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-fetch-in"><div class="inner"><span>fetch-in</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-fibo-nth"><div class="inner"><span>fibo-nth</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-fibo-thru"><div class="inner"><span>fibo-thru</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-fibonacci-seq"><div class="inner"><span>fibonacci-seq</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-forv"><div class="inner"><span>forv</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-glue"><div class="inner"><span>glue</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-glue-rows"><div class="inner"><span>glue-rows</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-grab"><div class="inner"><span>grab</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-has-length.3F"><div class="inner"><span>has-length?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-has-none.3F"><div class="inner"><span>has-none?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-has-some.3F"><div class="inner"><span>has-some?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-idx"><div class="inner"><span>idx</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-if-java-1-7-plus"><div class="inner"><span>if-java-1-7-plus</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-if-java-1-8-plus"><div class="inner"><span>if-java-1-8-plus</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-increasing-or-equal.3F"><div class="inner"><span>increasing-or-equal?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-increasing.3F"><div class="inner"><span>increasing?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-index-using"><div class="inner"><span>index-using</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-indexed"><div class="inner"><span>indexed</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-insert-at"><div class="inner"><span>insert-at</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-int-.3Ekw"><div class="inner"><span>int-&gt;kw</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-java-1-7-plus.3F"><div class="inner"><span>is-java-1-7-plus?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-java-1-7.3F"><div class="inner"><span>is-java-1-7?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-java-1-8-plus.3F"><div class="inner"><span>is-java-1-8-plus?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-java-1-8.3F"><div class="inner"><span>is-java-1-8?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-it-.3E"><div class="inner"><span>it-&gt;</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-java-version"><div class="inner"><span>java-version</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-java-version-matches.3F"><div class="inner"><span>java-version-matches?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-java-version-min.3F"><div class="inner"><span>java-version-min?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-json-.3Eedn"><div class="inner"><span>json-&gt;edn</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-keep-if"><div class="inner"><span>keep-if</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-keyvals"><div class="inner"><span>keyvals</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-keyvals-seq"><div class="inner"><span>keyvals-seq</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-keyvals-seq*"><div class="inner"><span>keyvals-seq*</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-kw-.3Eint"><div class="inner"><span>kw-&gt;int</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-kw-.3Estr"><div class="inner"><span>kw-&gt;str</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-kw-.3Esym"><div class="inner"><span>kw-&gt;sym</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-lazy-cons"><div class="inner"><span>lazy-cons</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-lazy-gen"><div class="inner"><span>lazy-gen</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-let-spy"><div class="inner"><span>let-spy</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-let-spy-pretty"><div class="inner"><span>let-spy-pretty</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-lexical-compare"><div class="inner"><span>lexical-compare</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-macro.3F"><div class="inner"><span>macro?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-map-keys"><div class="inner"><span>map-keys</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-map-let"><div class="inner"><span>map-let</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-map-let*"><div class="inner"><span>map-let*</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-map-vals"><div class="inner"><span>map-vals</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-matches.3F"><div class="inner"><span>matches?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-nl"><div class="inner"><span>nl</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-not-empty.3F"><div class="inner"><span>not-empty?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-not-nil.3F"><div class="inner"><span>not-nil?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-onlies"><div class="inner"><span>onlies</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-only"><div class="inner"><span>only</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-only2"><div class="inner"><span>only2</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-only.3F"><div class="inner"><span>only?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-pair.3F"><div class="inner"><span>pair?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-partition-using"><div class="inner"><span>partition-using</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-prepend"><div class="inner"><span>prepend</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-pretty"><div class="inner"><span>pretty</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-pretty-str"><div class="inner"><span>pretty-str</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-print-versions"><div class="inner"><span>print-versions</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-quad.3F"><div class="inner"><span>quad?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-range-vec"><div class="inner"><span>range-vec</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-refer-tupelo"><div class="inner"><span>refer-tupelo</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-rel.3D"><div class="inner"><span>rel=</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-replace-at"><div class="inner"><span>replace-at</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-safe-.3E"><div class="inner"><span>safe-&gt;</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-seq-.3Estr"><div class="inner"><span>seq-&gt;str</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-single.3F"><div class="inner"><span>single?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-split-match"><div class="inner"><span>split-match</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-split-using"><div class="inner"><span>split-using</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-spy"><div class="inner"><span>spy</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-spyx"><div class="inner"><span>spyx</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-spyx-pretty"><div class="inner"><span>spyx-pretty</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-spyxx"><div class="inner"><span>spyxx</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-starts-with.3F"><div class="inner"><span>starts-with?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-str-.3Echars"><div class="inner"><span>str-&gt;chars</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-str-.3Ekw"><div class="inner"><span>str-&gt;kw</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-str-.3Esym"><div class="inner"><span>str-&gt;sym</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-strcat"><div class="inner"><span>strcat</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-submap-by-keys"><div class="inner"><span>submap-by-keys</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-submap-by-vals"><div class="inner"><span>submap-by-vals</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-submap.3F"><div class="inner"><span>submap?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-submatch.3F"><div class="inner"><span>submatch?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-sym-.3Ekw"><div class="inner"><span>sym-&gt;kw</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-sym-.3Estr"><div class="inner"><span>sym-&gt;str</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-thru"><div class="inner"><span>thru</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-triple.3F"><div class="inner"><span>triple?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-truthy.3F"><div class="inner"><span>truthy?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-unnest"><div class="inner"><span>unnest</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-unwrap"><div class="inner"><span>unwrap</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-val.3D"><div class="inner"><span>val=</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-validate"><div class="inner"><span>validate</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-validate-map-keys"><div class="inner"><span>validate-map-keys</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-when-clojure-1-8-plus"><div class="inner"><span>when-clojure-1-8-plus</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-when-clojure-1-9-plus"><div class="inner"><span>when-clojure-1-9-plus</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-wild-item.3F"><div class="inner"><span>wild-item?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-wild-match-ctx.3F"><div class="inner"><span>wild-match-ctx?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-wild-match.3F"><div class="inner"><span>wild-match?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-wild-submatch.3F"><div class="inner"><span>wild-submatch?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-with-exception-default"><div class="inner"><span>with-exception-default</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-with-spy-enabled"><div class="inner"><span>with-spy-enabled</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-with-spy-indent"><div class="inner"><span>with-spy-indent</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-xbutlast"><div class="inner"><span>xbutlast</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-xfirst"><div class="inner"><span>xfirst</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-xfourth"><div class="inner"><span>xfourth</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-xlast"><div class="inner"><span>xlast</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-xrest"><div class="inner"><span>xrest</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-xreverse"><div class="inner"><span>xreverse</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-xsecond"><div class="inner"><span>xsecond</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-xthird"><div class="inner"><span>xthird</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-xvec"><div class="inner"><span>xvec</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-yield"><div class="inner"><span>yield</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-yield-all"><div class="inner"><span>yield-all</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-zip"><div class="inner"><span>zip</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-zip*"><div class="inner"><span>zip*</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-zip-lazy"><div class="inner"><span>zip-lazy</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">tupelo.core</h1><div class="doc"><pre class="plaintext">Tupelo - Making Clojure even sweeter
</pre></div><div class="public anchor" id="var--.3Evector"><h3>-&gt;vector</h3><div class="usage"><code>(-&gt;vector &amp; args)</code></div><div class="doc"><pre class="plaintext">Wraps all args in a vector, as with `clojure.core/vector`. Will (recursively) recognize
any embedded calls to (unwrap &lt;vec-or-list&gt;) and insert their elements as with the
unquote-spicing operator (~@). Examples:

    (-&gt;vector 1 2 3 4 5 6 7 8 9)              =&gt;  [1 2 3 4 5 6 7 8 9]
    (-&gt;vector 1 2 3 (unwrap [4 5 6]) 7 8 9)   =&gt;  [1 2 3 4 5 6 7 8 9] </pre></div></div><div class="public anchor" id="var-all-rel.3D"><h3>all-rel=</h3><div class="usage"><code>(all-rel= x-vals y-vals &amp; opts)</code></div><div class="doc"><pre class="plaintext">Applies
</pre></div></div><div class="public anchor" id="var-append"><h3>append</h3><div class="usage"><code>(append listy &amp; elems)</code></div><div class="doc"><pre class="plaintext">Given a sequential object (vector or list), add one or more elements to the end.
</pre></div></div><div class="public anchor" id="var-chars-thru"><h3>chars-thru</h3><div class="usage"><code>(chars-thru start-char stop-char)</code></div><div class="doc"><pre class="plaintext">Given two characters (or numerical equivalents), returns a seq of characters
(inclusive) from the first to the second.  Characters must be in ascending order.</pre></div></div><div class="public anchor" id="var-check-spy-enabled"><h3>check-spy-enabled</h3><h4 class="type">macro</h4><div class="usage"><code>(check-spy-enabled tag &amp; forms)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-clip-str"><h3>clip-str</h3><div class="usage"><code>(clip-str nchars &amp; args)</code></div><div class="doc"><pre class="plaintext">Converts all args to single string and clips any characters beyond nchars.
</pre></div></div><div class="public anchor" id="var-conjv"><h3>conjv</h3><h4 class="deprecated">deprecated</h4><div class="usage"><code>(conjv base-coll value)</code><code>(conjv base-coll value &amp; values)</code></div><div class="doc"><pre class="plaintext">Inputs: ([base-coll :- [s/Any] value :- s/Any] [base-coll :- [s/Any] value :- s/Any &amp; values :- [s/Any]])
Returns: [s/Any]

***** DEPRECATED:  replaced by tupelo.core/append *****

 Given base-coll and and one or more values, converts base-coll to a vector and then appends the values.
 The result is always returned as a vector. Note that `(conjv nil 5)` -&gt; `[5]`</pre></div></div><div class="public anchor" id="var-contains-elem.3F"><h3>contains-elem?</h3><div class="usage"><code>(contains-elem? coll elem)</code></div><div class="doc"><pre class="plaintext">For any collection coll &amp; element tgt, returns true if coll contains at least one
instance of tgt; otherwise returns false. Note that, for maps, each element is a
vector (i.e MapEntry) of the form [key value].</pre></div></div><div class="public anchor" id="var-contains-key.3F"><h3>contains-key?</h3><div class="usage"><code>(contains-key? map-or-set elem)</code></div><div class="doc"><pre class="plaintext">For any map or set, returns true if elem is a map key or set element, respectively
</pre></div></div><div class="public anchor" id="var-contains-val.3F"><h3>contains-val?</h3><div class="usage"><code>(contains-val? map elem)</code></div><div class="doc"><pre class="plaintext">For any map, returns true if elem is present in the map for at least one key.
</pre></div></div><div class="public anchor" id="var-dissoc-in"><h3>dissoc-in</h3><div class="usage"><code>(dissoc-in the-map keys-vec)</code></div><div class="doc"><pre class="plaintext">Inputs: [the-map :- ts/KeyMap keys-vec :- [s/Keyword]]
Returns: s/Any

A sane version of dissoc-in that will not delete intermediate keys.
 When invoked as (dissoc-in the-map [:k1 :k2 :k3... :kZ]), acts like
 (clojure.core/update-in the-map [:k1 :k2 :k3...] dissoc :kZ). That is, only
 the map entry containing the last key :kZ is removed, and all map entries
 higher than kZ in the hierarchy are unaffected.</pre></div></div><div class="public anchor" id="var-drop-at"><h3>drop-at</h3><div class="usage"><code>(drop-at coll index)</code></div><div class="doc"><pre class="plaintext">Removes an element from a collection at the specified index.
</pre></div></div><div class="public anchor" id="var-drop-if"><h3>drop-if</h3><div class="usage"><code>(drop-if pred coll)</code></div><div class="doc"><pre class="plaintext">Returns a vector of items in coll for which (pred item) is false (alias for clojure.core/remove)
</pre></div></div><div class="public anchor" id="var-edn-.3Ejson"><h3>edn-&gt;json</h3><div class="usage"><code>(edn-&gt;json arg)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-falsey.3F"><h3>falsey?</h3><div class="usage"><code>(falsey? arg)</code></div><div class="doc"><pre class="plaintext">Returns true if arg is logical false (either nil or false); otherwise returns false. Equivalent
to (not (truthy? arg)).</pre></div></div><div class="public anchor" id="var-fetch"><h3>fetch</h3><div class="usage"><code>(fetch the-map the-key)</code></div><div class="doc"><pre class="plaintext">A fail-fast version of keyword/map lookup.  When invoked as (fetch the-map :the-key),
returns the value associated with :the-key as for (clojure.core/get the-map :the-key).
Throws an Exception if :the-key is not present in the-map.</pre></div></div><div class="public anchor" id="var-fetch-in"><h3>fetch-in</h3><div class="usage"><code>(fetch-in the-map keys-vec)</code></div><div class="doc"><pre class="plaintext">A fail-fast version of clojure.core/get-in. When invoked as (fetch-in the-map keys-vec),
returns the value associated with keys-vec as for (clojure.core/get-in the-map keys-vec).
Throws an Exception if the path keys-vec is not present in the-map.</pre></div></div><div class="public anchor" id="var-fibo-nth"><h3>fibo-nth</h3><div class="usage"><code>(fibo-nth N)</code></div><div class="doc"><pre class="plaintext">Returns the N'th Fibonacci number (zero-based). Note that
N=91 corresponds to approx 2^62</pre></div></div><div class="public anchor" id="var-fibo-thru"><h3>fibo-thru</h3><div class="usage"><code>(fibo-thru limit)</code></div><div class="doc"><pre class="plaintext">Returns a vector of Fibonacci numbers up to limit (inclusive). Note that a
2^62  corresponds to 91'st Fibonacci number.</pre></div></div><div class="public anchor" id="var-fibonacci-seq"><h3>fibonacci-seq</h3><div class="usage"><code>(fibonacci-seq)</code></div><div class="doc"><pre class="plaintext">A lazy seq of Fibonacci numbers (memoized).
</pre></div></div><div class="public anchor" id="var-forv"><h3>forv</h3><h4 class="type">macro</h4><div class="usage"><code>(forv &amp; forms)</code></div><div class="doc"><pre class="plaintext">Like clojure.core/for but returns results in a vector.   Not lazy.
</pre></div></div><div class="public anchor" id="var-glue"><h3>glue</h3><div class="usage"><code>(glue &amp; colls)</code></div><div class="doc"><pre class="plaintext">Glues together like collections:

  (glue [1 2] [3 4] [5 6])                -&gt; [1 2 3 4 5 6]
  (glue {:a 1} {:b 2} {:c 3})             -&gt; {:a 1 :c 3 :b 2}
  (glue #{1 2} #{3 4} #{6 5})             -&gt; #{1 2 6 5 3 4}
  (glue "I" " like " \a " nap!" )  -&gt; "I like a nap!"

If you want to convert to a sorted set or map, just put an empty one first:

  (glue (sorted-map) {:a 1} {:b 2} {:c 3})      -&gt; {:a 1 :b 2 :c 3}
  (glue (sorted-set) #{1 2} #{3 4} #{6 5})      -&gt; #{1 2 3 4 5 6}

If there are duplicate keys when using glue for maps or sets, then "the last one wins":

  (glue {:band :VanHalen :singer :Dave}  {:singer :Sammy}) </pre></div></div><div class="public anchor" id="var-glue-rows"><h3>glue-rows</h3><div class="usage"><code>(glue-rows coll-2d)</code></div><div class="doc"><pre class="plaintext">Convert a vector of vectors (2-dimensional) into a single vector (1-dimensional).
Equivalent to `(apply glue ...)`</pre></div></div><div class="public anchor" id="var-grab"><h3>grab</h3><div class="usage"><code>(grab the-key the-map)</code></div><div class="doc"><pre class="plaintext">A fail-fast version of keyword/map lookup.  When invoked as (grab :the-key the-map),
returns the value associated with :the-key as for (clojure.core/get the-map :the-key).
Throws an Exception if :the-key is not present in the-map.</pre></div></div><div class="public anchor" id="var-has-length.3F"><h3>has-length?</h3><div class="usage"><code>(has-length? coll n)</code></div><div class="doc"><pre class="plaintext">Returns true if the collection has the indicated length. Does not hang for infinite sequences.
</pre></div></div><div class="public anchor" id="var-has-none.3F"><h3>has-none?</h3><div class="usage"><code>(has-none? pred coll)</code></div><div class="doc"><pre class="plaintext">For any predicate pred &amp; collection coll, returns false if (pred x) is logical true for at least one x in
coll; otherwise returns true.  Equivalent to clojure.core/not-any?, but inverse of has-some?.</pre></div></div><div class="public anchor" id="var-has-some.3F"><h3>has-some?</h3><div class="usage"><code>(has-some? pred coll)</code></div><div class="doc"><pre class="plaintext">For any predicate pred &amp; collection coll, returns true if (pred x) is logical true for at least one x in
coll; otherwise returns false.  Like clojure.core/some, but returns only true or false.</pre></div></div><div class="public anchor" id="var-idx"><h3>idx</h3><div class="usage"><code>(idx coll index-val)</code></div><div class="doc"><pre class="plaintext">Indexes into a vector, allowing negative index values
</pre></div></div><div class="public anchor" id="var-if-java-1-7-plus"><h3>if-java-1-7-plus</h3><h4 class="type">macro</h4><div class="usage"><code>(if-java-1-7-plus if-form else-form)</code></div><div class="doc"><pre class="plaintext">If JVM is Java 1.7 or higher, evaluates if-form into code. Otherwise, evaluates else-form.
</pre></div></div><div class="public anchor" id="var-if-java-1-8-plus"><h3>if-java-1-8-plus</h3><h4 class="type">macro</h4><div class="usage"><code>(if-java-1-8-plus if-form else-form)</code></div><div class="doc"><pre class="plaintext">If JVM is Java 1.8 or higher, evaluates if-form into code. Otherwise, evaluates else-form.
</pre></div></div><div class="public anchor" id="var-increasing-or-equal.3F"><h3>increasing-or-equal?</h3><div class="usage"><code>(increasing-or-equal? a b)</code></div><div class="doc"><pre class="plaintext">Returns true iff the vectors are in (strictly) lexicographically increasing-or-equal order
[1 2]  [1]        -&gt; false
[1 2]  [1 1]      -&gt; false
[1 2]  [1 2]      -&gt; true
[1 2]  [1 2 nil]  -&gt; true
[1 2]  [1 2 3]    -&gt; true
[1 2]  [1 3]      -&gt; true
[1 2]  [2 1]      -&gt; true
[1 2]  [2]        -&gt; true </pre></div></div><div class="public anchor" id="var-increasing.3F"><h3>increasing?</h3><div class="usage"><code>(increasing? a b)</code></div><div class="doc"><pre class="plaintext">Returns true iff the vectors are in (strictly) lexicographically increasing order
[1 2]  [1]        -&gt; false
[1 2]  [1 1]      -&gt; false
[1 2]  [1 2]      -&gt; false
[1 2]  [1 2 nil]  -&gt; true
[1 2]  [1 2 3]    -&gt; true
[1 2]  [1 3]      -&gt; true
[1 2]  [2 1]      -&gt; true
[1 2]  [2]        -&gt; true </pre></div></div><div class="public anchor" id="var-index-using"><h3>index-using</h3><div class="usage"><code>(index-using pred coll)</code></div><div class="doc"><pre class="plaintext">Finds the first index N where (&lt; N (count coll)) such that (pred (drop N coll)) is truthy.
Returns `nil` if no match found.</pre></div></div><div class="public anchor" id="var-indexed"><h3>indexed</h3><div class="usage"><code>(indexed &amp; colls)</code></div><div class="doc"><pre class="plaintext">Given one or more collections, returns a sequence of indexed tuples from the collections:
(indexed xs ys zs) -&gt; [ [0 x0 y0 z0]
                        [1 x1 y1 z1]
                        [2 x2 y2 z2]
                        ... ] </pre></div></div><div class="public anchor" id="var-insert-at"><h3>insert-at</h3><div class="usage"><code>(insert-at coll index elem)</code></div><div class="doc"><pre class="plaintext">Inserts an element into a collection at the specified index.
</pre></div></div><div class="public anchor" id="var-int-.3Ekw"><h3>int-&gt;kw</h3><div class="usage"><code>(int-&gt;kw arg)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-java-1-7-plus.3F"><h3>is-java-1-7-plus?</h3><div class="usage"><code>(is-java-1-7-plus?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-java-1-7.3F"><h3>is-java-1-7?</h3><div class="usage"><code>(is-java-1-7?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-java-1-8-plus.3F"><h3>is-java-1-8-plus?</h3><div class="usage"><code>(is-java-1-8-plus?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-java-1-8.3F"><h3>is-java-1-8?</h3><div class="usage"><code>(is-java-1-8?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-it-.3E"><h3>it-&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(it-&gt; expr &amp; forms)</code></div><div class="doc"><pre class="plaintext">A threading macro like as-&gt; that always uses the symbol 'it' as the placeholder for the next threaded value:
(it-&gt; 1
      (inc it)
      (+ it 3)
      (/ 10 it))
;=&gt; 2 </pre></div></div><div class="public anchor" id="var-java-version"><h3>java-version</h3><div class="usage"><code>(java-version)</code></div><div class="doc"><pre class="plaintext">Inputs: []
Returns: s/Str</pre></div></div><div class="public anchor" id="var-java-version-matches.3F"><h3>java-version-matches?</h3><div class="usage"><code>(java-version-matches? version-str)</code></div><div class="doc"><pre class="plaintext">Inputs: [version-str :- s/Str]
Returns: s/Bool

Returns true if Java version exactly matches supplied string.</pre></div></div><div class="public anchor" id="var-java-version-min.3F"><h3>java-version-min?</h3><div class="usage"><code>(java-version-min? version-str)</code></div><div class="doc"><pre class="plaintext">Inputs: [version-str :- s/Str]
Returns: s/Bool

Returns true if Java version is at least as great as supplied string.
Sort is by lexicographic (alphabetic) order.</pre></div></div><div class="public anchor" id="var-json-.3Eedn"><h3>json-&gt;edn</h3><div class="usage"><code>(json-&gt;edn arg)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-keep-if"><h3>keep-if</h3><div class="usage"><code>(keep-if pred coll)</code></div><div class="doc"><pre class="plaintext">Returns a vector of items in coll for which (pred item) is true (alias for clojure.core/filter)
</pre></div></div><div class="public anchor" id="var-keyvals"><h3>keyvals</h3><div class="usage"><code>(keyvals m)</code></div><div class="doc"><pre class="plaintext">For any map m, returns the (alternating) keys &amp; values of m as a vector, suitable for reconstructing m via
(apply hash-map (keyvals m)). (keyvals {:a 1 :b 2} =&gt; [:a 1 :b 2] </pre></div></div><div class="public anchor" id="var-keyvals-seq"><h3>keyvals-seq</h3><div class="usage"><code>(keyvals-seq m keys-seq)</code></div><div class="doc"><pre class="plaintext">Like `keyvals`, but only outputs selected keys in the order specified.
</pre></div></div><div class="public anchor" id="var-keyvals-seq*"><h3>keyvals-seq*</h3><div class="usage"><code>(keyvals-seq* ctx m keys-seq)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-kw-.3Eint"><h3>kw-&gt;int</h3><div class="usage"><code>(kw-&gt;int arg)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-kw-.3Estr"><h3>kw-&gt;str</h3><div class="usage"><code>(kw-&gt;str arg)</code></div><div class="doc"><pre class="plaintext">Converts a keyword to a string
</pre></div></div><div class="public anchor" id="var-kw-.3Esym"><h3>kw-&gt;sym</h3><div class="usage"><code>(kw-&gt;sym arg)</code></div><div class="doc"><pre class="plaintext">Converts a keyword to a symbol
</pre></div></div><div class="public anchor" id="var-lazy-cons"><h3>lazy-cons</h3><h4 class="type">macro</h4><div class="usage"><code>(lazy-cons curr-val recursive-call-form)</code></div><div class="doc"><pre class="plaintext">The simple way to create a lazy sequence:
(defn lazy-next-int [n]
  (t/lazy-cons n (lazy-next-int (inc n))))
(def all-ints (lazy-next-int 0)) </pre></div></div><div class="public anchor" id="var-lazy-gen"><h3>lazy-gen</h3><h4 class="type">macro</h4><div class="usage"><code>(lazy-gen &amp; forms)</code></div><div class="doc"><pre class="plaintext">Creates a 'generator function' that returns a lazy seq of results
via `yield` (a la Python).</pre></div></div><div class="public anchor" id="var-let-spy"><h3>let-spy</h3><h4 class="type">macro</h4><div class="usage"><code>(let-spy &amp; forms)</code></div><div class="doc"><pre class="plaintext">An expression (println ...) for use in threading forms (&amp; elsewhere). Evaluates the supplied
expressions, printing both the expression and its value to stdout. Returns the value of the
last expression.</pre></div></div><div class="public anchor" id="var-let-spy-pretty"><h3>let-spy-pretty</h3><h4 class="type">macro</h4><div class="usage"><code>(let-spy-pretty &amp; forms)</code></div><div class="doc"><pre class="plaintext">An expression (println ...) for use in threading forms (&amp; elsewhere). Evaluates the supplied
expressions, printing both the expression and its value to stdout. Returns the value of the
last expression.</pre></div></div><div class="public anchor" id="var-lexical-compare"><h3>lexical-compare</h3><div class="usage"><code>(lexical-compare a b)</code></div><div class="doc"><pre class="plaintext">Performs a lexical comparison of 2 sequences, sorting as follows:
[1]
[1 :a]
[1 :b]
[1 :b 3]
[2]
[3]
[3 :y] </pre></div></div><div class="public anchor" id="var-macro.3F"><h3>macro?</h3><div class="usage"><code>(macro? s)</code></div><div class="doc"><pre class="plaintext">Returns true if a quoted symbol resolves to a macro. Usage:

(println (macro? 'and))  ;=&gt; true </pre></div></div><div class="public anchor" id="var-map-keys"><h3>map-keys</h3><div class="usage"><code>(map-keys map-in tx-fn &amp; tx-args)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-map-let"><h3>map-let</h3><h4 class="type">macro</h4><div class="usage"><code>(map-let bindings &amp; forms)</code></div><div class="doc"><pre class="plaintext">Usage:
  (map-let bindings &amp; forms)

Given bindings and forms like `(map-let [x xs, y ys, ...] (+ x y))`, will iterate over the
collections [xs ys ...] assigning successive values of each collection to [x y ...], respectively.
The local symbols [x y ...] can then be used in `forms` to generate the output mapping.
Will throw if collections are not all of the same length. Not lazy.</pre></div></div><div class="public anchor" id="var-map-let*"><h3>map-let*</h3><h4 class="type">macro</h4><div class="usage"><code>(map-let* context bindings &amp; forms)</code></div><div class="doc"><pre class="plaintext">Usage:  (map-let* ctx bindings &amp; forms)

where ctx is a map with default values:
  {:strict true
   :lazy   false}</pre></div></div><div class="public anchor" id="var-map-vals"><h3>map-vals</h3><div class="usage"><code>(map-vals map-in tx-fn &amp; tx-args)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-matches.3F"><h3>matches?</h3><h4 class="type">macro</h4><div class="usage"><code>(matches? pattern &amp; values)</code></div><div class="doc"><pre class="plaintext">A shortcut to clojure.core.match/match to aid in testing.  Returns true if the data value
matches the pattern value.  Underscores serve as wildcard values. Usage:

  (matches? pattern &amp; values)

sample:

  (matches?  [1 _ 3] [1 2 3] )         ;=&gt; true
  (matches?  {:a _ :b _       :c 3}
             {:a 1 :b [1 2 3] :c 3}
             {:a 2 :b 99      :c 3}
             {:a 3 :b nil     :c 3} )  ;=&gt; true

Note that a wildcald can match either a primitive or a composite value.</pre></div></div><div class="public anchor" id="var-nl"><h3>nl</h3><div class="usage"><code>(nl)</code></div><div class="doc"><pre class="plaintext">Abbreviated name for `newline` 
</pre></div></div><div class="public anchor" id="var-not-empty.3F"><h3>not-empty?</h3><div class="usage"><code>(not-empty? coll)</code></div><div class="doc"><pre class="plaintext">For any collection coll, returns true if coll contains any items; otherwise returns false.
Equivalent to (not (empty? coll)).</pre></div></div><div class="public anchor" id="var-not-nil.3F"><h3>not-nil?</h3><div class="usage"><code>(not-nil? arg)</code></div><div class="doc"><pre class="plaintext">Returns true if arg is not nil; false otherwise. Equivalent to (not (nil? arg)),
or the poorly-named clojure.core/some? </pre></div></div><div class="public anchor" id="var-onlies"><h3>onlies</h3><div class="usage"><code>(onlies coll)</code></div><div class="doc"><pre class="plaintext">Given a sequence of length-1 sequences, returns a sequence of the unwrapped values.
i.e.  (onlies [[1] [2] [3]]) =&gt; [1 2 3]. Equivalent to `(mapv only coll)`.  </pre></div></div><div class="public anchor" id="var-only"><h3>only</h3><div class="usage"><code>(only coll)</code></div><div class="doc"><pre class="plaintext">Ensures that a sequence is of length=1, and returns the only value present.
Throws an exception if the length of the sequence is not one.
Note that, for a length-1 sequence S, (first S), (last S) and (only S) are equivalent.</pre></div></div><div class="public anchor" id="var-only2"><h3>only2</h3><div class="usage"><code>(only2 coll)</code></div><div class="doc"><pre class="plaintext">Given a collection like `[[5]]`, returns `5`.  Equivalent to `(only (only coll))`.
</pre></div></div><div class="public anchor" id="var-only.3F"><h3>only?</h3><div class="usage"><code>(only? coll)</code></div><div class="doc"><pre class="plaintext">Returns true if the collection contains a single item.
</pre></div></div><div class="public anchor" id="var-pair.3F"><h3>pair?</h3><div class="usage"><code>(pair? coll)</code></div><div class="doc"><pre class="plaintext">Returns true if the collection contains exactly 2 items.
</pre></div></div><div class="public anchor" id="var-partition-using"><h3>partition-using</h3><div class="usage"><code>(partition-using pred values)</code></div><div class="doc"><pre class="plaintext">Inputs: [pred :- s/Any values :- ts/List]

Partitions a collection into vector of segments based on a predicate with a collection argument.
The first segment is initialized by removing the first element from `values`, with subsequent
elements similarly transferred as long as `(pred remaining-values)` is falsey. When
`(pred remaining-values)` becomes truthy, the algorithm begins building the next segment.
Thus, the first partition finds the smallest N (&lt; 0 N) such that (pred (drop N values))
is true, and constructs the segment as (take N values). If pred is never satisified,
[values] is returned.</pre></div></div><div class="public anchor" id="var-prepend"><h3>prepend</h3><div class="usage"><code>(prepend &amp; args)</code></div><div class="doc"><pre class="plaintext">Given a sequential object (vector or list), add one or more elements to the beginning
</pre></div></div><div class="public anchor" id="var-pretty"><h3>pretty</h3><div class="usage"><code>(pretty &amp; args)</code></div><div class="doc"><pre class="plaintext">Shortcut to clojure.pprint/pprint. Returns it (1st) argument.
</pre></div></div><div class="public anchor" id="var-pretty-str"><h3>pretty-str</h3><div class="usage"><code>(pretty-str arg)</code></div><div class="doc"><pre class="plaintext">Returns a string that is the result of clojure.pprint/pprint
</pre></div></div><div class="public anchor" id="var-print-versions"><h3>print-versions</h3><div class="usage"><code>(print-versions)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-quad.3F"><h3>quad?</h3><div class="usage"><code>(quad? coll)</code></div><div class="doc"><pre class="plaintext">Returns true if the collection contains exactly 4 items.
</pre></div></div><div class="public anchor" id="var-range-vec"><h3>range-vec</h3><div class="usage"><code>(range-vec &amp; args)</code></div><div class="doc"><pre class="plaintext">An eager version clojure.core/range that always returns its result in a vector.
</pre></div></div><div class="public anchor" id="var-refer-tupelo"><h3>refer-tupelo</h3><div class="usage"><code>(refer-tupelo &amp; args)</code></div><div class="doc"><pre class="plaintext">Refer a number of commonly used tupelo.core functions into the current namespace so they can
be used without namespace qualification.</pre></div></div><div class="public anchor" id="var-rel.3D"><h3>rel=</h3><div class="usage"><code>(rel= val1 val2 &amp; {:as opts})</code></div><div class="doc"><pre class="plaintext">Returns true if 2 double-precision numbers are relatively equal, else false.  Relative equality
is specified as either (1) the N most significant digits are equal, or (2) the absolute
difference is less than a tolerance value.  Input values are coerced to double before comparison.
Example:

  (rel= 123450000 123456789   :digits 4   )  ; true
  (rel= 1         1.001       :tol    0.01)  ; true
</pre></div></div><div class="public anchor" id="var-replace-at"><h3>replace-at</h3><div class="usage"><code>(replace-at coll index elem)</code></div><div class="doc"><pre class="plaintext">Replaces an element in a collection at the specified index.
</pre></div></div><div class="public anchor" id="var-safe-.3E"><h3>safe-&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(safe-&gt; expr &amp; forms)</code></div><div class="doc"><pre class="plaintext">When expr is not nil, threads it into the first form (via -&gt;), and when that result is not nil,
through the next etc.  If result is nil, throw IllegalArgumentException</pre></div></div><div class="public anchor" id="var-seq-.3Estr"><h3>seq-&gt;str</h3><div class="usage"><code>(seq-&gt;str seq-in)</code></div><div class="doc"><pre class="plaintext">Convert a seq into a string (using pr) with a space preceding each value
</pre></div></div><div class="public anchor" id="var-single.3F"><h3>single?</h3><div class="usage"><code>(single? coll)</code></div><div class="doc"><pre class="plaintext">Returns true if the collection contains a single item. Equivalent to `(only? coll)`
</pre></div></div><div class="public anchor" id="var-split-match"><h3>split-match</h3><div class="usage"><code>(split-match coll tgt)</code></div><div class="doc"><pre class="plaintext">Splits a collection src by matching with a sub-sequence tgt of length L.
Finds the first index N such that (= tgt (-&gt;&gt; coll (drop N) (take L))) is true.
Returns a length-2 vector of [ (take N coll) (drop N coll) ].
If no match is found, [ coll [] ] is returned.</pre></div></div><div class="public anchor" id="var-split-using"><h3>split-using</h3><div class="usage"><code>(split-using pred coll)</code></div><div class="doc"><pre class="plaintext">Splits a collection based on a predicate with a collection argument.
Finds the first index N such that (pred (drop N coll)) is true. Returns a length-2 vector
of [ (take N coll) (drop N coll) ]. If pred is never satisified, [ coll [] ] is returned.</pre></div></div><div class="public anchor" id="var-spy"><h3>spy</h3><div class="usage"><code>(spy &amp; args)</code></div><div class="doc"><pre class="plaintext">A form of (println ...) to ease debugging display of either intermediate values in threading
forms or function return values. There are three variants.  Usage:

 (spy :msg &lt;msg-string&gt;)
     This variant is intended for use in either thread-first (-&gt;) or thread-last (-&gt;&gt;)
     forms.  The keyword :msg is used to identify the message string and works equally
     well for both the -&gt; and -&gt;&gt; operators. Spy prints both &lt;msg-string&gt;  and the
     threading value to stdout, then returns the value for further propogation in the
     threading form. For example, both of the following:
         (-&gt;   2
               (+ 3)
               (spy :msg "sum" )
               (* 4))
         (-&gt;&gt;  2
               (+ 3)
               (spy :msg "sum" )
               (* 4))
     will print 'sum =&gt; 5' to stdout.

 (spy &lt;msg-string&gt; &lt;value&gt;)
     This variant is intended for simpler use cases such as function return values.
     Function return value expressions often invoke other functions and cannot be
     easily displayed since (println ...) swallows the return value and returns nil
     itself.  Spy will output both &lt;msg-string&gt; and the value, then return the value
     for use by further processing.  For example, the following:
         (println (* 2
                    (spy "sum" (+ 3 4))))
   will print:
         sum =&gt; 7
         14
   to stdout.

 (spy &lt;value&gt;)
     This variant is intended for use in very simple situations and is the same as the
     2-argument arity where &lt;msg-string&gt; defaults to 'spy'.  For example (spy (+ 2 3))
     prints 'spy =&gt; 5' to stdout.  </pre></div></div><div class="public anchor" id="var-spyx"><h3>spyx</h3><h4 class="type">macro</h4><div class="usage"><code>(spyx &amp; forms)</code></div><div class="doc"><pre class="plaintext">An expression (println ...) for use in threading forms (&amp; elsewhere). Evaluates the supplied
expressions, printing both the expression and its value to stdout. Returns the value of the
last expression.</pre></div></div><div class="public anchor" id="var-spyx-pretty"><h3>spyx-pretty</h3><h4 class="type">macro</h4><div class="usage"><code>(spyx-pretty &amp; forms)</code></div><div class="doc"><pre class="plaintext">Like `spyx` but with pretty printing (clojure.pprint/pprint)
</pre></div></div><div class="public anchor" id="var-spyxx"><h3>spyxx</h3><h4 class="type">macro</h4><div class="usage"><code>(spyxx expr)</code></div><div class="doc"><pre class="plaintext">An expression (println ...) for use in threading forms (&amp; elsewhere). Evaluates the supplied
expression, printing both the expression, its type, and its value to stdout, then returns the value.</pre></div></div><div class="public anchor" id="var-starts-with.3F"><h3>starts-with?</h3><div class="usage"><code>(starts-with? coll tgt-in)</code></div><div class="doc"><pre class="plaintext">Inputs: [coll tgt-in]
Returns: s/Bool

Returns true when the initial elements of coll match those of tgt</pre></div></div><div class="public anchor" id="var-str-.3Echars"><h3>str-&gt;chars</h3><div class="usage"><code>(str-&gt;chars arg)</code></div><div class="doc"><pre class="plaintext">Converts a string to a vector of chars
</pre></div></div><div class="public anchor" id="var-str-.3Ekw"><h3>str-&gt;kw</h3><div class="usage"><code>(str-&gt;kw arg)</code></div><div class="doc"><pre class="plaintext">Converts a string to a keyword
</pre></div></div><div class="public anchor" id="var-str-.3Esym"><h3>str-&gt;sym</h3><div class="usage"><code>(str-&gt;sym arg)</code></div><div class="doc"><pre class="plaintext">Converts a string to a symbol
</pre></div></div><div class="public anchor" id="var-strcat"><h3>strcat</h3><div class="usage"><code>(strcat &amp; args)</code></div><div class="doc"><pre class="plaintext">Recursively concatenate all arguments into a single string result.
</pre></div></div><div class="public anchor" id="var-submap-by-keys"><h3>submap-by-keys</h3><div class="usage"><code>(submap-by-keys map-arg keep-keys &amp; opts)</code></div><div class="doc"><pre class="plaintext">Returns a new map containing entries with the specified keys. Throws for missing keys,
unless `:missing-ok` is specified. Usage:

    (submap-by-keys {:a 1 :b 2} #{:a   }             )  =&gt;  {:a 1}
    (submap-by-keys {:a 1 :b 2} #{:a :z} :missing-ok )  =&gt;  {:a 1}
</pre></div></div><div class="public anchor" id="var-submap-by-vals"><h3>submap-by-vals</h3><div class="usage"><code>(submap-by-vals map-arg keep-vals &amp; opts)</code></div><div class="doc"><pre class="plaintext">Returns a new map containing entries with the specified vals. Throws for missing vals,
unless `:missing-ok` is specified. Usage:

    (submap-by-vals {:a 1 :b 2 :A 1} #{1  }             )  =&gt;  {:a 1 :A 1}
    (submap-by-vals {:a 1 :b 2 :A 1} #{1 9} :missing-ok )  =&gt;  {:a 1 :A 1} </pre></div></div><div class="public anchor" id="var-submap.3F"><h3>submap?</h3><div class="usage"><code>(submap? inner-map outer-map)</code></div><div class="doc"><pre class="plaintext">Returns true if the map entries (key-value pairs) of one map are a subset of the entries of
another map.  Similar to clojure.set/subset?</pre></div></div><div class="public anchor" id="var-submatch.3F"><h3>submatch?</h3><div class="usage"><code>(submatch? smaller larger)</code></div><div class="doc"><pre class="plaintext">Returns true if the first arg is (recursively) a subset/submap/subvec of the 2nd arg
</pre></div></div><div class="public anchor" id="var-sym-.3Ekw"><h3>sym-&gt;kw</h3><div class="usage"><code>(sym-&gt;kw arg)</code></div><div class="doc"><pre class="plaintext">Converts a symbol to a keyword
</pre></div></div><div class="public anchor" id="var-sym-.3Estr"><h3>sym-&gt;str</h3><div class="usage"><code>(sym-&gt;str arg)</code></div><div class="doc"><pre class="plaintext">Converts a symbol to a string
</pre></div></div><div class="public anchor" id="var-thru"><h3>thru</h3><div class="usage"><code>(thru &amp; args)</code></div><div class="doc"><pre class="plaintext">Returns a sequence of integers. Like clojure.core/rng, but is inclusive of the right boundary value. Not lazy. 
</pre></div></div><div class="public anchor" id="var-triple.3F"><h3>triple?</h3><div class="usage"><code>(triple? coll)</code></div><div class="doc"><pre class="plaintext">Returns true if the collection contains exactly 3 items.
</pre></div></div><div class="public anchor" id="var-truthy.3F"><h3>truthy?</h3><div class="usage"><code>(truthy? arg)</code></div><div class="doc"><pre class="plaintext">Returns true if arg is logical true (neither nil nor false); otherwise returns false.
</pre></div></div><div class="public anchor" id="var-unnest"><h3>unnest</h3><div class="usage"><code>(unnest &amp; values)</code></div><div class="doc"><pre class="plaintext">Given any set of arguments including vectors, maps, sets, &amp; scalars, performs a depth-first
recursive walk returning scalar args (int, string, keyword, etc) in a single 1-D vector.</pre></div></div><div class="public anchor" id="var-unwrap"><h3>unwrap</h3><div class="usage"><code>(unwrap data)</code></div><div class="doc"><pre class="plaintext">Works with the `-&gt;vector` function to unwrap vectors/lists to insert
their elements as with the unquote-spicing operator (~@). Examples:

    (-&gt;vector 1 2 3 4 5 6 7 8 9)              =&gt;  [1 2 3 4 5 6 7 8 9]
    (-&gt;vector 1 2 3 (unwrap [4 5 6]) 7 8 9)   =&gt;  [1 2 3 4 5 6 7 8 9] </pre></div></div><div class="public anchor" id="var-val.3D"><h3>val=</h3><div class="usage"><code>(val= &amp; vals)</code></div><div class="doc"><pre class="plaintext">Compares values for equality using clojure.core/=, treating records as plain map values:

(defrecord SampleRec [a b])
(assert (val= (-&gt;SampleRec 1 2) {:a 1 :b 2}))   ; fails for clojure.core/= </pre></div></div><div class="public anchor" id="var-validate"><h3>validate</h3><div class="usage"><code>(validate tst-fn tst-val)</code></div><div class="doc"><pre class="plaintext">(validate tst-fn tst-val)
Used to validate intermediate results. Returns tst-val if the result of
(tst-fn tst-val) is truthy.  Otherwise, throws IllegalStateException.</pre></div></div><div class="public anchor" id="var-validate-map-keys"><h3>validate-map-keys</h3><div class="usage"><code>(validate-map-keys tst-map valid-keys)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-when-clojure-1-8-plus"><h3>when-clojure-1-8-plus</h3><h4 class="type">macro</h4><div class="usage"><code>(when-clojure-1-8-plus &amp; forms)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-when-clojure-1-9-plus"><h3>when-clojure-1-9-plus</h3><h4 class="type">macro</h4><div class="usage"><code>(when-clojure-1-9-plus &amp; forms)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-wild-item.3F"><h3>wild-item?</h3><div class="usage"><code>(wild-item? item)</code></div><div class="doc"><pre class="plaintext">Returns true if any element in a nested collection is the wildcard :*
</pre></div></div><div class="public anchor" id="var-wild-match-ctx.3F"><h3>wild-match-ctx?</h3><div class="usage"><code>(wild-match-ctx? ctx-in pattern &amp; values)</code></div><div class="doc"><pre class="plaintext">Returns true if a pattern is matched by one or more values.  The special keyword :* (colon-star)
in the pattern serves as a wildcard value.  Note that a wildcald can match either a primitive or a
composite value: Usage:

  (wild-match-ctx? ctx pattern &amp; values)

samples:

  (wild-match-ctx? ctx {:a :* :b 2}
                       {:a 1  :b 2})         ;=&gt; true

  (wild-match-ctx? ctx [1 :* 3]
                       [1 2  3]
                       [1 9  3] ))           ;=&gt; true

  (wild-match-ctx? ctx {:a :*       :b 2}
                       {:a [1 2 3]  :b 2})   ;=&gt; true

wild-match? accepts a context map as an optional first argument which defaults to:

  (let [ctx {:submap-ok false
             :subset-ok false
             :subvec-ok false}]
    (wild-match-ctx? ctx pattern values))) </pre></div></div><div class="public anchor" id="var-wild-match.3F"><h3>wild-match?</h3><div class="usage"><code>(wild-match? pattern &amp; values)</code></div><div class="doc"><pre class="plaintext">Simple wrapper for wild-match-ctx? using the default context
</pre></div></div><div class="public anchor" id="var-wild-submatch.3F"><h3>wild-submatch?</h3><div class="usage"><code>(wild-submatch? pattern &amp; values)</code></div><div class="doc"><pre class="plaintext">Simple wrapper for wild-match-ctx? where all types of sub-matching are enabled.
</pre></div></div><div class="public anchor" id="var-with-exception-default"><h3>with-exception-default</h3><h4 class="type">macro</h4><div class="usage"><code>(with-exception-default default-val &amp; forms)</code></div><div class="doc"><pre class="plaintext">Evaluates body &amp; returns its result.  In the event of an exception, default-val is returned
instead of the exception.</pre></div></div><div class="public anchor" id="var-with-spy-enabled"><h3>with-spy-enabled</h3><h4 class="type">macro</h4><div class="usage"><code>(with-spy-enabled tag &amp; forms)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-with-spy-indent"><h3>with-spy-indent</h3><h4 class="type">macro</h4><div class="usage"><code>(with-spy-indent &amp; forms)</code></div><div class="doc"><pre class="plaintext">Increments indentation level of all spy, spyx, or spyxx expressions within the body.
</pre></div></div><div class="public anchor" id="var-xbutlast"><h3>xbutlast</h3><div class="usage"><code>(xbutlast coll)</code></div><div class="doc"><pre class="plaintext">Returns a vector of all but the last value in a list or vector. Throws if empty.
</pre></div></div><div class="public anchor" id="var-xfirst"><h3>xfirst</h3><div class="usage"><code>(xfirst coll)</code></div><div class="doc"><pre class="plaintext">Returns the first value in a list or vector. Throws if empty.
</pre></div></div><div class="public anchor" id="var-xfourth"><h3>xfourth</h3><div class="usage"><code>(xfourth coll)</code></div><div class="doc"><pre class="plaintext">Returns the fourth value in a list or vector. Throws if (&lt; len 4).
</pre></div></div><div class="public anchor" id="var-xlast"><h3>xlast</h3><div class="usage"><code>(xlast coll)</code></div><div class="doc"><pre class="plaintext">Returns the last value in a list or vector. Throws if empty.
</pre></div></div><div class="public anchor" id="var-xrest"><h3>xrest</h3><div class="usage"><code>(xrest coll)</code></div><div class="doc"><pre class="plaintext">Returns the last value in a list or vector. Throws if empty.
</pre></div></div><div class="public anchor" id="var-xreverse"><h3>xreverse</h3><div class="usage"><code>(xreverse coll)</code></div><div class="doc"><pre class="plaintext">Returns all but the last value in a list or vector. Throws if empty.
</pre></div></div><div class="public anchor" id="var-xsecond"><h3>xsecond</h3><div class="usage"><code>(xsecond coll)</code></div><div class="doc"><pre class="plaintext">Returns the second value in a list or vector. Throws if (&lt; len 2).
</pre></div></div><div class="public anchor" id="var-xthird"><h3>xthird</h3><div class="usage"><code>(xthird coll)</code></div><div class="doc"><pre class="plaintext">Returns the third value in a list or vector. Throws if (&lt; len 3).
</pre></div></div><div class="public anchor" id="var-xvec"><h3>xvec</h3><div class="usage"><code>(xvec coll)</code></div><div class="doc"><pre class="plaintext">Converts a collection into a vector. Throws if given nil.
</pre></div></div><div class="public anchor" id="var-yield"><h3>yield</h3><h4 class="type">macro</h4><div class="usage"><code>(yield value)</code></div><div class="doc"><pre class="plaintext">Within a 'generator function' created by `lazy-gen`, populates the
result lazy seq with the supplied value (a la Python). Returns the value.</pre></div></div><div class="public anchor" id="var-yield-all"><h3>yield-all</h3><h4 class="type">macro</h4><div class="usage"><code>(yield-all values)</code></div><div class="doc"><pre class="plaintext">Within a 'generator function' created by `lazy-gen`, populates the
result lazy seq with each item from the supplied collection. Returns the collection.</pre></div></div><div class="public anchor" id="var-zip"><h3>zip</h3><div class="usage"><code>(zip &amp; args)</code></div><div class="doc"><pre class="plaintext">Zips together vectors producing a vector of tuples (like Python zip). Not lazy.
Example:

   (zip [:a :b :c] [1 2 3]) -&gt;  [ [:a 1] [:b 2] [:c 3] ]

 ***** WARNING - will hang for infinite length inputs ***** </pre></div></div><div class="public anchor" id="var-zip*"><h3>zip*</h3><div class="usage"><code>(zip* context &amp; colls)</code></div><div class="doc"><pre class="plaintext">Usage:  (zip* context &amp; colls)
where context is a map with default values:  {:strict true}
Not lazy. </pre></div></div><div class="public anchor" id="var-zip-lazy"><h3>zip-lazy</h3><div class="usage"><code>(zip-lazy &amp; colls)</code></div><div class="doc"><pre class="plaintext">Usage:  (zip-lazy coll1 coll2 ...)
    (zip-lazy xs ys zs) -&gt; [ [x0 y0 z0]
                             [x1 y1 z1]
                             [x2 y2 z2]
                             ... ]

Returns a lazy result. Will truncate to the length of the shortest collection.
A convenience wrapper for `(map vector coll1 coll2 ...)`.  </pre></div></div></div></body></html>