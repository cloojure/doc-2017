<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>tupelo.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Tupelo</span> <span class="project-version">0.9.32</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tupelo</span></div></div></li><li class="depth-2 branch"><a href="tupelo.array.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>array</span></div></a></li><li class="depth-2 branch"><a href="tupelo.async.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>async</span></div></a></li><li class="depth-2 branch"><a href="tupelo.base64.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>base64</span></div></a></li><li class="depth-2 branch"><a href="tupelo.base64url.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>base64url</span></div></a></li><li class="depth-2 branch current"><a href="tupelo.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="tupelo.csv.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>csv</span></div></a></li><li class="depth-2 branch"><a href="tupelo.misc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>misc</span></div></a></li><li class="depth-2 branch"><a href="tupelo.parse.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parse</span></div></a></li><li class="depth-2 branch"><a href="tupelo.schema.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>schema</span></div></a></li><li class="depth-2 branch"><a href="tupelo.string.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>string</span></div></a></li><li class="depth-2 branch"><a href="tupelo.test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></a></li><li class="depth-2 branch"><a href="tupelo.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li><li class="depth-2 branch"><a href="tupelo.x.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>x</span></div></a></li><li class="depth-2 branch"><a href="tupelo.xxx.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>xxx</span></div></a></li><li class="depth-2"><a href="tupelo.y64.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>y64</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="tupelo.core.html#var-*lazy-gen-buffer-size*"><div class="inner"><span>*lazy-gen-buffer-size*</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-append"><div class="inner"><span>append</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-char-seq"><div class="inner"><span>char-seq</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-clip-str"><div class="inner"><span>clip-str</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-clj-.3Ejson"><div class="inner"><span>clj-&gt;json</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-conjv"><div class="inner"><span>conjv</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-contains-elem.3F"><div class="inner"><span>contains-elem?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-contains-key.3F"><div class="inner"><span>contains-key?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-contains-val.3F"><div class="inner"><span>contains-val?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-dissoc-in"><div class="inner"><span>dissoc-in</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-drop-at"><div class="inner"><span>drop-at</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-drop-if"><div class="inner"><span>drop-if</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-falsey.3F"><div class="inner"><span>falsey?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-fetch-in"><div class="inner"><span>fetch-in</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-fibo-nth"><div class="inner"><span>fibo-nth</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-fibo-thru"><div class="inner"><span>fibo-thru</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-fibonacci-seq"><div class="inner"><span>fibonacci-seq</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-flat-vec"><div class="inner"><span>flat-vec</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-forv"><div class="inner"><span>forv</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-forz"><div class="inner"><span>forz</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-glue"><div class="inner"><span>glue</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-grab"><div class="inner"><span>grab</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-has-none.3F"><div class="inner"><span>has-none?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-has-some.3F"><div class="inner"><span>has-some?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-if-java-1-7-plus"><div class="inner"><span>if-java-1-7-plus</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-if-java-1-8-plus"><div class="inner"><span>if-java-1-8-plus</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-increasing-or-equal.3F"><div class="inner"><span>increasing-or-equal?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-increasing.3F"><div class="inner"><span>increasing?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-index-using"><div class="inner"><span>index-using</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-insert-at"><div class="inner"><span>insert-at</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-int-.3Ekw"><div class="inner"><span>int-&gt;kw</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-clojure-1-7-plus.3F"><div class="inner"><span>is-clojure-1-7-plus?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-clojure-1-8-plus.3F"><div class="inner"><span>is-clojure-1-8-plus?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-clojure-1-9-plus.3F"><div class="inner"><span>is-clojure-1-9-plus?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-java-1-7-plus.3F"><div class="inner"><span>is-java-1-7-plus?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-java-1-7.3F"><div class="inner"><span>is-java-1-7?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-java-1-8-plus.3F"><div class="inner"><span>is-java-1-8-plus?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-java-1-8.3F"><div class="inner"><span>is-java-1-8?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-pre-clojure-1-8.3F"><div class="inner"><span>is-pre-clojure-1-8?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-pre-clojure-1-9.3F"><div class="inner"><span>is-pre-clojure-1-9?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-it-.3E"><div class="inner"><span>it-&gt;</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-java-version"><div class="inner"><span>java-version</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-java-version-matches.3F"><div class="inner"><span>java-version-matches?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-java-version-min.3F"><div class="inner"><span>java-version-min?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-json-.3Eclj"><div class="inner"><span>json-&gt;clj</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-keep-if"><div class="inner"><span>keep-if</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-keyvals"><div class="inner"><span>keyvals</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-kw-.3Eint"><div class="inner"><span>kw-&gt;int</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-lazy-cons"><div class="inner"><span>lazy-cons</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-lazy-gen"><div class="inner"><span>lazy-gen</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-mapper"><div class="inner"><span>mapper</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-matches.3F"><div class="inner"><span>matches?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-nl"><div class="inner"><span>nl</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-not-empty.3F"><div class="inner"><span>not-empty?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-not-nil.3F"><div class="inner"><span>not-nil?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-only"><div class="inner"><span>only</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-partition-using"><div class="inner"><span>partition-using</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-prepend"><div class="inner"><span>prepend</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-pretty"><div class="inner"><span>pretty</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-pretty-str"><div class="inner"><span>pretty-str</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-print-versions"><div class="inner"><span>print-versions</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-range-vec"><div class="inner"><span>range-vec</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-refer-tupelo"><div class="inner"><span>refer-tupelo</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-rel.3D"><div class="inner"><span>rel=</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-replace-at"><div class="inner"><span>replace-at</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-safe-.3E"><div class="inner"><span>safe-&gt;</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-select-values"><div class="inner"><span>select-values</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-seq-.3Estr"><div class="inner"><span>seq-&gt;str</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-seqable.3F"><div class="inner"><span>seqable?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-split-match"><div class="inner"><span>split-match</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-split-using"><div class="inner"><span>split-using</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-spy"><div class="inner"><span>spy</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-spy-let"><div class="inner"><span>spy-let</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-spyx"><div class="inner"><span>spyx</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-spyxx"><div class="inner"><span>spyxx</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-starts-with.3F"><div class="inner"><span>starts-with?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-strcat"><div class="inner"><span>strcat</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-submap.3F"><div class="inner"><span>submap?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-third"><div class="inner"><span>third</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-thru"><div class="inner"><span>thru</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-truthy.3F"><div class="inner"><span>truthy?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-validate"><div class="inner"><span>validate</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-when-clojure-1-8-plus"><div class="inner"><span>when-clojure-1-8-plus</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-when-clojure-1-9-plus"><div class="inner"><span>when-clojure-1-9-plus</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-when-not-clojure-1-9-plus"><div class="inner"><span>when-not-clojure-1-9-plus</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-wild-match.3F"><div class="inner"><span>wild-match?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-with-exception-default"><div class="inner"><span>with-exception-default</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-with-spy-indent"><div class="inner"><span>with-spy-indent</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-yield"><div class="inner"><span>yield</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-yield-all"><div class="inner"><span>yield-all</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-zip"><div class="inner"><span>zip</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">tupelo.core</h1><div class="doc"><pre class="plaintext">Tupelo - Making Clojure even sweeter
</pre></div><div class="public anchor" id="var-*lazy-gen-buffer-size*"><h3>*lazy-gen-buffer-size*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Specifies the output channel default buffer size for `lazy-gen` forms
</pre></div></div><div class="public anchor" id="var-append"><h3>append</h3><div class="usage"><code>(append listy &amp; elems)</code></div><div class="doc"><pre class="plaintext">Inputs: [listy :- ts/List &amp; elems :- [s/Any]]
Returns: ts/List

Given a sequential object (vector or list), add one or more elements to the end.</pre></div></div><div class="public anchor" id="var-char-seq"><h3>char-seq</h3><div class="usage"><code>(char-seq start-char stop-char)</code></div><div class="doc"><pre class="plaintext">Given two characters (or numerical equivalents), returns a seq of characters
(inclusive) from the first to the second.  Characters must be in ascending order.</pre></div></div><div class="public anchor" id="var-clip-str"><h3>clip-str</h3><div class="usage"><code>(clip-str nchars &amp; args)</code></div><div class="doc"><pre class="plaintext">Converts all args to single string and clips any characters beyond nchars.
</pre></div></div><div class="public anchor" id="var-clj-.3Ejson"><h3>clj-&gt;json</h3><div class="usage"><code>(clj-&gt;json arg)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-conjv"><h3>conjv</h3><h4 class="deprecated">deprecated</h4><div class="usage"><code>(conjv base-coll value)</code><code>(conjv base-coll value &amp; values)</code></div><div class="doc"><pre class="plaintext">Inputs: ([base-coll :- [s/Any] value :- s/Any] [base-coll :- [s/Any] value :- s/Any &amp; values :- [s/Any]])
Returns: [s/Any]

***** DEPRECATED:  replaced by tupelo.core/append *****

 Given base-coll and and one or more values, converts base-coll to a vector and then appends the values.
 The result is always returned as a vector. Note that `(conjv nil 5)` -&gt; `[5]`</pre></div></div><div class="public anchor" id="var-contains-elem.3F"><h3>contains-elem?</h3><div class="usage"><code>(contains-elem? coll elem)</code></div><div class="doc"><pre class="plaintext">Inputs: [coll :- s/Any elem :- s/Any]
Returns: s/Bool

For any collection coll &amp; element tgt, returns true if coll contains at least one
instance of tgt; otherwise returns false. Note that, for maps, each element is a
vector (i.e MapEntry) of the form [key value].</pre></div></div><div class="public anchor" id="var-contains-key.3F"><h3>contains-key?</h3><div class="usage"><code>(contains-key? map-or-set elem)</code></div><div class="doc"><pre class="plaintext">Inputs: [map-or-set :- (s/pred (fn* [p1__14860#] (or (map? p1__14860#) (set? p1__14860#)))) elem :- s/Any]
Returns: s/Bool

For any map or set, returns true if elem is a map key or set element, respectively</pre></div></div><div class="public anchor" id="var-contains-val.3F"><h3>contains-val?</h3><div class="usage"><code>(contains-val? map elem)</code></div><div class="doc"><pre class="plaintext">Inputs: [map :- ts/Map elem :- s/Any]
Returns: s/Bool

For any map, returns true if elem is present in the map for at least one key.</pre></div></div><div class="public anchor" id="var-dissoc-in"><h3>dissoc-in</h3><div class="usage"><code>(dissoc-in the-map keys-vec)</code></div><div class="doc"><pre class="plaintext">Inputs: [the-map :- ts/KeyMap keys-vec :- [s/Keyword]]
Returns: s/Any

A sane version of dissoc-in that will not delete intermediate keys.
 When invoked as (dissoc-in the-map [:k1 :k2 :k3... :kZ]), acts like
 (clojure.core/update-in the-map [:k1 :k2 :k3...] dissoc :kZ). That is, only
 the map entry containing the last key :kZ is removed, and all map entries
 higher than kZ in the hierarchy are unaffected.</pre></div></div><div class="public anchor" id="var-drop-at"><h3>drop-at</h3><div class="usage"><code>(drop-at coll index)</code></div><div class="doc"><pre class="plaintext">Inputs: [coll :- ts/List index :- s/Int]
Returns: ts/List

Removes an element from a collection at the specified index.</pre></div></div><div class="public anchor" id="var-drop-if"><h3>drop-if</h3><div class="usage"><code>(drop-if pred coll)</code></div><div class="doc"><pre class="plaintext">Returns a vector of items in coll for which (pred item) is false (alias for clojure.core/remove)
</pre></div></div><div class="public anchor" id="var-falsey.3F"><h3>falsey?</h3><div class="usage"><code>(falsey? arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [arg :- s/Any]
Returns: s/Bool

Returns true if arg is logical false (either nil or false); otherwise returns false. Equivalent
 to (not (truthy? arg)).</pre></div></div><div class="public anchor" id="var-fetch-in"><h3>fetch-in</h3><div class="usage"><code>(fetch-in the-map keys-vec)</code></div><div class="doc"><pre class="plaintext">Inputs: [the-map :- ts/KeyMap keys-vec :- [s/Keyword]]
Returns: s/Any

A fail-fast version of clojure.core/get-in. When invoked as (fetch-in the-map keys-vec),
 returns the value associated with keys-vec as for (clojure.core/get-in the-map keys-vec).
 Throws an Exception if the path keys-vec is not present in the-map.</pre></div></div><div class="public anchor" id="var-fibo-nth"><h3>fibo-nth</h3><div class="usage"><code>(fibo-nth N)</code></div><div class="doc"><pre class="plaintext">Returns the N'th Fibonacci number (zero-based). Note that
N=91 corresponds to approx 2^62</pre></div></div><div class="public anchor" id="var-fibo-thru"><h3>fibo-thru</h3><div class="usage"><code>(fibo-thru limit)</code></div><div class="doc"><pre class="plaintext">Returns a vector of Fibonacci numbers up to limit (inclusive). Note that a
2^62  corresponds to 91'st Fibonacci number.</pre></div></div><div class="public anchor" id="var-fibonacci-seq"><h3>fibonacci-seq</h3><div class="usage"><code>(fibonacci-seq)</code></div><div class="doc"><pre class="plaintext">A lazy seq of Fibonacci numbers (memoized).
</pre></div></div><div class="public anchor" id="var-flat-vec"><h3>flat-vec</h3><div class="usage"><code>(flat-vec &amp; args)</code></div><div class="doc"><pre class="plaintext">Accepts any number of nested args and returns the flattened result as a vector.
</pre></div></div><div class="public anchor" id="var-forv"><h3>forv</h3><h4 class="type">macro</h4><div class="usage"><code>(forv &amp; body)</code></div><div class="doc"><pre class="plaintext">Like clojure.core/for but returns results in a vector.   Not lazy.
</pre></div></div><div class="public anchor" id="var-forz"><h3>forz</h3><h4 class="type">macro</h4><div class="usage"><code>(forz &amp; body)</code></div><div class="doc"><pre class="plaintext">Lazy version of tupelo/forv. Equivalent to clojure.core/for.
</pre></div></div><div class="public anchor" id="var-glue"><h3>glue</h3><div class="usage"><code>(glue &amp; colls)</code></div><div class="doc"><pre class="plaintext">Glues together like collections:

  (glue [1 2] [3 4] [5 6])                -&gt; [1 2 3 4 5 6]
  (glue {:a 1} {:b 2} {:c 3})             -&gt; {:a 1 :c 3 :b 2}
  (glue #{1 2} #{3 4} #{6 5})             -&gt; #{1 2 6 5 3 4}
  (glue "I" " like " \a " nap!" )  -&gt; "I like a nap!"

If you want to convert to a sorted set or map, just put an empty one first:

  (glue (sorted-map) {:a 1} {:b 2} {:c 3})      -&gt; {:a 1 :b 2 :c 3}
  (glue (sorted-set) #{1 2} #{3 4} #{6 5})      -&gt; #{1 2 3 4 5 6}

If there are duplicate keys when using glue for maps or sets, then "the last one wins":

  (glue {:band :VanHalen :singer :Dave}  {:singer :Sammy}) </pre></div></div><div class="public anchor" id="var-grab"><h3>grab</h3><div class="usage"><code>(grab the-key the-map)</code></div><div class="doc"><pre class="plaintext">Inputs: [the-key :- s/Keyword the-map :- ts/KeyMap]
Returns: s/Any

A fail-fast version of keyword/map lookup.  When invoked as (grab :the-key the-map),
 returns the value associated with :the-key as for (clojure.core/get the-map :the-key).
 Throws an Exception if :the-key is not present in the-map.</pre></div></div><div class="public anchor" id="var-has-none.3F"><h3>has-none?</h3><div class="usage"><code>(has-none? pred coll)</code></div><div class="doc"><pre class="plaintext">Inputs: [pred :- s/Any coll :- [s/Any]]
Returns: s/Bool

For any predicate pred &amp; collection coll, returns false if (pred x) is logical true for at least one x in
 coll; otherwise returns true.  Equivalent to clojure.core/not-any?, but inverse of has-some?.</pre></div></div><div class="public anchor" id="var-has-some.3F"><h3>has-some?</h3><div class="usage"><code>(has-some? pred coll)</code></div><div class="doc"><pre class="plaintext">Inputs: [pred :- s/Any coll :- [s/Any]]
Returns: s/Bool

For any predicate pred &amp; collection coll, returns true if (pred x) is logical true for at least one x in
 coll; otherwise returns false.  Like clojure.core/some, but returns only true or false.</pre></div></div><div class="public anchor" id="var-if-java-1-7-plus"><h3>if-java-1-7-plus</h3><h4 class="type">macro</h4><div class="usage"><code>(if-java-1-7-plus if-form else-form)</code></div><div class="doc"><pre class="plaintext">If JVM is Java 1.7 or higher, evaluates if-form into code. Otherwise, evaluates else-form.
</pre></div></div><div class="public anchor" id="var-if-java-1-8-plus"><h3>if-java-1-8-plus</h3><h4 class="type">macro</h4><div class="usage"><code>(if-java-1-8-plus if-form else-form)</code></div><div class="doc"><pre class="plaintext">If JVM is Java 1.8 or higher, evaluates if-form into code. Otherwise, evaluates else-form.
</pre></div></div><div class="public anchor" id="var-increasing-or-equal.3F"><h3>increasing-or-equal?</h3><div class="usage"><code>(increasing-or-equal? a b)</code></div><div class="doc"><pre class="plaintext">Inputs: [a :- ts/List b :- ts/List]
Returns: s/Bool

Returns true iff the vectors are in (strictly) lexicographically increasing order
  [1 2]  [1]        -&gt; false
  [1 2]  [1 1]      -&gt; false
  [1 2]  [1 2]      -&gt; true
  [1 2]  [1 2 nil]  -&gt; true
  [1 2]  [1 2 3]    -&gt; true
  [1 2]  [1 3]      -&gt; true
  [1 2]  [2 1]      -&gt; true
  [1 2]  [2]        -&gt; true
</pre></div></div><div class="public anchor" id="var-increasing.3F"><h3>increasing?</h3><div class="usage"><code>(increasing? a b)</code></div><div class="doc"><pre class="plaintext">Inputs: [a :- ts/List b :- ts/List]
Returns: s/Bool

Returns true iff the vectors are in (strictly) lexicographically increasing order
  [1 2]  [1]        -&gt; false
  [1 2]  [1 1]      -&gt; false
  [1 2]  [1 2]      -&gt; false
  [1 2]  [1 2 nil]  -&gt; true
  [1 2]  [1 2 3]    -&gt; true
  [1 2]  [1 3]      -&gt; true
  [1 2]  [2 1]      -&gt; true
  [1 2]  [2]        -&gt; true
</pre></div></div><div class="public anchor" id="var-index-using"><h3>index-using</h3><div class="usage"><code>(index-using pred coll)</code></div><div class="doc"><pre class="plaintext">Finds the first index N where (&lt; N (count coll)) such that (pred (drop N coll)) is truthy.
Returns `nil` if no match found.</pre></div></div><div class="public anchor" id="var-insert-at"><h3>insert-at</h3><div class="usage"><code>(insert-at coll index elem)</code></div><div class="doc"><pre class="plaintext">Inputs: [coll :- ts/List index :- s/Int elem :- s/Any]
Returns: ts/List

Inserts an element into a collection at the specified index.</pre></div></div><div class="public anchor" id="var-int-.3Ekw"><h3>int-&gt;kw</h3><div class="usage"><code>(int-&gt;kw arg)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-clojure-1-7-plus.3F"><h3>is-clojure-1-7-plus?</h3><div class="usage"><code>(is-clojure-1-7-plus?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-clojure-1-8-plus.3F"><h3>is-clojure-1-8-plus?</h3><div class="usage"><code>(is-clojure-1-8-plus?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-clojure-1-9-plus.3F"><h3>is-clojure-1-9-plus?</h3><div class="usage"><code>(is-clojure-1-9-plus?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-java-1-7-plus.3F"><h3>is-java-1-7-plus?</h3><div class="usage"><code>(is-java-1-7-plus?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-java-1-7.3F"><h3>is-java-1-7?</h3><div class="usage"><code>(is-java-1-7?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-java-1-8-plus.3F"><h3>is-java-1-8-plus?</h3><div class="usage"><code>(is-java-1-8-plus?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-java-1-8.3F"><h3>is-java-1-8?</h3><div class="usage"><code>(is-java-1-8?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-pre-clojure-1-8.3F"><h3>is-pre-clojure-1-8?</h3><div class="usage"><code>(is-pre-clojure-1-8?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-pre-clojure-1-9.3F"><h3>is-pre-clojure-1-9?</h3><div class="usage"><code>(is-pre-clojure-1-9?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-it-.3E"><h3>it-&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(it-&gt; expr &amp; forms)</code></div><div class="doc"><pre class="plaintext">A threading macro like as-&gt; that always uses the symbol 'it' as the placeholder for the next threaded value:
(it-&gt; 1
      (inc it)
      (+ it 3)
      (/ 10 it))
;=&gt; 2
</pre></div></div><div class="public anchor" id="var-java-version"><h3>java-version</h3><div class="usage"><code>(java-version)</code></div><div class="doc"><pre class="plaintext">Inputs: []
Returns: s/Str</pre></div></div><div class="public anchor" id="var-java-version-matches.3F"><h3>java-version-matches?</h3><div class="usage"><code>(java-version-matches? version-str)</code></div><div class="doc"><pre class="plaintext">Inputs: [version-str :- s/Str]
Returns: s/Bool

Returns true if Java version exactly matches supplied string.</pre></div></div><div class="public anchor" id="var-java-version-min.3F"><h3>java-version-min?</h3><div class="usage"><code>(java-version-min? version-str)</code></div><div class="doc"><pre class="plaintext">Inputs: [version-str :- s/Str]
Returns: s/Bool

Returns true if Java version is at least as great as supplied string.
Sort is by lexicographic (alphabetic) order.</pre></div></div><div class="public anchor" id="var-json-.3Eclj"><h3>json-&gt;clj</h3><div class="usage"><code>(json-&gt;clj arg)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-keep-if"><h3>keep-if</h3><div class="usage"><code>(keep-if pred coll)</code></div><div class="doc"><pre class="plaintext">Returns a vector of items in coll for which (pred item) is true (alias for clojure.core/filter)
</pre></div></div><div class="public anchor" id="var-keyvals"><h3>keyvals</h3><div class="usage"><code>(keyvals m)</code></div><div class="doc"><pre class="plaintext">For any map m, returns the (alternating) keys &amp; values of m as a vector, suitable for reconstructing m via
(apply hash-map (keyvals m)). (keyvals {:a 1 :b 2} =&gt; [:a 1 :b 2] </pre></div></div><div class="public anchor" id="var-kw-.3Eint"><h3>kw-&gt;int</h3><div class="usage"><code>(kw-&gt;int arg)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-lazy-cons"><h3>lazy-cons</h3><h4 class="type">macro</h4><div class="usage"><code>(lazy-cons curr-val next-form)</code></div><div class="doc"><pre class="plaintext">The simple way to create a lazy sequence:
(defn lazy-next-int [n]
  (t/lazy-cons n (lazy-next-int (inc n))))
(def all-ints (lazy-next-int 0)) </pre></div></div><div class="public anchor" id="var-lazy-gen"><h3>lazy-gen</h3><h4 class="type">macro</h4><div class="usage"><code>(lazy-gen &amp; forms)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-mapper"><h3>mapper</h3><div class="usage"><code>(mapper &amp; args)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-matches.3F"><h3>matches?</h3><h4 class="type">macro</h4><div class="usage"><code>(matches? pattern &amp; values)</code></div><div class="doc"><pre class="plaintext">A shortcut to clojure.core.match/match to aid in testing.  Returns true if the data value
matches the pattern value.  Underscores serve as wildcard values. Usage:

  (matches? pattern &amp; values)

sample:

  (matches?  [1 _ 3] [1 2 3] )         ;=&gt; true
  (matches?  {:a _ :b _       :c 3}
             {:a 1 :b [1 2 3] :c 3}
             {:a 2 :b 99      :c 3}
             {:a 3 :b nil     :c 3} )  ;=&gt; true

Note that a wildcald can match either a primitive or a composite value.</pre></div></div><div class="public anchor" id="var-nl"><h3>nl</h3><div class="usage"><code>(nl)</code></div><div class="doc"><pre class="plaintext">Abbreviated name for `newline` 
</pre></div></div><div class="public anchor" id="var-not-empty.3F"><h3>not-empty?</h3><div class="usage"><code>(not-empty? coll)</code></div><div class="doc"><pre class="plaintext">Inputs: [coll]
Returns: s/Bool

For any collection coll, returns true if coll contains any items; otherwise returns false.
 Equivalent to (not (empty? coll)).</pre></div></div><div class="public anchor" id="var-not-nil.3F"><h3>not-nil?</h3><div class="usage"><code>(not-nil? arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [arg :- s/Any]
Returns: s/Bool

Returns true if arg is not nil; false otherwise. Equivalent to (not (nil? arg)),
 or the poorly-named clojure.core/some? </pre></div></div><div class="public anchor" id="var-only"><h3>only</h3><div class="usage"><code>(only seqable-arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [seqable-arg :- ts/List]
Returns: s/Any

(only seqable-arg)
Ensures that a sequence is of length=1, and returns the only value present.
Throws an exception if the length of the sequence is not one.
Note that, for a length-1 sequence S, (first S), (last S) and (only S) are equivalent.</pre></div></div><div class="public anchor" id="var-partition-using"><h3>partition-using</h3><div class="usage"><code>(partition-using pred values)</code></div><div class="doc"><pre class="plaintext">Inputs: [pred :- s/Any values :- ts/List]

Partitions a collection into vector of segments based on a predicate with a collection argument.
The first segment is initialized by removing the first element from `values`, with subsequent
elements similarly transferred as long as `(pred remaining-values)` is falsey. When
`(pred remaining-values)` becomes truthy, the algorithm begins building the next segment.
Thus, the first partition finds the smallest N (&lt; 0 N) such that (pred (drop N values))
is true, and constructs the segment as (take N values). If pred is never satisified,
[values] is returned.</pre></div></div><div class="public anchor" id="var-prepend"><h3>prepend</h3><div class="usage"><code>(prepend &amp; args)</code></div><div class="doc"><pre class="plaintext">Inputs: [&amp; args]
Returns: ts/List

Given a sequential object (vector or list), add one or more elements to the beginning</pre></div></div><div class="public anchor" id="var-pretty"><h3>pretty</h3><div class="usage"><code>(pretty &amp; args)</code></div><div class="doc"><pre class="plaintext">Shortcut to clojure.pprint/pprint
</pre></div></div><div class="public anchor" id="var-pretty-str"><h3>pretty-str</h3><div class="usage"><code>(pretty-str arg)</code></div><div class="doc"><pre class="plaintext">Returns a string that is the result of clojure.pprint/pprint
</pre></div></div><div class="public anchor" id="var-print-versions"><h3>print-versions</h3><div class="usage"><code>(print-versions)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-range-vec"><h3>range-vec</h3><div class="usage"><code>(range-vec &amp; args)</code></div><div class="doc"><pre class="plaintext">An eager version clojure.core/range that always returns its result in a vector.
</pre></div></div><div class="public anchor" id="var-refer-tupelo"><h3>refer-tupelo</h3><div class="usage"><code>(refer-tupelo)</code></div><div class="doc"><pre class="plaintext">Refer a number of commonly used tupelo.core functions into the current namespace so they can
be used without namespace qualification.</pre></div></div><div class="public anchor" id="var-rel.3D"><h3>rel=</h3><div class="usage"><code>(rel= val1 val2 &amp; {:as opts})</code></div><div class="doc"><pre class="plaintext">Returns true if 2 double-precision numbers are relatively equal, else false.  Relative equality
is specified as either (1) the N most significant digits are equal, or (2) the absolute
difference is less than a tolerance value.  Input values are coerced to double before comparison.
Example:

  (rel= 123450000 123456789   :digits 4   )  ; true
  (rel= 1         1.001       :tol    0.01)  ; true
</pre></div></div><div class="public anchor" id="var-replace-at"><h3>replace-at</h3><div class="usage"><code>(replace-at coll index elem)</code></div><div class="doc"><pre class="plaintext">Inputs: [coll :- ts/List index :- s/Int elem :- s/Any]
Returns: ts/List

Replaces an element in a collection at the specified index.</pre></div></div><div class="public anchor" id="var-safe-.3E"><h3>safe-&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(safe-&gt; expr &amp; forms)</code></div><div class="doc"><pre class="plaintext">When expr is not nil, threads it into the first form (via -&gt;), and when that result is not nil,
through the next etc.  If result is nil, throw IllegalArgumentException</pre></div></div><div class="public anchor" id="var-select-values"><h3>select-values</h3><div class="usage"><code>(select-values map keys)</code></div><div class="doc"><pre class="plaintext">Inputs: [map :- ts/KeyMap keys :- [s/Keyword]]
Returns: ts/List

Returns a vector of values for each key, in the order specified.</pre></div></div><div class="public anchor" id="var-seq-.3Estr"><h3>seq-&gt;str</h3><div class="usage"><code>(seq-&gt;str seq-in)</code></div><div class="doc"><pre class="plaintext">Convert a seq into a string (using pr) with a space preceding each value
</pre></div></div><div class="public anchor" id="var-seqable.3F"><h3>seqable?</h3><h4 class="deprecated">deprecated in 1.9.0-alpha5</h4><div class="usage"><code>(seqable? x)</code></div><div class="doc"><pre class="plaintext">Returns true if (seq x) will succeed, false otherwise.
</pre></div></div><div class="public anchor" id="var-split-match"><h3>split-match</h3><div class="usage"><code>(split-match coll tgt)</code></div><div class="doc"><pre class="plaintext">Splits a collection src by matching with a sub-sequence tgt of length L.
Finds the first index N such that (= tgt (-&gt;&gt; coll (drop N) (take L))) is true.
Returns a length-2 vector of [ (take N coll) (drop N coll) ].
If no match is found, [ coll [] ] is returned.</pre></div></div><div class="public anchor" id="var-split-using"><h3>split-using</h3><div class="usage"><code>(split-using pred coll)</code></div><div class="doc"><pre class="plaintext">Splits a collection based on a predicate with a collection argument.
Finds the first index N such that (pred (drop N coll)) is true. Returns a length-2 vector
of [ (take N coll) (drop N coll) ]. If pred is never satisified, [ coll [] ] is returned.</pre></div></div><div class="public anchor" id="var-spy"><h3>spy</h3><div class="usage"><code>(spy arg1 arg2 arg3)</code><code>(spy msg value)</code><code>(spy value)</code></div><div class="doc"><pre class="plaintext">A form of (println ...) to ease debugging display of either intermediate values in threading
forms or function return values. There are three variants.  Usage:

 (spy :msg &lt;msg-string&gt;)
     This variant is intended for use in either thread-first (-&gt;) or thread-last (-&gt;&gt;)
     forms.  The keyword :msg is used to identify the message string and works equally
     well for both the -&gt; and -&gt;&gt; operators. Spy prints both &lt;msg-string&gt;  and the
     threading value to stdout, then returns the value for further propogation in the
     threading form. For example, both of the following:
         (-&gt;   2
               (+ 3)
               (spy :msg "sum" )
               (* 4))
         (-&gt;&gt;  2
               (+ 3)
               (spy :msg "sum" )
               (* 4))
     will print 'sum =&gt; 5' to stdout.

 (spy &lt;msg-string&gt; &lt;value&gt;)
     This variant is intended for simpler use cases such as function return values.
     Function return value expressions often invoke other functions and cannot be
     easily displayed since (println ...) swallows the return value and returns nil
     itself.  Spy will output both &lt;msg-string&gt; and the value, then return the value
     for use by further processing.  For example, the following:
         (println (* 2
                    (spy "sum" (+ 3 4))))
   will print:
         sum =&gt; 7
         14
   to stdout.

 (spy &lt;value&gt;)
     This variant is intended for use in very simple situations and is the same as the
     2-argument arity where &lt;msg-string&gt; defaults to 'spy'.  For example (spy (+ 2 3))
     prints 'spy =&gt; 5' to stdout.  </pre></div></div><div class="public anchor" id="var-spy-let"><h3>spy-let</h3><h4 class="type">macro</h4><div class="usage"><code>(spy-let &amp; exprs)</code></div><div class="doc"><pre class="plaintext">An expression (println ...) for use in threading forms (&amp; elsewhere). Evaluates the supplied
expressions, printing both the expression and its value to stdout. Returns the value of the
last expression.</pre></div></div><div class="public anchor" id="var-spyx"><h3>spyx</h3><h4 class="type">macro</h4><div class="usage"><code>(spyx &amp; exprs)</code></div><div class="doc"><pre class="plaintext">An expression (println ...) for use in threading forms (&amp; elsewhere). Evaluates the supplied
expressions, printing both the expression and its value to stdout. Returns the value of the
last expression.</pre></div></div><div class="public anchor" id="var-spyxx"><h3>spyxx</h3><h4 class="type">macro</h4><div class="usage"><code>(spyxx expr)</code></div><div class="doc"><pre class="plaintext">An expression (println ...) for use in threading forms (&amp; elsewhere). Evaluates the supplied
expression, printing both the expression, its type, and its value to stdout, then returns the value.</pre></div></div><div class="public anchor" id="var-starts-with.3F"><h3>starts-with?</h3><div class="usage"><code>(starts-with? coll tgt)</code></div><div class="doc"><pre class="plaintext">Inputs: [coll tgt]
Returns: s/Bool

Returns true when the initial elements of coll match those of tgt</pre></div></div><div class="public anchor" id="var-strcat"><h3>strcat</h3><div class="usage"><code>(strcat &amp; args)</code></div><div class="doc"><pre class="plaintext">Recursively concatenate all arguments into a single string result.
</pre></div></div><div class="public anchor" id="var-submap.3F"><h3>submap?</h3><div class="usage"><code>(submap? inner-map outer-map)</code></div><div class="doc"><pre class="plaintext">Inputs: [inner-map :- {s/Any s/Any} outer-map :- {s/Any s/Any}]
Returns: Boolean

Returns true if the map entries (key-value pairs) of one map are a subset of the entries of
 another map.  Similar to clojure.set/subset?</pre></div></div><div class="public anchor" id="var-third"><h3>third</h3><div class="usage"><code>(third seqable-arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [seqable-arg :- ts/List]
Returns: s/Any

Returns the third item in a collection, or nil if fewer than three items are present. </pre></div></div><div class="public anchor" id="var-thru"><h3>thru</h3><div class="usage"><code>(thru end)</code><code>(thru start end)</code><code>(thru start end step)</code></div><div class="doc"><pre class="plaintext">Returns a sequence of integers. Like clojure.core/rng, but is inclusive of the right boundary value. Not lazy. 
</pre></div></div><div class="public anchor" id="var-truthy.3F"><h3>truthy?</h3><div class="usage"><code>(truthy? arg)</code></div><div class="doc"><pre class="plaintext">Returns true if arg is logical true (neither nil nor false); otherwise returns false.
</pre></div></div><div class="public anchor" id="var-validate"><h3>validate</h3><div class="usage"><code>(validate tstfn tstval)</code></div><div class="doc"><pre class="plaintext">(validate tstfn tstval)
Used to validate intermediate results. Returns tstval if the result of
(tstfn tstval) is truthy.  Otherwise, throws IllegalStateException.</pre></div></div><div class="public anchor" id="var-when-clojure-1-8-plus"><h3>when-clojure-1-8-plus</h3><h4 class="type">macro</h4><div class="usage"><code>(when-clojure-1-8-plus &amp; forms)</code></div><div class="doc"><pre class="plaintext">Wraps code that should only be included for Clojure 1.8 or higher.  Otherwise, code is supressed.
</pre></div></div><div class="public anchor" id="var-when-clojure-1-9-plus"><h3>when-clojure-1-9-plus</h3><h4 class="type">macro</h4><div class="usage"><code>(when-clojure-1-9-plus &amp; forms)</code></div><div class="doc"><pre class="plaintext">Wraps code that should only be included for Clojure 1.9 or higher.  Otherwise, code is supressed.
</pre></div></div><div class="public anchor" id="var-when-not-clojure-1-9-plus"><h3>when-not-clojure-1-9-plus</h3><h4 class="type">macro</h4><div class="usage"><code>(when-not-clojure-1-9-plus &amp; forms)</code></div><div class="doc"><pre class="plaintext">Wraps code that should only be included for Clojure versions prior to 1.9.  Otherwise, code is supressed.
</pre></div></div><div class="public anchor" id="var-wild-match.3F"><h3>wild-match?</h3><div class="usage"><code>(wild-match? pattern &amp; values)</code></div><div class="doc"><pre class="plaintext">Returns true if a pattern is matched by one or more values.  The special keyword :* (colon-star)
in the pattern serves as a wildcard value.  Note that a wildcald can match either a primitive or a
composite value: Usage:

  (wild-match? pattern &amp; values)

samples:

  (wild-match?  {:a :* :b 2}
                {:a 1  :b 2})         ;=&gt; true

  (wild-match?  [1 :* 3]
                [1 2  3]
                [1 9  3] ))           ;=&gt; true

  (wild-match?  {:a :*       :b 2}
                {:a [1 2 3]  :b 2})   ;=&gt; true </pre></div></div><div class="public anchor" id="var-with-exception-default"><h3>with-exception-default</h3><h4 class="type">macro</h4><div class="usage"><code>(with-exception-default default-val &amp; body)</code></div><div class="doc"><pre class="plaintext">Evaluates body &amp; returns its result.  In the event of an exception, default-val is returned
instead of the exception.</pre></div></div><div class="public anchor" id="var-with-spy-indent"><h3>with-spy-indent</h3><h4 class="type">macro</h4><div class="usage"><code>(with-spy-indent &amp; body)</code></div><div class="doc"><pre class="plaintext">Increments indentation level of all spy, spyx, or spyxx expressions within the body.
</pre></div></div><div class="public anchor" id="var-yield"><h3>yield</h3><h4 class="type">macro</h4><div class="usage"><code>(yield value)</code></div><div class="doc"><pre class="plaintext">Within a 'generator function' created by `lazy-gen`, populates the
result lazy seq with the supplied value (a la Python). Returns the value.</pre></div></div><div class="public anchor" id="var-yield-all"><h3>yield-all</h3><h4 class="type">macro</h4><div class="usage"><code>(yield-all values)</code></div><div class="doc"><pre class="plaintext">Within a 'generator function' created by `lazy-gen`, populates the
result lazy seq with each item from the supplied collection. Returns the collection.</pre></div></div><div class="public anchor" id="var-zip"><h3>zip</h3><div class="usage"><code>(zip &amp; args)</code></div><div class="doc"><pre class="plaintext"></pre></div></div></div></body></html>