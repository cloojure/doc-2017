<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>tupelo.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Tupelo</span> <span class="project-version">0.9.52</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tupelo</span></div></div></li><li class="depth-2 branch"><a href="tupelo.array.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>array</span></div></a></li><li class="depth-2 branch"><a href="tupelo.async.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>async</span></div></a></li><li class="depth-2 branch"><a href="tupelo.base64.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>base64</span></div></a></li><li class="depth-2 branch"><a href="tupelo.base64url.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>base64url</span></div></a></li><li class="depth-2 branch current"><a href="tupelo.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="tupelo.csv.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>csv</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>deprecated</span></div></div></li><li class="depth-3"><a href="tupelo.deprecated.misc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>misc</span></div></a></li><li class="depth-2 branch"><a href="tupelo.enlive.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>enlive</span></div></a></li><li class="depth-2 branch"><a href="tupelo.forest.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>forest</span></div></a></li><li class="depth-2 branch"><a href="tupelo.gen.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>gen</span></div></a></li><li class="depth-2 branch"><a href="tupelo.misc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>misc</span></div></a></li><li class="depth-2 branch"><a href="tupelo.parse.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>parse</span></div></a></li><li class="depth-2 branch"><a href="tupelo.schema.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>schema</span></div></a></li><li class="depth-2 branch"><a href="tupelo.string.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>string</span></div></a></li><li class="depth-2 branch"><a href="tupelo.test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></a></li><li class="depth-2 branch"><a href="tupelo.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li><li class="depth-2 branch"><a href="tupelo.xxx.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>xxx</span></div></a></li><li class="depth-2"><a href="tupelo.y64.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>y64</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="tupelo.core.html#var--.3Evec"><div class="inner"><span>-&gt;vec</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var--main"><div class="inner"><span>-main</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-append"><div class="inner"><span>append</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-char-seq"><div class="inner"><span>char-seq</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-check-spy-enabled"><div class="inner"><span>check-spy-enabled</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-clip-str"><div class="inner"><span>clip-str</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-clj-.3Ejson"><div class="inner"><span>clj-&gt;json</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-conjv"><div class="inner"><span>conjv</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-contains-elem.3F"><div class="inner"><span>contains-elem?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-contains-key.3F"><div class="inner"><span>contains-key?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-contains-val.3F"><div class="inner"><span>contains-val?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-dissoc-in"><div class="inner"><span>dissoc-in</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-drop-at"><div class="inner"><span>drop-at</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-drop-if"><div class="inner"><span>drop-if</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-falsey.3F"><div class="inner"><span>falsey?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-fetch"><div class="inner"><span>fetch</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-fetch-in"><div class="inner"><span>fetch-in</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-fibo-nth"><div class="inner"><span>fibo-nth</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-fibo-thru"><div class="inner"><span>fibo-thru</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-fibonacci-seq"><div class="inner"><span>fibonacci-seq</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-flat-vec"><div class="inner"><span>flat-vec</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-forv"><div class="inner"><span>forv</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-glue"><div class="inner"><span>glue</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-grab"><div class="inner"><span>grab</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-has-none.3F"><div class="inner"><span>has-none?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-has-some.3F"><div class="inner"><span>has-some?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-if-java-1-7-plus"><div class="inner"><span>if-java-1-7-plus</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-if-java-1-8-plus"><div class="inner"><span>if-java-1-8-plus</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-increasing-or-equal.3F"><div class="inner"><span>increasing-or-equal?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-increasing.3F"><div class="inner"><span>increasing?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-index-using"><div class="inner"><span>index-using</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-insert-at"><div class="inner"><span>insert-at</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-int-.3Ekw"><div class="inner"><span>int-&gt;kw</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-clojure-1-7-plus.3F"><div class="inner"><span>is-clojure-1-7-plus?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-clojure-1-8-plus.3F"><div class="inner"><span>is-clojure-1-8-plus?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-clojure-1-9-plus.3F"><div class="inner"><span>is-clojure-1-9-plus?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-java-1-7-plus.3F"><div class="inner"><span>is-java-1-7-plus?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-java-1-7.3F"><div class="inner"><span>is-java-1-7?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-java-1-8-plus.3F"><div class="inner"><span>is-java-1-8-plus?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-java-1-8.3F"><div class="inner"><span>is-java-1-8?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-pre-clojure-1-8.3F"><div class="inner"><span>is-pre-clojure-1-8?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-is-pre-clojure-1-9.3F"><div class="inner"><span>is-pre-clojure-1-9?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-it-.3E"><div class="inner"><span>it-&gt;</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-java-version"><div class="inner"><span>java-version</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-java-version-matches.3F"><div class="inner"><span>java-version-matches?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-java-version-min.3F"><div class="inner"><span>java-version-min?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-json-.3Eclj"><div class="inner"><span>json-&gt;clj</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-keep-if"><div class="inner"><span>keep-if</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-keyvals"><div class="inner"><span>keyvals</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-kw-.3Eint"><div class="inner"><span>kw-&gt;int</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-kw-.3Estr"><div class="inner"><span>kw-&gt;str</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-kw-.3Esym"><div class="inner"><span>kw-&gt;sym</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-lazy-cons"><div class="inner"><span>lazy-cons</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-lazy-gen"><div class="inner"><span>lazy-gen</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-let-spy"><div class="inner"><span>let-spy</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-let-spy-pretty"><div class="inner"><span>let-spy-pretty</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-macro.3F"><div class="inner"><span>macro?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-map-keys-.3Evals"><div class="inner"><span>map-keys-&gt;vals</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-map-let"><div class="inner"><span>map-let</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-map-let*"><div class="inner"><span>map-let*</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-mapper"><div class="inner"><span>mapper</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-matches.3F"><div class="inner"><span>matches?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-nl"><div class="inner"><span>nl</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-not-empty.3F"><div class="inner"><span>not-empty?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-not-nil.3F"><div class="inner"><span>not-nil?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-only"><div class="inner"><span>only</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-partition-using"><div class="inner"><span>partition-using</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-prepend"><div class="inner"><span>prepend</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-pretty"><div class="inner"><span>pretty</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-pretty-str"><div class="inner"><span>pretty-str</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-print-versions"><div class="inner"><span>print-versions</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-range-vec"><div class="inner"><span>range-vec</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-refer-tupelo"><div class="inner"><span>refer-tupelo</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-rel.3D"><div class="inner"><span>rel=</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-replace-at"><div class="inner"><span>replace-at</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-safe-.3E"><div class="inner"><span>safe-&gt;</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-seq-.3Estr"><div class="inner"><span>seq-&gt;str</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-seqable.3F"><div class="inner"><span>seqable?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-split-match"><div class="inner"><span>split-match</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-split-using"><div class="inner"><span>split-using</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-spy"><div class="inner"><span>spy</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-spy-let"><div class="inner"><span>spy-let</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-spy-let-pretty"><div class="inner"><span>spy-let-pretty</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-spyx"><div class="inner"><span>spyx</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-spyx-pretty"><div class="inner"><span>spyx-pretty</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-spyxx"><div class="inner"><span>spyxx</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-starts-with.3F"><div class="inner"><span>starts-with?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-str-.3Ekw"><div class="inner"><span>str-&gt;kw</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-str-.3Esym"><div class="inner"><span>str-&gt;sym</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-strcat"><div class="inner"><span>strcat</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-submap-by-keys"><div class="inner"><span>submap-by-keys</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-submap-by-vals"><div class="inner"><span>submap-by-vals</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-submap.3F"><div class="inner"><span>submap?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-submatch.3F"><div class="inner"><span>submatch?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-sym-.3Ekw"><div class="inner"><span>sym-&gt;kw</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-sym-.3Estr"><div class="inner"><span>sym-&gt;str</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-third"><div class="inner"><span>third</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-thru"><div class="inner"><span>thru</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-truthy.3F"><div class="inner"><span>truthy?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-unnest"><div class="inner"><span>unnest</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-unwrap"><div class="inner"><span>unwrap</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-val.3D"><div class="inner"><span>val=</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-validate"><div class="inner"><span>validate</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-vals-.3Emap"><div class="inner"><span>vals-&gt;map</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-vec-.3Elist"><div class="inner"><span>vec-&gt;list</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-when-clojure-1-8-plus"><div class="inner"><span>when-clojure-1-8-plus</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-when-clojure-1-9-plus"><div class="inner"><span>when-clojure-1-9-plus</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-when-not-clojure-1-9-plus"><div class="inner"><span>when-not-clojure-1-9-plus</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-wild-item.3F"><div class="inner"><span>wild-item?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-wild-match-ctx.3F"><div class="inner"><span>wild-match-ctx?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-wild-match.3F"><div class="inner"><span>wild-match?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-wild-submatch.3F"><div class="inner"><span>wild-submatch?</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-with-exception-default"><div class="inner"><span>with-exception-default</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-with-map-vals"><div class="inner"><span>with-map-vals</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-with-spy-enabled"><div class="inner"><span>with-spy-enabled</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-with-spy-indent"><div class="inner"><span>with-spy-indent</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-xfirst"><div class="inner"><span>xfirst</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-xrest"><div class="inner"><span>xrest</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-xsecond"><div class="inner"><span>xsecond</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-xthird"><div class="inner"><span>xthird</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-yield"><div class="inner"><span>yield</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-yield-all"><div class="inner"><span>yield-all</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-zip"><div class="inner"><span>zip</span></div></a></li><li class="depth-1"><a href="tupelo.core.html#var-zip*"><div class="inner"><span>zip*</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">tupelo.core</h1><div class="doc"><pre class="plaintext">Tupelo - Making Clojure even sweeter
</pre></div><div class="public anchor" id="var--.3Evec"><h3>-&gt;vec</h3><div class="usage"><code>(-&gt;vec &amp; args)</code></div><div class="doc"><pre class="plaintext">Inputs: [&amp; args :- [s/Any]]
Returns: [s/Any]</pre></div></div><div class="public anchor" id="var--main"><h3>-main</h3><div class="usage"><code>(-main &amp; args)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-append"><h3>append</h3><div class="usage"><code>(append listy &amp; elems)</code></div><div class="doc"><pre class="plaintext">Inputs: [listy :- tsk/List &amp; elems :- [s/Any]]
Returns: tsk/List

Given a sequential object (vector or list), add one or more elements to the end.</pre></div></div><div class="public anchor" id="var-char-seq"><h3>char-seq</h3><div class="usage"><code>(char-seq start-char stop-char)</code></div><div class="doc"><pre class="plaintext">Given two characters (or numerical equivalents), returns a seq of characters
(inclusive) from the first to the second.  Characters must be in ascending order.</pre></div></div><div class="public anchor" id="var-check-spy-enabled"><h3>check-spy-enabled</h3><h4 class="type">macro</h4><div class="usage"><code>(check-spy-enabled tag &amp; forms)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-clip-str"><h3>clip-str</h3><div class="usage"><code>(clip-str nchars &amp; args)</code></div><div class="doc"><pre class="plaintext">Converts all args to single string and clips any characters beyond nchars.
</pre></div></div><div class="public anchor" id="var-clj-.3Ejson"><h3>clj-&gt;json</h3><div class="usage"><code>(clj-&gt;json arg)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-conjv"><h3>conjv</h3><h4 class="deprecated">deprecated</h4><div class="usage"><code>(conjv base-coll value)</code><code>(conjv base-coll value &amp; values)</code></div><div class="doc"><pre class="plaintext">Inputs: ([base-coll :- [s/Any] value :- s/Any] [base-coll :- [s/Any] value :- s/Any &amp; values :- [s/Any]])
Returns: [s/Any]

***** DEPRECATED:  replaced by tupelo.core/append *****

 Given base-coll and and one or more values, converts base-coll to a vector and then appends the values.
 The result is always returned as a vector. Note that `(conjv nil 5)` -&gt; `[5]`</pre></div></div><div class="public anchor" id="var-contains-elem.3F"><h3>contains-elem?</h3><div class="usage"><code>(contains-elem? coll elem)</code></div><div class="doc"><pre class="plaintext">Inputs: [coll :- s/Any elem :- s/Any]
Returns: s/Bool

For any collection coll &amp; element tgt, returns true if coll contains at least one
instance of tgt; otherwise returns false. Note that, for maps, each element is a
vector (i.e MapEntry) of the form [key value].</pre></div></div><div class="public anchor" id="var-contains-key.3F"><h3>contains-key?</h3><div class="usage"><code>(contains-key? map-or-set elem)</code></div><div class="doc"><pre class="plaintext">Inputs: [map-or-set :- (s/pred (fn* [p1__14529#] (or (map? p1__14529#) (set? p1__14529#)))) elem :- s/Any]
Returns: s/Bool

For any map or set, returns true if elem is a map key or set element, respectively</pre></div></div><div class="public anchor" id="var-contains-val.3F"><h3>contains-val?</h3><div class="usage"><code>(contains-val? map elem)</code></div><div class="doc"><pre class="plaintext">Inputs: [map :- tsk/Map elem :- s/Any]
Returns: s/Bool

For any map, returns true if elem is present in the map for at least one key.</pre></div></div><div class="public anchor" id="var-dissoc-in"><h3>dissoc-in</h3><div class="usage"><code>(dissoc-in the-map keys-vec)</code></div><div class="doc"><pre class="plaintext">Inputs: [the-map :- ts/KeyMap keys-vec :- [s/Keyword]]
Returns: s/Any

A sane version of dissoc-in that will not delete intermediate keys.
 When invoked as (dissoc-in the-map [:k1 :k2 :k3... :kZ]), acts like
 (clojure.core/update-in the-map [:k1 :k2 :k3...] dissoc :kZ). That is, only
 the map entry containing the last key :kZ is removed, and all map entries
 higher than kZ in the hierarchy are unaffected.</pre></div></div><div class="public anchor" id="var-drop-at"><h3>drop-at</h3><div class="usage"><code>(drop-at coll index)</code></div><div class="doc"><pre class="plaintext">Inputs: [coll :- tsk/List index :- s/Int]
Returns: tsk/List

Removes an element from a collection at the specified index.</pre></div></div><div class="public anchor" id="var-drop-if"><h3>drop-if</h3><div class="usage"><code>(drop-if pred coll)</code></div><div class="doc"><pre class="plaintext">Returns a vector of items in coll for which (pred item) is false (alias for clojure.core/remove)
</pre></div></div><div class="public anchor" id="var-falsey.3F"><h3>falsey?</h3><div class="usage"><code>(falsey? arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [arg :- s/Any]
Returns: s/Bool

Returns true if arg is logical false (either nil or false); otherwise returns false. Equivalent
 to (not (truthy? arg)).</pre></div></div><div class="public anchor" id="var-fetch"><h3>fetch</h3><div class="usage"><code>(fetch the-map the-key)</code></div><div class="doc"><pre class="plaintext">Inputs: [the-map :- tsk/Map the-key :- s/Any]
Returns: s/Any

A fail-fast version of keyword/map lookup.  When invoked as (grab the-map :the-key),
 returns the value associated with :the-key as for (clojure.core/get the-map :the-key).
 Throws an Exception if :the-key is not present in the-map.</pre></div></div><div class="public anchor" id="var-fetch-in"><h3>fetch-in</h3><div class="usage"><code>(fetch-in the-map keys-vec)</code></div><div class="doc"><pre class="plaintext">Inputs: [the-map :- tsk/Map keys-vec :- tsk/Vec]
Returns: s/Any

A fail-fast version of clojure.core/get-in. When invoked as (fetch-in the-map keys-vec),
 returns the value associated with keys-vec as for (clojure.core/get-in the-map keys-vec).
 Throws an Exception if the path keys-vec is not present in the-map.</pre></div></div><div class="public anchor" id="var-fibo-nth"><h3>fibo-nth</h3><div class="usage"><code>(fibo-nth N)</code></div><div class="doc"><pre class="plaintext">Returns the N'th Fibonacci number (zero-based). Note that
N=91 corresponds to approx 2^62</pre></div></div><div class="public anchor" id="var-fibo-thru"><h3>fibo-thru</h3><div class="usage"><code>(fibo-thru limit)</code></div><div class="doc"><pre class="plaintext">Returns a vector of Fibonacci numbers up to limit (inclusive). Note that a
2^62  corresponds to 91'st Fibonacci number.</pre></div></div><div class="public anchor" id="var-fibonacci-seq"><h3>fibonacci-seq</h3><div class="usage"><code>(fibonacci-seq)</code></div><div class="doc"><pre class="plaintext">A lazy seq of Fibonacci numbers (memoized).
</pre></div></div><div class="public anchor" id="var-flat-vec"><h3>flat-vec</h3><div class="usage"><code>(flat-vec &amp; args)</code></div><div class="doc"><pre class="plaintext">Accepts any number of nested args and returns the flattened result as a vector.
</pre></div></div><div class="public anchor" id="var-forv"><h3>forv</h3><h4 class="type">macro</h4><div class="usage"><code>(forv &amp; body)</code></div><div class="doc"><pre class="plaintext">Like clojure.core/for but returns results in a vector.   Not lazy.
</pre></div></div><div class="public anchor" id="var-glue"><h3>glue</h3><div class="usage"><code>(glue &amp; colls)</code></div><div class="doc"><pre class="plaintext">Glues together like collections:

  (glue [1 2] [3 4] [5 6])                -&gt; [1 2 3 4 5 6]
  (glue {:a 1} {:b 2} {:c 3})             -&gt; {:a 1 :c 3 :b 2}
  (glue #{1 2} #{3 4} #{6 5})             -&gt; #{1 2 6 5 3 4}
  (glue "I" " like " \a " nap!" )  -&gt; "I like a nap!"

If you want to convert to a sorted set or map, just put an empty one first:

  (glue (sorted-map) {:a 1} {:b 2} {:c 3})      -&gt; {:a 1 :b 2 :c 3}
  (glue (sorted-set) #{1 2} #{3 4} #{6 5})      -&gt; #{1 2 3 4 5 6}

If there are duplicate keys when using glue for maps or sets, then "the last one wins":

  (glue {:band :VanHalen :singer :Dave}  {:singer :Sammy}) </pre></div></div><div class="public anchor" id="var-grab"><h3>grab</h3><div class="usage"><code>(grab the-key the-map)</code></div><div class="doc"><pre class="plaintext">Inputs: [the-key :- s/Any the-map :- tsk/Map]
Returns: s/Any

A fail-fast version of keyword/map lookup.  When invoked as (grab :the-key the-map),
 returns the value associated with :the-key as for (clojure.core/get the-map :the-key).
 Throws an Exception if :the-key is not present in the-map.</pre></div></div><div class="public anchor" id="var-has-none.3F"><h3>has-none?</h3><div class="usage"><code>(has-none? pred coll)</code></div><div class="doc"><pre class="plaintext">Inputs: [pred :- s/Any coll :- [s/Any]]
Returns: s/Bool

For any predicate pred &amp; collection coll, returns false if (pred x) is logical true for at least one x in
 coll; otherwise returns true.  Equivalent to clojure.core/not-any?, but inverse of has-some?.</pre></div></div><div class="public anchor" id="var-has-some.3F"><h3>has-some?</h3><div class="usage"><code>(has-some? pred coll)</code></div><div class="doc"><pre class="plaintext">Inputs: [pred :- s/Any coll :- [s/Any]]
Returns: s/Bool

For any predicate pred &amp; collection coll, returns true if (pred x) is logical true for at least one x in
 coll; otherwise returns false.  Like clojure.core/some, but returns only true or false.</pre></div></div><div class="public anchor" id="var-if-java-1-7-plus"><h3>if-java-1-7-plus</h3><h4 class="type">macro</h4><div class="usage"><code>(if-java-1-7-plus if-form else-form)</code></div><div class="doc"><pre class="plaintext">If JVM is Java 1.7 or higher, evaluates if-form into code. Otherwise, evaluates else-form.
</pre></div></div><div class="public anchor" id="var-if-java-1-8-plus"><h3>if-java-1-8-plus</h3><h4 class="type">macro</h4><div class="usage"><code>(if-java-1-8-plus if-form else-form)</code></div><div class="doc"><pre class="plaintext">If JVM is Java 1.8 or higher, evaluates if-form into code. Otherwise, evaluates else-form.
</pre></div></div><div class="public anchor" id="var-increasing-or-equal.3F"><h3>increasing-or-equal?</h3><div class="usage"><code>(increasing-or-equal? a b)</code></div><div class="doc"><pre class="plaintext">Inputs: [a :- ts/List b :- ts/List]
Returns: s/Bool

Returns true iff the vectors are in (strictly) lexicographically increasing order
  [1 2]  [1]        -&gt; false
  [1 2]  [1 1]      -&gt; false
  [1 2]  [1 2]      -&gt; true
  [1 2]  [1 2 nil]  -&gt; true
  [1 2]  [1 2 3]    -&gt; true
  [1 2]  [1 3]      -&gt; true
  [1 2]  [2 1]      -&gt; true
  [1 2]  [2]        -&gt; true
</pre></div></div><div class="public anchor" id="var-increasing.3F"><h3>increasing?</h3><div class="usage"><code>(increasing? a b)</code></div><div class="doc"><pre class="plaintext">Inputs: [a :- ts/List b :- ts/List]
Returns: s/Bool

Returns true iff the vectors are in (strictly) lexicographically increasing order
  [1 2]  [1]        -&gt; false
  [1 2]  [1 1]      -&gt; false
  [1 2]  [1 2]      -&gt; false
  [1 2]  [1 2 nil]  -&gt; true
  [1 2]  [1 2 3]    -&gt; true
  [1 2]  [1 3]      -&gt; true
  [1 2]  [2 1]      -&gt; true
  [1 2]  [2]        -&gt; true
</pre></div></div><div class="public anchor" id="var-index-using"><h3>index-using</h3><div class="usage"><code>(index-using pred coll)</code></div><div class="doc"><pre class="plaintext">Finds the first index N where (&lt; N (count coll)) such that (pred (drop N coll)) is truthy.
Returns `nil` if no match found.</pre></div></div><div class="public anchor" id="var-insert-at"><h3>insert-at</h3><div class="usage"><code>(insert-at coll index elem)</code></div><div class="doc"><pre class="plaintext">Inputs: [coll :- tsk/List index :- s/Int elem :- s/Any]
Returns: tsk/List

Inserts an element into a collection at the specified index.</pre></div></div><div class="public anchor" id="var-int-.3Ekw"><h3>int-&gt;kw</h3><div class="usage"><code>(int-&gt;kw arg)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-clojure-1-7-plus.3F"><h3>is-clojure-1-7-plus?</h3><div class="usage"><code>(is-clojure-1-7-plus?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-clojure-1-8-plus.3F"><h3>is-clojure-1-8-plus?</h3><div class="usage"><code>(is-clojure-1-8-plus?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-clojure-1-9-plus.3F"><h3>is-clojure-1-9-plus?</h3><div class="usage"><code>(is-clojure-1-9-plus?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-java-1-7-plus.3F"><h3>is-java-1-7-plus?</h3><div class="usage"><code>(is-java-1-7-plus?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-java-1-7.3F"><h3>is-java-1-7?</h3><div class="usage"><code>(is-java-1-7?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-java-1-8-plus.3F"><h3>is-java-1-8-plus?</h3><div class="usage"><code>(is-java-1-8-plus?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-java-1-8.3F"><h3>is-java-1-8?</h3><div class="usage"><code>(is-java-1-8?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-pre-clojure-1-8.3F"><h3>is-pre-clojure-1-8?</h3><div class="usage"><code>(is-pre-clojure-1-8?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-is-pre-clojure-1-9.3F"><h3>is-pre-clojure-1-9?</h3><div class="usage"><code>(is-pre-clojure-1-9?)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-it-.3E"><h3>it-&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(it-&gt; expr &amp; forms)</code></div><div class="doc"><pre class="plaintext">A threading macro like as-&gt; that always uses the symbol 'it' as the placeholder for the next threaded value:
(it-&gt; 1
      (inc it)
      (+ it 3)
      (/ 10 it))
;=&gt; 2
</pre></div></div><div class="public anchor" id="var-java-version"><h3>java-version</h3><div class="usage"><code>(java-version)</code></div><div class="doc"><pre class="plaintext">Inputs: []
Returns: s/Str</pre></div></div><div class="public anchor" id="var-java-version-matches.3F"><h3>java-version-matches?</h3><div class="usage"><code>(java-version-matches? version-str)</code></div><div class="doc"><pre class="plaintext">Inputs: [version-str :- s/Str]
Returns: s/Bool

Returns true if Java version exactly matches supplied string.</pre></div></div><div class="public anchor" id="var-java-version-min.3F"><h3>java-version-min?</h3><div class="usage"><code>(java-version-min? version-str)</code></div><div class="doc"><pre class="plaintext">Inputs: [version-str :- s/Str]
Returns: s/Bool

Returns true if Java version is at least as great as supplied string.
Sort is by lexicographic (alphabetic) order.</pre></div></div><div class="public anchor" id="var-json-.3Eclj"><h3>json-&gt;clj</h3><div class="usage"><code>(json-&gt;clj arg)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-keep-if"><h3>keep-if</h3><div class="usage"><code>(keep-if pred coll)</code></div><div class="doc"><pre class="plaintext">Returns a vector of items in coll for which (pred item) is true (alias for clojure.core/filter)
</pre></div></div><div class="public anchor" id="var-keyvals"><h3>keyvals</h3><div class="usage"><code>(keyvals m)</code></div><div class="doc"><pre class="plaintext">Inputs: [m :- tsk/Map]
Returns: [s/Any]

For any map m, returns the (alternating) keys &amp; values of m as a vector, suitable for reconstructing m via
 (apply hash-map (keyvals m)). (keyvals {:a 1 :b 2} =&gt; [:a 1 :b 2] </pre></div></div><div class="public anchor" id="var-kw-.3Eint"><h3>kw-&gt;int</h3><div class="usage"><code>(kw-&gt;int arg)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-kw-.3Estr"><h3>kw-&gt;str</h3><div class="usage"><code>(kw-&gt;str arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [arg :- s/Keyword]
Returns: s/Str</pre></div></div><div class="public anchor" id="var-kw-.3Esym"><h3>kw-&gt;sym</h3><div class="usage"><code>(kw-&gt;sym arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [arg :- s/Keyword]
Returns: s/Symbol</pre></div></div><div class="public anchor" id="var-lazy-cons"><h3>lazy-cons</h3><h4 class="type">macro</h4><div class="usage"><code>(lazy-cons curr-val next-form)</code></div><div class="doc"><pre class="plaintext">The simple way to create a lazy sequence:
(defn lazy-next-int [n]
  (t/lazy-cons n (lazy-next-int (inc n))))
(def all-ints (lazy-next-int 0)) </pre></div></div><div class="public anchor" id="var-lazy-gen"><h3>lazy-gen</h3><h4 class="type">macro</h4><div class="usage"><code>(lazy-gen &amp; forms)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-let-spy"><h3>let-spy</h3><h4 class="type">macro</h4><div class="usage"><code>(let-spy &amp; exprs)</code></div><div class="doc"><pre class="plaintext">An expression (println ...) for use in threading forms (&amp; elsewhere). Evaluates the supplied
expressions, printing both the expression and its value to stdout. Returns the value of the
last expression.</pre></div></div><div class="public anchor" id="var-let-spy-pretty"><h3>let-spy-pretty</h3><h4 class="type">macro</h4><div class="usage"><code>(let-spy-pretty &amp; exprs)</code></div><div class="doc"><pre class="plaintext">An expression (println ...) for use in threading forms (&amp; elsewhere). Evaluates the supplied
expressions, printing both the expression and its value to stdout. Returns the value of the
last expression.</pre></div></div><div class="public anchor" id="var-macro.3F"><h3>macro?</h3><div class="usage"><code>(macro? s)</code></div><div class="doc"><pre class="plaintext">Returns true if a quoted symbol resolves to a macro. Usage:

(println (macro? 'and))  ;=&gt; true
</pre></div></div><div class="public anchor" id="var-map-keys-.3Evals"><h3>map-keys-&gt;vals</h3><div class="usage"><code>(map-keys-&gt;vals map keys)</code></div><div class="doc"><pre class="plaintext">Inputs: [map :- tsk/KeyMap keys :- [s/Keyword]]
Returns: tsk/List

Returns a vector of values for each key, in the order specified. Throws for missing keys.</pre></div></div><div class="public anchor" id="var-map-let"><h3>map-let</h3><h4 class="type">macro</h4><div class="usage"><code>(map-let bindings &amp; forms)</code></div><div class="doc"><pre class="plaintext">Usage:
  (map-let bindings &amp; forms)

Given bindings and forms like `(map-let [x xs, y ys, ...] (+ x y))`, will iterate over the
collections [xs ys ...] assigning successive values of each collection to [x y ...], respectively.
The local symbols [x y ...] can then be used in `forms` to generate the output mapping.
Will throw if collections are not all of the same length. Not lazy.</pre></div></div><div class="public anchor" id="var-map-let*"><h3>map-let*</h3><h4 class="type">macro</h4><div class="usage"><code>(map-let* context bindings &amp; forms)</code></div><div class="doc"><pre class="plaintext">Usage:  (map-let* ctx bindings &amp; forms)

where ctx is a map with default values:
  {:strict true
   :lazy   false}</pre></div></div><div class="public anchor" id="var-mapper"><h3>mapper</h3><div class="usage"><code>(mapper &amp; args)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-matches.3F"><h3>matches?</h3><h4 class="type">macro</h4><div class="usage"><code>(matches? pattern &amp; values)</code></div><div class="doc"><pre class="plaintext">A shortcut to clojure.core.match/match to aid in testing.  Returns true if the data value
matches the pattern value.  Underscores serve as wildcard values. Usage:

  (matches? pattern &amp; values)

sample:

  (matches?  [1 _ 3] [1 2 3] )         ;=&gt; true
  (matches?  {:a _ :b _       :c 3}
             {:a 1 :b [1 2 3] :c 3}
             {:a 2 :b 99      :c 3}
             {:a 3 :b nil     :c 3} )  ;=&gt; true

Note that a wildcald can match either a primitive or a composite value.</pre></div></div><div class="public anchor" id="var-nl"><h3>nl</h3><div class="usage"><code>(nl)</code></div><div class="doc"><pre class="plaintext">Abbreviated name for `newline` 
</pre></div></div><div class="public anchor" id="var-not-empty.3F"><h3>not-empty?</h3><div class="usage"><code>(not-empty? coll)</code></div><div class="doc"><pre class="plaintext">Inputs: [coll]
Returns: s/Bool

For any collection coll, returns true if coll contains any items; otherwise returns false.
 Equivalent to (not (empty? coll)).</pre></div></div><div class="public anchor" id="var-not-nil.3F"><h3>not-nil?</h3><div class="usage"><code>(not-nil? arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [arg :- s/Any]
Returns: s/Bool

Returns true if arg is not nil; false otherwise. Equivalent to (not (nil? arg)),
 or the poorly-named clojure.core/some? </pre></div></div><div class="public anchor" id="var-only"><h3>only</h3><div class="usage"><code>(only coll)</code></div><div class="doc"><pre class="plaintext">(only coll-in)
Ensures that a sequence is of length=1, and returns the only value present.
Throws an exception if the length of the sequence is not one.
Note that, for a length-1 sequence S, (first S), (last S) and (only S) are equivalent.</pre></div></div><div class="public anchor" id="var-partition-using"><h3>partition-using</h3><div class="usage"><code>(partition-using pred values)</code></div><div class="doc"><pre class="plaintext">Inputs: [pred :- s/Any values :- ts/List]

Partitions a collection into vector of segments based on a predicate with a collection argument.
The first segment is initialized by removing the first element from `values`, with subsequent
elements similarly transferred as long as `(pred remaining-values)` is falsey. When
`(pred remaining-values)` becomes truthy, the algorithm begins building the next segment.
Thus, the first partition finds the smallest N (&lt; 0 N) such that (pred (drop N values))
is true, and constructs the segment as (take N values). If pred is never satisified,
[values] is returned.</pre></div></div><div class="public anchor" id="var-prepend"><h3>prepend</h3><div class="usage"><code>(prepend &amp; args)</code></div><div class="doc"><pre class="plaintext">Inputs: [&amp; args]
Returns: tsk/List

Given a sequential object (vector or list), add one or more elements to the beginning</pre></div></div><div class="public anchor" id="var-pretty"><h3>pretty</h3><div class="usage"><code>(pretty arg)</code><code>(pretty arg writer)</code></div><div class="doc"><pre class="plaintext">Shortcut to clojure.pprint/pprint. Returns it argument.
</pre></div></div><div class="public anchor" id="var-pretty-str"><h3>pretty-str</h3><div class="usage"><code>(pretty-str arg)</code></div><div class="doc"><pre class="plaintext">Returns a string that is the result of clojure.pprint/pprint
</pre></div></div><div class="public anchor" id="var-print-versions"><h3>print-versions</h3><div class="usage"><code>(print-versions)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-range-vec"><h3>range-vec</h3><div class="usage"><code>(range-vec &amp; args)</code></div><div class="doc"><pre class="plaintext">An eager version clojure.core/range that always returns its result in a vector.
</pre></div></div><div class="public anchor" id="var-refer-tupelo"><h3>refer-tupelo</h3><div class="usage"><code>(refer-tupelo)</code></div><div class="doc"><pre class="plaintext">Refer a number of commonly used tupelo.core functions into the current namespace so they can
be used without namespace qualification.</pre></div></div><div class="public anchor" id="var-rel.3D"><h3>rel=</h3><div class="usage"><code>(rel= val1 val2 &amp; {:as opts})</code></div><div class="doc"><pre class="plaintext">Returns true if 2 double-precision numbers are relatively equal, else false.  Relative equality
is specified as either (1) the N most significant digits are equal, or (2) the absolute
difference is less than a tolerance value.  Input values are coerced to double before comparison.
Example:

  (rel= 123450000 123456789   :digits 4   )  ; true
  (rel= 1         1.001       :tol    0.01)  ; true
</pre></div></div><div class="public anchor" id="var-replace-at"><h3>replace-at</h3><div class="usage"><code>(replace-at coll index elem)</code></div><div class="doc"><pre class="plaintext">Inputs: [coll :- tsk/List index :- s/Int elem :- s/Any]
Returns: tsk/List

Replaces an element in a collection at the specified index.</pre></div></div><div class="public anchor" id="var-safe-.3E"><h3>safe-&gt;</h3><h4 class="type">macro</h4><div class="usage"><code>(safe-&gt; expr &amp; forms)</code></div><div class="doc"><pre class="plaintext">When expr is not nil, threads it into the first form (via -&gt;), and when that result is not nil,
through the next etc.  If result is nil, throw IllegalArgumentException</pre></div></div><div class="public anchor" id="var-seq-.3Estr"><h3>seq-&gt;str</h3><div class="usage"><code>(seq-&gt;str seq-in)</code></div><div class="doc"><pre class="plaintext">Convert a seq into a string (using pr) with a space preceding each value
</pre></div></div><div class="public anchor" id="var-seqable.3F"><h3>seqable?</h3><h4 class="deprecated">deprecated in 1.9.0-alpha5</h4><div class="usage"><code>(seqable? x)</code></div><div class="doc"><pre class="plaintext">Returns true if (seq x) will succeed, false otherwise.
</pre></div></div><div class="public anchor" id="var-split-match"><h3>split-match</h3><div class="usage"><code>(split-match coll tgt)</code></div><div class="doc"><pre class="plaintext">Splits a collection src by matching with a sub-sequence tgt of length L.
Finds the first index N such that (= tgt (-&gt;&gt; coll (drop N) (take L))) is true.
Returns a length-2 vector of [ (take N coll) (drop N coll) ].
If no match is found, [ coll [] ] is returned.</pre></div></div><div class="public anchor" id="var-split-using"><h3>split-using</h3><div class="usage"><code>(split-using pred coll)</code></div><div class="doc"><pre class="plaintext">Splits a collection based on a predicate with a collection argument.
Finds the first index N such that (pred (drop N coll)) is true. Returns a length-2 vector
of [ (take N coll) (drop N coll) ]. If pred is never satisified, [ coll [] ] is returned.</pre></div></div><div class="public anchor" id="var-spy"><h3>spy</h3><div class="usage"><code>(spy arg1 arg2 arg3)</code><code>(spy msg value)</code><code>(spy value)</code></div><div class="doc"><pre class="plaintext">A form of (println ...) to ease debugging display of either intermediate values in threading
forms or function return values. There are three variants.  Usage:

 (spy :msg &lt;msg-string&gt;)
     This variant is intended for use in either thread-first (-&gt;) or thread-last (-&gt;&gt;)
     forms.  The keyword :msg is used to identify the message string and works equally
     well for both the -&gt; and -&gt;&gt; operators. Spy prints both &lt;msg-string&gt;  and the
     threading value to stdout, then returns the value for further propogation in the
     threading form. For example, both of the following:
         (-&gt;   2
               (+ 3)
               (spy :msg "sum" )
               (* 4))
         (-&gt;&gt;  2
               (+ 3)
               (spy :msg "sum" )
               (* 4))
     will print 'sum =&gt; 5' to stdout.

 (spy &lt;msg-string&gt; &lt;value&gt;)
     This variant is intended for simpler use cases such as function return values.
     Function return value expressions often invoke other functions and cannot be
     easily displayed since (println ...) swallows the return value and returns nil
     itself.  Spy will output both &lt;msg-string&gt; and the value, then return the value
     for use by further processing.  For example, the following:
         (println (* 2
                    (spy "sum" (+ 3 4))))
   will print:
         sum =&gt; 7
         14
   to stdout.

 (spy &lt;value&gt;)
     This variant is intended for use in very simple situations and is the same as the
     2-argument arity where &lt;msg-string&gt; defaults to 'spy'.  For example (spy (+ 2 3))
     prints 'spy =&gt; 5' to stdout.  </pre></div></div><div class="public anchor" id="var-spy-let"><h3>spy-let</h3><h4 class="type">macro</h4><div class="usage"><code>(spy-let &amp; exprs)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-spy-let-pretty"><h3>spy-let-pretty</h3><h4 class="type">macro</h4><div class="usage"><code>(spy-let-pretty &amp; exprs)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-spyx"><h3>spyx</h3><h4 class="type">macro</h4><div class="usage"><code>(spyx &amp; exprs)</code></div><div class="doc"><pre class="plaintext">An expression (println ...) for use in threading forms (&amp; elsewhere). Evaluates the supplied
expressions, printing both the expression and its value to stdout. Returns the value of the
last expression.</pre></div></div><div class="public anchor" id="var-spyx-pretty"><h3>spyx-pretty</h3><h4 class="type">macro</h4><div class="usage"><code>(spyx-pretty &amp; exprs)</code></div><div class="doc"><pre class="plaintext">Like `spyx` but with pretty printing (clojure.pprint/pprint)
</pre></div></div><div class="public anchor" id="var-spyxx"><h3>spyxx</h3><h4 class="type">macro</h4><div class="usage"><code>(spyxx expr)</code></div><div class="doc"><pre class="plaintext">An expression (println ...) for use in threading forms (&amp; elsewhere). Evaluates the supplied
expression, printing both the expression, its type, and its value to stdout, then returns the value.</pre></div></div><div class="public anchor" id="var-starts-with.3F"><h3>starts-with?</h3><div class="usage"><code>(starts-with? coll tgt-in)</code></div><div class="doc"><pre class="plaintext">Inputs: [coll tgt-in]
Returns: s/Bool

Returns true when the initial elements of coll match those of tgt</pre></div></div><div class="public anchor" id="var-str-.3Ekw"><h3>str-&gt;kw</h3><div class="usage"><code>(str-&gt;kw arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [arg :- s/Str]
Returns: s/Keyword</pre></div></div><div class="public anchor" id="var-str-.3Esym"><h3>str-&gt;sym</h3><div class="usage"><code>(str-&gt;sym arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [arg :- s/Str]
Returns: s/Symbol</pre></div></div><div class="public anchor" id="var-strcat"><h3>strcat</h3><div class="usage"><code>(strcat &amp; args)</code></div><div class="doc"><pre class="plaintext">Recursively concatenate all arguments into a single string result.
</pre></div></div><div class="public anchor" id="var-submap-by-keys"><h3>submap-by-keys</h3><div class="usage"><code>(submap-by-keys map-arg keep-keys &amp; opts)</code></div><div class="doc"><pre class="plaintext">Inputs: [map-arg :- tsk/Map keep-keys :- tsk/Set &amp; opts]
Returns: tsk/Map

Returns a new map containing entries with the specified keys. Throws for missing keys,
unless `:missing-ok` is specified. Usage:

    (submap-by-keys {:a 1 :b 2} #{:a   }             )  =&gt;  {:a 1}
    (submap-by-keys {:a 1 :b 2} #{:a :z} :missing-ok )  =&gt;  {:a 1}
</pre></div></div><div class="public anchor" id="var-submap-by-vals"><h3>submap-by-vals</h3><div class="usage"><code>(submap-by-vals map-arg keep-vals &amp; opts)</code></div><div class="doc"><pre class="plaintext">Inputs: [map-arg :- tsk/Map keep-vals :- tsk/Set &amp; opts]
Returns: tsk/Map

Returns a new map containing entries with the specified vals. Throws for missing vals,
unless `:missing-ok` is specified. Usage:

    (submap-by-vals {:a 1 :b 2 :A 1} #{1  }             )  =&gt;  {:a 1 :A 1}
    (submap-by-vals {:a 1 :b 2 :A 1} #{1 9} :missing-ok )  =&gt;  {:a 1 :A 1}
</pre></div></div><div class="public anchor" id="var-submap.3F"><h3>submap?</h3><div class="usage"><code>(submap? inner-map outer-map)</code></div><div class="doc"><pre class="plaintext">Inputs: [inner-map :- {s/Any s/Any} outer-map :- {s/Any s/Any}]
Returns: Boolean

Returns true if the map entries (key-value pairs) of one map are a subset of the entries of
 another map.  Similar to clojure.set/subset?</pre></div></div><div class="public anchor" id="var-submatch.3F"><h3>submatch?</h3><div class="usage"><code>(submatch? smaller larger)</code></div><div class="doc"><pre class="plaintext">Returns true if the first arg is (recursively) a subset/submap/subvec of the 2nd arg
</pre></div></div><div class="public anchor" id="var-sym-.3Ekw"><h3>sym-&gt;kw</h3><div class="usage"><code>(sym-&gt;kw arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [arg :- s/Symbol]
Returns: s/Keyword</pre></div></div><div class="public anchor" id="var-sym-.3Estr"><h3>sym-&gt;str</h3><div class="usage"><code>(sym-&gt;str arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [arg :- s/Symbol]
Returns: s/Str</pre></div></div><div class="public anchor" id="var-third"><h3>third</h3><div class="usage"><code>(third seqable-arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [seqable-arg :- ts/List]
Returns: s/Any

Returns the third item in a collection, or nil if fewer than three items are present. </pre></div></div><div class="public anchor" id="var-thru"><h3>thru</h3><div class="usage"><code>(thru end)</code><code>(thru start end)</code><code>(thru start end step)</code></div><div class="doc"><pre class="plaintext">Returns a sequence of integers. Like clojure.core/rng, but is inclusive of the right boundary value. Not lazy. 
</pre></div></div><div class="public anchor" id="var-truthy.3F"><h3>truthy?</h3><div class="usage"><code>(truthy? arg)</code></div><div class="doc"><pre class="plaintext">Returns true if arg is logical true (neither nil nor false); otherwise returns false.
</pre></div></div><div class="public anchor" id="var-unnest"><h3>unnest</h3><div class="usage"><code>(unnest &amp; values)</code></div><div class="doc"><pre class="plaintext">Inputs: [&amp; values]
Returns: [s/Any]

Given any set of arguments including vectors, maps, sets, &amp; scalars, performs a depth-first
recursive walk returning scalar args (int, string, keyword, etc) in a single 1-D vector.</pre></div></div><div class="public anchor" id="var-unwrap"><h3>unwrap</h3><div class="usage"><code>(unwrap data)</code></div><div class="doc"><pre class="plaintext">Inputs: [data :- [s/Any]]
Returns: Unwrapped</pre></div></div><div class="public anchor" id="var-val.3D"><h3>val=</h3><div class="usage"><code>(val= &amp; vals)</code></div><div class="doc"><pre class="plaintext">Inputs: [&amp; vals]
Returns: s/Bool

Compares values for equality using clojure.core/=, treating records as plain map values:

    (defrecord SampleRec [a b])
    (assert (val= (-&gt;SampleRec 1 2) {:a 1 :b 2}))   ; fails for clojure.core/=
</pre></div></div><div class="public anchor" id="var-validate"><h3>validate</h3><div class="usage"><code>(validate tst-fn tst-val)</code></div><div class="doc"><pre class="plaintext">(validate tst-fn tst-val)
Used to validate intermediate results. Returns tst-val if the result of
(tst-fn tst-val) is truthy.  Otherwise, throws IllegalStateException.</pre></div></div><div class="public anchor" id="var-vals-.3Emap"><h3>vals-&gt;map</h3><h4 class="type">macro</h4><div class="usage"><code>(vals-&gt;map &amp; symbols)</code></div><div class="doc"><pre class="plaintext">Called with a list of symbols like `(label-value-map a b c)` returns a labeled map
like {:a a :b b :c c} with the values for a, b, &amp; c.</pre></div></div><div class="public anchor" id="var-vec-.3Elist"><h3>vec-&gt;list</h3><div class="usage"><code>(vec-&gt;list arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [arg :- [s/Any]]
Returns: [s/Any]</pre></div></div><div class="public anchor" id="var-when-clojure-1-8-plus"><h3>when-clojure-1-8-plus</h3><h4 class="type">macro</h4><div class="usage"><code>(when-clojure-1-8-plus &amp; forms)</code></div><div class="doc"><pre class="plaintext">Wraps code that should only be included for Clojure 1.8 or higher.  Otherwise, code is supressed.
</pre></div></div><div class="public anchor" id="var-when-clojure-1-9-plus"><h3>when-clojure-1-9-plus</h3><h4 class="type">macro</h4><div class="usage"><code>(when-clojure-1-9-plus &amp; forms)</code></div><div class="doc"><pre class="plaintext">Wraps code that should only be included for Clojure 1.9 or higher.  Otherwise, code is supressed.
</pre></div></div><div class="public anchor" id="var-when-not-clojure-1-9-plus"><h3>when-not-clojure-1-9-plus</h3><h4 class="type">macro</h4><div class="usage"><code>(when-not-clojure-1-9-plus &amp; forms)</code></div><div class="doc"><pre class="plaintext">Wraps code that should only be included for Clojure versions prior to 1.9.  Otherwise, code is supressed.
</pre></div></div><div class="public anchor" id="var-wild-item.3F"><h3>wild-item?</h3><div class="usage"><code>(wild-item? item)</code></div><div class="doc"><pre class="plaintext">Inputs: [item :- s/Any]
Returns: s/Bool

Returns true if any element in a nested collection is the wildcard :*</pre></div></div><div class="public anchor" id="var-wild-match-ctx.3F"><h3>wild-match-ctx?</h3><div class="usage"><code>(wild-match-ctx? ctx-in pattern &amp; values)</code></div><div class="doc"><pre class="plaintext">Returns true if a pattern is matched by one or more values.  The special keyword :* (colon-star)
in the pattern serves as a wildcard value.  Note that a wildcald can match either a primitive or a
composite value: Usage:

  (wild-match-ctx? ctx pattern &amp; values)

samples:

  (wild-match-ctx? ctx {:a :* :b 2}
                       {:a 1  :b 2})         ;=&gt; true

  (wild-match-ctx? ctx [1 :* 3]
                       [1 2  3]
                       [1 9  3] ))           ;=&gt; true

  (wild-match-ctx? ctx {:a :*       :b 2}
                       {:a [1 2 3]  :b 2})   ;=&gt; true

wild-match? accepts a context map as an optional first argument which defaults to:

  (let [ctx {:submap-ok false
             :subset-ok false
             :subvec-ok false}]
    (wild-match-ctx? ctx pattern values))) </pre></div></div><div class="public anchor" id="var-wild-match.3F"><h3>wild-match?</h3><div class="usage"><code>(wild-match? pattern &amp; values)</code></div><div class="doc"><pre class="plaintext">Simple wrapper for wild-match-ctx? using the default context
</pre></div></div><div class="public anchor" id="var-wild-submatch.3F"><h3>wild-submatch?</h3><div class="usage"><code>(wild-submatch? pattern &amp; values)</code></div><div class="doc"><pre class="plaintext">Simple wrapper for wild-match-ctx? where all types of sub-matching are enabled.
</pre></div></div><div class="public anchor" id="var-with-exception-default"><h3>with-exception-default</h3><h4 class="type">macro</h4><div class="usage"><code>(with-exception-default default-val &amp; body)</code></div><div class="doc"><pre class="plaintext">Evaluates body &amp; returns its result.  In the event of an exception, default-val is returned
instead of the exception.</pre></div></div><div class="public anchor" id="var-with-map-vals"><h3>with-map-vals</h3><h4 class="type">macro</h4><div class="usage"><code>(with-map-vals the-map syms-vec &amp; forms)</code></div><div class="doc"><pre class="plaintext">Given a map like {:a 1 :b 2 :c 3} (such as generated by `(label-value-map a b c)`),
performs safe `let` destructuring using `grab` like:

   (def the-map {:a 1 :b 2 :c 3} }
   (with-map-vals the-map [a b c]  ...)

      =&gt;  (let [a (grab :a the-map)
                b (grab :b the-map)
                c (grab :c the-map) ]
             ... )

`with-map-fields` is safe for typos since `grab` will throw is the requrested map key is not present.</pre></div></div><div class="public anchor" id="var-with-spy-enabled"><h3>with-spy-enabled</h3><h4 class="type">macro</h4><div class="usage"><code>(with-spy-enabled tag &amp; forms)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-with-spy-indent"><h3>with-spy-indent</h3><h4 class="type">macro</h4><div class="usage"><code>(with-spy-indent &amp; body)</code></div><div class="doc"><pre class="plaintext">Increments indentation level of all spy, spyx, or spyxx expressions within the body.
</pre></div></div><div class="public anchor" id="var-xfirst"><h3>xfirst</h3><div class="usage"><code>(xfirst arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [arg :- [s/Any]]
Returns: s/Any

Returns the first value in a list or vector. Throws if empty.</pre></div></div><div class="public anchor" id="var-xrest"><h3>xrest</h3><div class="usage"><code>(xrest arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [arg :- [s/Any]]
Returns: s/Any

Returns a vector containing all but the first value in a list or vector. Throws if (zero? (count arg)).</pre></div></div><div class="public anchor" id="var-xsecond"><h3>xsecond</h3><div class="usage"><code>(xsecond arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [arg :- [s/Any]]
Returns: s/Any

Returns the second value in a list or vector. Throws if (&lt; len 2).</pre></div></div><div class="public anchor" id="var-xthird"><h3>xthird</h3><div class="usage"><code>(xthird arg)</code></div><div class="doc"><pre class="plaintext">Inputs: [arg :- [s/Any]]
Returns: s/Any

Returns the third value in a list or vector. Throws if (&lt; len 3).</pre></div></div><div class="public anchor" id="var-yield"><h3>yield</h3><h4 class="type">macro</h4><div class="usage"><code>(yield value)</code></div><div class="doc"><pre class="plaintext">Within a 'generator function' created by `lazy-gen`, populates the
result lazy seq with the supplied value (a la Python). Returns the value.</pre></div></div><div class="public anchor" id="var-yield-all"><h3>yield-all</h3><h4 class="type">macro</h4><div class="usage"><code>(yield-all values)</code></div><div class="doc"><pre class="plaintext">Within a 'generator function' created by `lazy-gen`, populates the
result lazy seq with each item from the supplied collection. Returns the collection.</pre></div></div><div class="public anchor" id="var-zip"><h3>zip</h3><div class="usage"><code>(zip &amp; args)</code></div><div class="doc"><pre class="plaintext">Zips together vectors like zipmap (like Python zip):

  (zip [:a :b :c] [1 2 3]) -&gt;  [ [:a 1] [:b 2] [:c 3] ]

Use (zip ... :trunc) if you want to truncate all inputs to the lenght of the shortest.
Use (zip ... :lazy)  if you want it to be lazy.  </pre></div></div><div class="public anchor" id="var-zip*"><h3>zip*</h3><div class="usage"><code>(zip* context &amp; colls)</code></div><div class="doc"><pre class="plaintext">Usage:  (zip* context &amp; colls)

where context is a map with default values:
  {:strict true
   :lazy   false}</pre></div></div></div></body></html>